// printing/backend/mojom/print_backend.mojom.js is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2014 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

(function() {
  var mojomId = 'printing/backend/mojom/print_backend.mojom';
  if (mojo.internal.isMojomLoaded(mojomId)) {
    console.warn('The following mojom is loaded multiple times: ' + mojomId);
    return;
  }
  mojo.internal.markMojomLoaded(mojomId);
  var bindings = mojo;
  var associatedBindings = mojo;
  var codec = mojo.internal;
  var validator = mojo.internal;

  var exports = mojo.internal.exposeNamespace('printing.mojom');
  var print$ =
      mojo.internal.exposeNamespace('printing.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'printing/mojom/print.mojom', '../../mojom/print.mojom.js');
  }
  var geometry$ =
      mojo.internal.exposeNamespace('gfx.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'ui/gfx/geometry/mojom/geometry.mojom', '../../../ui/gfx/geometry/mojom/geometry.mojom.js');
  }



  function PrinterBasicInfo(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  PrinterBasicInfo.prototype.initDefaults_ = function() {
    this.printerName = null;
    this.displayName = null;
    this.printerDescription = null;
    this.printerStatus = 0;
    this.isDefault = false;
    this.options = null;
  };
  PrinterBasicInfo.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  PrinterBasicInfo.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 48}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PrinterBasicInfo.printerName
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 0, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate PrinterBasicInfo.displayName
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 8, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate PrinterBasicInfo.printerDescription
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 16, false)
    if (err !== validator.validationError.NONE)
        return err;




    // validate PrinterBasicInfo.options
    err = messageValidator.validateMapPointer(offset + codec.kStructHeaderSize + 32, false, codec.String, codec.String, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  PrinterBasicInfo.encodedSize = codec.kStructHeaderSize + 40;

  PrinterBasicInfo.decode = function(decoder) {
    var packed;
    var val = new PrinterBasicInfo();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.printerName =
        decoder.decodeStruct(codec.String);
    val.displayName =
        decoder.decodeStruct(codec.String);
    val.printerDescription =
        decoder.decodeStruct(codec.String);
    val.printerStatus =
        decoder.decodeStruct(codec.Int32);
    packed = decoder.readUint8();
    val.isDefault = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.options =
        decoder.decodeMapPointer(codec.String, codec.String);
    return val;
  };

  PrinterBasicInfo.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(PrinterBasicInfo.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.String, val.printerName);
    encoder.encodeStruct(codec.String, val.displayName);
    encoder.encodeStruct(codec.String, val.printerDescription);
    encoder.encodeStruct(codec.Int32, val.printerStatus);
    packed = 0;
    packed |= (val.isDefault & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeMapPointer(codec.String, codec.String, val.options);
  };
  function Paper(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Paper.prototype.initDefaults_ = function() {
    this.displayName = null;
    this.vendorId = null;
    this.sizeUm = null;
    this.printableAreaUm = null;
    this.maxHeightUm = 0;
    this.hasBorderlessVariant = false;
  };
  Paper.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Paper.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 32},
      {version: 1, numBytes: 40},
      {version: 2, numBytes: 48},
      {version: 3, numBytes: 48}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Paper.displayName
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 0, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate Paper.vendorId
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 8, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate Paper.sizeUm
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, geometry$.Size, false);
    if (err !== validator.validationError.NONE)
        return err;



    // version check Paper.printableAreaUm
    if (!messageValidator.isFieldInStructVersion(offset, 1))
      return validator.validationError.NONE;
    // validate Paper.printableAreaUm
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 24, geometry$.Rect, true);
    if (err !== validator.validationError.NONE)
        return err;



    return validator.validationError.NONE;
  };

  Paper.encodedSize = codec.kStructHeaderSize + 40;

  Paper.decode = function(decoder) {
    var packed;
    var val = new Paper();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.displayName =
        decoder.decodeStruct(codec.String);
    val.vendorId =
        decoder.decodeStruct(codec.String);
    val.sizeUm =
        decoder.decodeStructPointer(geometry$.Size);
    if (version >= 1) {
      val.printableAreaUm =
          decoder.decodeStructPointer(geometry$.Rect);
    } else {
      val.printableAreaUm = null;
    }
    if (version >= 2) {
      val.maxHeightUm =
          decoder.decodeStruct(codec.Int32);
    } else {
      val.maxHeightUm = null;
    }
    packed = decoder.readUint8();
    val.hasBorderlessVariant = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  Paper.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Paper.encodedSize);
    encoder.writeUint32(3);
    encoder.encodeStruct(codec.String, val.displayName);
    encoder.encodeStruct(codec.String, val.vendorId);
    encoder.encodeStructPointer(geometry$.Size, val.sizeUm);
    encoder.encodeStructPointer(geometry$.Rect, val.printableAreaUm);
    encoder.encodeStruct(codec.Int32, val.maxHeightUm);
    packed = 0;
    packed |= (val.hasBorderlessVariant & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function MediaType(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  MediaType.prototype.initDefaults_ = function() {
    this.displayName = null;
    this.vendorId = null;
  };
  MediaType.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  MediaType.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate MediaType.displayName
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 0, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate MediaType.vendorId
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 8, false)
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  MediaType.encodedSize = codec.kStructHeaderSize + 16;

  MediaType.decode = function(decoder) {
    var packed;
    var val = new MediaType();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.displayName =
        decoder.decodeStruct(codec.String);
    val.vendorId =
        decoder.decodeStruct(codec.String);
    return val;
  };

  MediaType.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(MediaType.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.String, val.displayName);
    encoder.encodeStruct(codec.String, val.vendorId);
  };
  function PrinterSemanticCapsAndDefaults(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  PrinterSemanticCapsAndDefaults.prototype.initDefaults_ = function() {
    this.collateCapable = false;
    this.collateDefault = false;
    this.colorChangeable = false;
    this.colorDefault = false;
    this.copiesMax = 1;
    this.duplexModes = null;
    this.duplexDefault = print$.DuplexMode.kUnknownDuplexMode;
    this.colorModel = print$.ColorModel.kUnknownColorModel;
    this.bwModel = print$.ColorModel.kUnknownColorModel;
    this.papers = null;
    this.userDefinedPapers = null;
    this.defaultPaper = null;
    this.dpis = null;
    this.defaultDpi = null;
    this.mediaTypes = null;
    this.defaultMediaType = null;
  };
  PrinterSemanticCapsAndDefaults.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  PrinterSemanticCapsAndDefaults.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 80},
      {version: 2, numBytes: 96}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;





    // validate PrinterSemanticCapsAndDefaults.duplexModes
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 8, 4, new codec.Enum(print$.DuplexMode), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PrinterSemanticCapsAndDefaults.duplexDefault
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 16, print$.DuplexMode);
    if (err !== validator.validationError.NONE)
        return err;




    // validate PrinterSemanticCapsAndDefaults.colorModel
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 20, print$.ColorModel);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PrinterSemanticCapsAndDefaults.bwModel
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 24, print$.ColorModel);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PrinterSemanticCapsAndDefaults.papers
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 32, 8, new codec.PointerTo(Paper), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PrinterSemanticCapsAndDefaults.userDefinedPapers
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 40, 8, new codec.PointerTo(Paper), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PrinterSemanticCapsAndDefaults.defaultPaper
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 48, Paper, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PrinterSemanticCapsAndDefaults.dpis
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 56, 8, new codec.PointerTo(geometry$.Size), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PrinterSemanticCapsAndDefaults.defaultDpi
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 64, geometry$.Size, false);
    if (err !== validator.validationError.NONE)
        return err;



    // version check PrinterSemanticCapsAndDefaults.mediaTypes
    if (!messageValidator.isFieldInStructVersion(offset, 2))
      return validator.validationError.NONE;
    // validate PrinterSemanticCapsAndDefaults.mediaTypes
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 72, 8, new codec.PointerTo(MediaType), true, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;



    // version check PrinterSemanticCapsAndDefaults.defaultMediaType
    if (!messageValidator.isFieldInStructVersion(offset, 2))
      return validator.validationError.NONE;
    // validate PrinterSemanticCapsAndDefaults.defaultMediaType
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 80, MediaType, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  PrinterSemanticCapsAndDefaults.encodedSize = codec.kStructHeaderSize + 88;

  PrinterSemanticCapsAndDefaults.decode = function(decoder) {
    var packed;
    var val = new PrinterSemanticCapsAndDefaults();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    packed = decoder.readUint8();
    val.collateCapable = (packed >> 0) & 1 ? true : false;
    val.collateDefault = (packed >> 1) & 1 ? true : false;
    val.colorChangeable = (packed >> 2) & 1 ? true : false;
    val.colorDefault = (packed >> 3) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.copiesMax =
        decoder.decodeStruct(codec.Int32);
    val.duplexModes =
        decoder.decodeArrayPointer(new codec.Enum(print$.DuplexMode));
    val.duplexDefault =
        decoder.decodeStruct(new codec.Enum(print$.DuplexMode));
    val.colorModel =
        decoder.decodeStruct(new codec.Enum(print$.ColorModel));
    val.bwModel =
        decoder.decodeStruct(new codec.Enum(print$.ColorModel));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.papers =
        decoder.decodeArrayPointer(new codec.PointerTo(Paper));
    val.userDefinedPapers =
        decoder.decodeArrayPointer(new codec.PointerTo(Paper));
    val.defaultPaper =
        decoder.decodeStructPointer(Paper);
    val.dpis =
        decoder.decodeArrayPointer(new codec.PointerTo(geometry$.Size));
    val.defaultDpi =
        decoder.decodeStructPointer(geometry$.Size);
    if (version >= 2) {
      val.mediaTypes =
          decoder.decodeArrayPointer(new codec.PointerTo(MediaType));
    } else {
      val.mediaTypes = null;
    }
    if (version >= 2) {
      val.defaultMediaType =
          decoder.decodeStructPointer(MediaType);
    } else {
      val.defaultMediaType = null;
    }
    return val;
  };

  PrinterSemanticCapsAndDefaults.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(PrinterSemanticCapsAndDefaults.encodedSize);
    encoder.writeUint32(2);
    packed = 0;
    packed |= (val.collateCapable & 1) << 0
    packed |= (val.collateDefault & 1) << 1
    packed |= (val.colorChangeable & 1) << 2
    packed |= (val.colorDefault & 1) << 3
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.Int32, val.copiesMax);
    encoder.encodeArrayPointer(new codec.Enum(print$.DuplexMode), val.duplexModes);
    encoder.encodeStruct(codec.Int32, val.duplexDefault);
    encoder.encodeStruct(codec.Int32, val.colorModel);
    encoder.encodeStruct(codec.Int32, val.bwModel);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeArrayPointer(new codec.PointerTo(Paper), val.papers);
    encoder.encodeArrayPointer(new codec.PointerTo(Paper), val.userDefinedPapers);
    encoder.encodeStructPointer(Paper, val.defaultPaper);
    encoder.encodeArrayPointer(new codec.PointerTo(geometry$.Size), val.dpis);
    encoder.encodeStructPointer(geometry$.Size, val.defaultDpi);
    encoder.encodeArrayPointer(new codec.PointerTo(MediaType), val.mediaTypes);
    encoder.encodeStructPointer(MediaType, val.defaultMediaType);
  };
  exports.PrinterBasicInfo = PrinterBasicInfo;
  exports.Paper = Paper;
  exports.MediaType = MediaType;
  exports.PrinterSemanticCapsAndDefaults = PrinterSemanticCapsAndDefaults;
})();