// printing/mojom/printing_context.mojom.js is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2014 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

(function() {
  var mojomId = 'printing/mojom/printing_context.mojom';
  if (mojo.internal.isMojomLoaded(mojomId)) {
    console.warn('The following mojom is loaded multiple times: ' + mojomId);
    return;
  }
  mojo.internal.markMojomLoaded(mojomId);
  var bindings = mojo;
  var associatedBindings = mojo;
  var codec = mojo.internal;
  var validator = mojo.internal;

  var exports = mojo.internal.exposeNamespace('printing.mojom');
  var string16$ =
      mojo.internal.exposeNamespace('mojoBase.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'mojo/public/mojom/base/string16.mojom', '../../mojo/public/mojom/base/string16.mojom.js');
  }
  var values$ =
      mojo.internal.exposeNamespace('mojoBase.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'mojo/public/mojom/base/values.mojom', '../../mojo/public/mojom/base/values.mojom.js');
  }
  var print$ =
      mojo.internal.exposeNamespace('printing.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'printing/mojom/print.mojom', 'print.mojom.js');
  }
  var geometry$ =
      mojo.internal.exposeNamespace('gfx.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'ui/gfx/geometry/mojom/geometry.mojom', '../../ui/gfx/geometry/mojom/geometry.mojom.js');
  }



  function PageMargins(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  PageMargins.prototype.initDefaults_ = function() {
    this.header = 0;
    this.footer = 0;
    this.left = 0;
    this.right = 0;
    this.top = 0;
    this.bottom = 0;
  };
  PageMargins.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  PageMargins.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 32}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;







    return validator.validationError.NONE;
  };

  PageMargins.encodedSize = codec.kStructHeaderSize + 24;

  PageMargins.decode = function(decoder) {
    var packed;
    var val = new PageMargins();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.header =
        decoder.decodeStruct(codec.Int32);
    val.footer =
        decoder.decodeStruct(codec.Int32);
    val.left =
        decoder.decodeStruct(codec.Int32);
    val.right =
        decoder.decodeStruct(codec.Int32);
    val.top =
        decoder.decodeStruct(codec.Int32);
    val.bottom =
        decoder.decodeStruct(codec.Int32);
    return val;
  };

  PageMargins.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(PageMargins.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.header);
    encoder.encodeStruct(codec.Int32, val.footer);
    encoder.encodeStruct(codec.Int32, val.left);
    encoder.encodeStruct(codec.Int32, val.right);
    encoder.encodeStruct(codec.Int32, val.top);
    encoder.encodeStruct(codec.Int32, val.bottom);
  };
  function PageSetup(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  PageSetup.prototype.initDefaults_ = function() {
    this.physicalSize = null;
    this.printableArea = null;
    this.overlayArea = null;
    this.contentArea = null;
    this.effectiveMargins = null;
    this.requestedMargins = null;
    this.forcedMargins = false;
    this.textHeight = 0;
  };
  PageSetup.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  PageSetup.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 64}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageSetup.physicalSize
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, geometry$.Size, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageSetup.printableArea
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, geometry$.Rect, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageSetup.overlayArea
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, geometry$.Rect, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageSetup.contentArea
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 24, geometry$.Rect, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageSetup.effectiveMargins
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 32, PageMargins, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageSetup.requestedMargins
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 40, PageMargins, false);
    if (err !== validator.validationError.NONE)
        return err;



    return validator.validationError.NONE;
  };

  PageSetup.encodedSize = codec.kStructHeaderSize + 56;

  PageSetup.decode = function(decoder) {
    var packed;
    var val = new PageSetup();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.physicalSize =
        decoder.decodeStructPointer(geometry$.Size);
    val.printableArea =
        decoder.decodeStructPointer(geometry$.Rect);
    val.overlayArea =
        decoder.decodeStructPointer(geometry$.Rect);
    val.contentArea =
        decoder.decodeStructPointer(geometry$.Rect);
    val.effectiveMargins =
        decoder.decodeStructPointer(PageMargins);
    val.requestedMargins =
        decoder.decodeStructPointer(PageMargins);
    packed = decoder.readUint8();
    val.forcedMargins = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.textHeight =
        decoder.decodeStruct(codec.Int32);
    return val;
  };

  PageSetup.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(PageSetup.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(geometry$.Size, val.physicalSize);
    encoder.encodeStructPointer(geometry$.Rect, val.printableArea);
    encoder.encodeStructPointer(geometry$.Rect, val.overlayArea);
    encoder.encodeStructPointer(geometry$.Rect, val.contentArea);
    encoder.encodeStructPointer(PageMargins, val.effectiveMargins);
    encoder.encodeStructPointer(PageMargins, val.requestedMargins);
    packed = 0;
    packed |= (val.forcedMargins & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.Int32, val.textHeight);
  };
  function RequestedMedia(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  RequestedMedia.prototype.initDefaults_ = function() {
    this.sizeMicrons = null;
    this.vendorId = null;
  };
  RequestedMedia.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  RequestedMedia.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate RequestedMedia.sizeMicrons
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, geometry$.Size, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate RequestedMedia.vendorId
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 8, false)
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  RequestedMedia.encodedSize = codec.kStructHeaderSize + 16;

  RequestedMedia.decode = function(decoder) {
    var packed;
    var val = new RequestedMedia();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.sizeMicrons =
        decoder.decodeStructPointer(geometry$.Size);
    val.vendorId =
        decoder.decodeStruct(codec.String);
    return val;
  };

  RequestedMedia.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(RequestedMedia.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(geometry$.Size, val.sizeMicrons);
    encoder.encodeStruct(codec.String, val.vendorId);
  };
  function PrintSettings(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  PrintSettings.prototype.initDefaults_ = function() {
    this.ranges = null;
    this.selectionOnly = false;
    this.displayHeaderFooter = false;
    this.shouldPrintBackgrounds = false;
    this.collate = false;
    this.borderless = false;
    this.rasterizePdf = false;
    this.landscape = false;
    this.isModifiable = false;
    this.marginType = 0;
    this.title = null;
    this.url = null;
    this.color = 0;
    this.copies = 0;
    this.duplexMode = 0;
    this.pagesPerSheet = 0;
    this.deviceName = null;
    this.requestedMedia = null;
    this.pageSetupDeviceUnits = null;
    this.mediaType = null;
    this.dpi = null;
    this.scaleFactor = 0;
    this.requestedCustomMarginsInPoints = null;
    this.advancedSettings = null;
    this.systemPrintDialogData = null;
  };
  PrintSettings.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  PrintSettings.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 128}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PrintSettings.ranges
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 0, 8, new codec.PointerTo(print$.PageRange), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;



    // validate PrintSettings.marginType
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 12, print$.MarginType);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PrintSettings.title
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PrintSettings.url
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 24, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;





    // validate PrintSettings.color
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 32, print$.ColorModel);
    if (err !== validator.validationError.NONE)
        return err;



    // validate PrintSettings.duplexMode
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 40, print$.DuplexMode);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PrintSettings.deviceName
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 48, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PrintSettings.requestedMedia
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 56, RequestedMedia, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PrintSettings.pageSetupDeviceUnits
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 64, PageSetup, false);
    if (err !== validator.validationError.NONE)
        return err;



    // validate PrintSettings.mediaType
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 72, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate PrintSettings.dpi
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 80, geometry$.Size, false);
    if (err !== validator.validationError.NONE)
        return err;






    // validate PrintSettings.requestedCustomMarginsInPoints
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 96, PageMargins, false);
    if (err !== validator.validationError.NONE)
        return err;



    // validate PrintSettings.advancedSettings
    err = messageValidator.validateMapPointer(offset + codec.kStructHeaderSize + 104, false, codec.String, values$.Value, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PrintSettings.systemPrintDialogData
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 112, values$.DictionaryValue, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  PrintSettings.encodedSize = codec.kStructHeaderSize + 120;

  PrintSettings.decode = function(decoder) {
    var packed;
    var val = new PrintSettings();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.ranges =
        decoder.decodeArrayPointer(new codec.PointerTo(print$.PageRange));
    packed = decoder.readUint8();
    val.selectionOnly = (packed >> 0) & 1 ? true : false;
    val.displayHeaderFooter = (packed >> 1) & 1 ? true : false;
    val.shouldPrintBackgrounds = (packed >> 2) & 1 ? true : false;
    val.collate = (packed >> 3) & 1 ? true : false;
    val.borderless = (packed >> 4) & 1 ? true : false;
    val.rasterizePdf = (packed >> 5) & 1 ? true : false;
    val.landscape = (packed >> 6) & 1 ? true : false;
    val.isModifiable = (packed >> 7) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.marginType =
        decoder.decodeStruct(new codec.Enum(print$.MarginType));
    val.title =
        decoder.decodeStructPointer(string16$.String16);
    val.url =
        decoder.decodeStructPointer(string16$.String16);
    val.color =
        decoder.decodeStruct(new codec.Enum(print$.ColorModel));
    val.copies =
        decoder.decodeStruct(codec.Int32);
    val.duplexMode =
        decoder.decodeStruct(new codec.Enum(print$.DuplexMode));
    val.pagesPerSheet =
        decoder.decodeStruct(codec.Int32);
    val.deviceName =
        decoder.decodeStructPointer(string16$.String16);
    val.requestedMedia =
        decoder.decodeStructPointer(RequestedMedia);
    val.pageSetupDeviceUnits =
        decoder.decodeStructPointer(PageSetup);
    val.mediaType =
        decoder.decodeStruct(codec.String);
    val.dpi =
        decoder.decodeStructPointer(geometry$.Size);
    val.scaleFactor =
        decoder.decodeStruct(codec.Double);
    val.requestedCustomMarginsInPoints =
        decoder.decodeStructPointer(PageMargins);
    val.advancedSettings =
        decoder.decodeMapPointer(codec.String, values$.Value);
    val.systemPrintDialogData =
        decoder.decodeStructPointer(values$.DictionaryValue);
    return val;
  };

  PrintSettings.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(PrintSettings.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeArrayPointer(new codec.PointerTo(print$.PageRange), val.ranges);
    packed = 0;
    packed |= (val.selectionOnly & 1) << 0
    packed |= (val.displayHeaderFooter & 1) << 1
    packed |= (val.shouldPrintBackgrounds & 1) << 2
    packed |= (val.collate & 1) << 3
    packed |= (val.borderless & 1) << 4
    packed |= (val.rasterizePdf & 1) << 5
    packed |= (val.landscape & 1) << 6
    packed |= (val.isModifiable & 1) << 7
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.Int32, val.marginType);
    encoder.encodeStructPointer(string16$.String16, val.title);
    encoder.encodeStructPointer(string16$.String16, val.url);
    encoder.encodeStruct(codec.Int32, val.color);
    encoder.encodeStruct(codec.Int32, val.copies);
    encoder.encodeStruct(codec.Int32, val.duplexMode);
    encoder.encodeStruct(codec.Int32, val.pagesPerSheet);
    encoder.encodeStructPointer(string16$.String16, val.deviceName);
    encoder.encodeStructPointer(RequestedMedia, val.requestedMedia);
    encoder.encodeStructPointer(PageSetup, val.pageSetupDeviceUnits);
    encoder.encodeStruct(codec.String, val.mediaType);
    encoder.encodeStructPointer(geometry$.Size, val.dpi);
    encoder.encodeStruct(codec.Double, val.scaleFactor);
    encoder.encodeStructPointer(PageMargins, val.requestedCustomMarginsInPoints);
    encoder.encodeMapPointer(codec.String, values$.Value, val.advancedSettings);
    encoder.encodeStructPointer(values$.DictionaryValue, val.systemPrintDialogData);
  };
  exports.PageMargins = PageMargins;
  exports.PageSetup = PageSetup;
  exports.RequestedMedia = RequestedMedia;
  exports.PrintSettings = PrintSettings;
})();