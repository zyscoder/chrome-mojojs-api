// services/webnn/public/mojom/webnn_graph.mojom.js is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2014 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

(function() {
  var mojomId = 'services/webnn/public/mojom/webnn_graph.mojom';
  if (mojo.internal.isMojomLoaded(mojomId)) {
    console.warn('The following mojom is loaded multiple times: ' + mojomId);
    return;
  }
  mojo.internal.markMojomLoaded(mojomId);
  var bindings = mojo;
  var associatedBindings = mojo;
  var codec = mojo.internal;
  var validator = mojo.internal;

  var exports = mojo.internal.exposeNamespace('webnn.mojom');
  var big_buffer$ =
      mojo.internal.exposeNamespace('mojoBase.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'mojo/public/mojom/base/big_buffer.mojom', '../../../../mojo/public/mojom/base/big_buffer.mojom.js');
  }


  var InputOperandLayout = {};
  InputOperandLayout.kChannelsFirst = 0;
  InputOperandLayout.kChannelsLast = 1;
  InputOperandLayout.MIN_VALUE = 0;
  InputOperandLayout.MAX_VALUE = 1;

  InputOperandLayout.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
      return true;
    }
    return false;
  };

  InputOperandLayout.toKnownEnumValue = function(value) {
    return value;
  };

  InputOperandLayout.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var ComputeResult = {};
  ComputeResult.kOk = 0;
  ComputeResult.kInvalidInputs = 1;
  ComputeResult.kUnknownError = 2;
  ComputeResult.MIN_VALUE = 0;
  ComputeResult.MAX_VALUE = 2;

  ComputeResult.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    }
    return false;
  };

  ComputeResult.toKnownEnumValue = function(value) {
    return value;
  };

  ComputeResult.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };

  function Operand(values) {
    this.initDefaults_();
    this.initFields_(values);
  }

  Operand.DataType = {};
  Operand.DataType.kFloat32 = 0;
  Operand.DataType.kFloat16 = 1;
  Operand.DataType.kInt32 = 2;
  Operand.DataType.kUint32 = 3;
  Operand.DataType.kInt8 = 4;
  Operand.DataType.kUint8 = 5;
  Operand.DataType.MIN_VALUE = 0;
  Operand.DataType.MAX_VALUE = 5;

  Operand.DataType.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    }
    return false;
  };

  Operand.DataType.toKnownEnumValue = function(value) {
    return value;
  };

  Operand.DataType.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  Operand.Kind = {};
  Operand.Kind.kInput = 0;
  Operand.Kind.kConstant = 1;
  Operand.Kind.kOutput = 2;
  Operand.Kind.MIN_VALUE = 0;
  Operand.Kind.MAX_VALUE = 2;

  Operand.Kind.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    }
    return false;
  };

  Operand.Kind.toKnownEnumValue = function(value) {
    return value;
  };

  Operand.Kind.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };

  Operand.prototype.initDefaults_ = function() {
    this.kind = 0;
    this.dataType = 0;
    this.dimensions = null;
    this.name = null;
  };
  Operand.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Operand.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 32}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Operand.kind
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, Operand.Kind);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Operand.dataType
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 4, Operand.DataType);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Operand.dimensions
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 8, 4, codec.Uint32, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Operand.name
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 16, true)
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Operand.encodedSize = codec.kStructHeaderSize + 24;

  Operand.decode = function(decoder) {
    var packed;
    var val = new Operand();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.kind =
        decoder.decodeStruct(new codec.Enum(Operand.Kind));
    val.dataType =
        decoder.decodeStruct(new codec.Enum(Operand.DataType));
    val.dimensions =
        decoder.decodeArrayPointer(codec.Uint32);
    val.name =
        decoder.decodeStruct(codec.NullableString);
    return val;
  };

  Operand.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Operand.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.kind);
    encoder.encodeStruct(codec.Int32, val.dataType);
    encoder.encodeArrayPointer(codec.Uint32, val.dimensions);
    encoder.encodeStruct(codec.NullableString, val.name);
  };
  function ClampAttributes(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ClampAttributes.prototype.initDefaults_ = function() {
    this.minValue = 0;
    this.maxValue = 0;
  };
  ClampAttributes.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ClampAttributes.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    return validator.validationError.NONE;
  };

  ClampAttributes.encodedSize = codec.kStructHeaderSize + 8;

  ClampAttributes.decode = function(decoder) {
    var packed;
    var val = new ClampAttributes();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.minValue =
        decoder.decodeStruct(codec.Float);
    val.maxValue =
        decoder.decodeStruct(codec.Float);
    return val;
  };

  ClampAttributes.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ClampAttributes.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Float, val.minValue);
    encoder.encodeStruct(codec.Float, val.maxValue);
  };
  function Size2d(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Size2d.prototype.initDefaults_ = function() {
    this.height = 0;
    this.width = 0;
  };
  Size2d.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Size2d.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    return validator.validationError.NONE;
  };

  Size2d.encodedSize = codec.kStructHeaderSize + 8;

  Size2d.decode = function(decoder) {
    var packed;
    var val = new Size2d();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.height =
        decoder.decodeStruct(codec.Uint32);
    val.width =
        decoder.decodeStruct(codec.Uint32);
    return val;
  };

  Size2d.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Size2d.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint32, val.height);
    encoder.encodeStruct(codec.Uint32, val.width);
  };
  function Padding2d(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Padding2d.prototype.initDefaults_ = function() {
    this.beginning = null;
    this.ending = null;
  };
  Padding2d.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Padding2d.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Padding2d.beginning
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, Size2d, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Padding2d.ending
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, Size2d, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Padding2d.encodedSize = codec.kStructHeaderSize + 16;

  Padding2d.decode = function(decoder) {
    var packed;
    var val = new Padding2d();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.beginning =
        decoder.decodeStructPointer(Size2d);
    val.ending =
        decoder.decodeStructPointer(Size2d);
    return val;
  };

  Padding2d.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Padding2d.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(Size2d, val.beginning);
    encoder.encodeStructPointer(Size2d, val.ending);
  };
  function Conv2dAttributes(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Conv2dAttributes.prototype.initDefaults_ = function() {
    this.padding = null;
    this.strides = null;
    this.dilations = null;
    this.groups = 1;
    this.inputLayout = 0;
    this.bias_operand_id_$flag = false;
    this.bias_operand_id_$value = 0;
    this.activation = null;
  };
  Conv2dAttributes.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Conv2dAttributes.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 64}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Conv2dAttributes.padding
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, Padding2d, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Conv2dAttributes.strides
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, Size2d, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Conv2dAttributes.dilations
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, Size2d, false);
    if (err !== validator.validationError.NONE)
        return err;



    // validate Conv2dAttributes.inputLayout
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 28, InputOperandLayout);
    if (err !== validator.validationError.NONE)
        return err;




    // validate Conv2dAttributes.activation
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 48, Operator, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Conv2dAttributes.encodedSize = codec.kStructHeaderSize + 56;

  Conv2dAttributes.decode = function(decoder) {
    var packed;
    var val = new Conv2dAttributes();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.padding =
        decoder.decodeStructPointer(Padding2d);
    val.strides =
        decoder.decodeStructPointer(Size2d);
    val.dilations =
        decoder.decodeStructPointer(Size2d);
    val.groups =
        decoder.decodeStruct(codec.Uint32);
    val.inputLayout =
        decoder.decodeStruct(new codec.Enum(InputOperandLayout));
    packed = decoder.readUint8();
    val.bias_operand_id_$flag = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.bias_operand_id_$value =
        decoder.decodeStruct(codec.Uint64);
    val.activation =
        decoder.decodeStructPointer(Operator);
    return val;
  };

  Conv2dAttributes.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Conv2dAttributes.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(Padding2d, val.padding);
    encoder.encodeStructPointer(Size2d, val.strides);
    encoder.encodeStructPointer(Size2d, val.dilations);
    encoder.encodeStruct(codec.Uint32, val.groups);
    encoder.encodeStruct(codec.Int32, val.inputLayout);
    packed = 0;
    packed |= (val.bias_operand_id_$flag & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.Uint64, val.bias_operand_id_$value);
    encoder.encodeStructPointer(Operator, val.activation);
  };
  function Pool2d(values) {
    this.initDefaults_();
    this.initFields_(values);
  }

  Pool2d.Kind = {};
  Pool2d.Kind.kAveragePool2d = 0;
  Pool2d.Kind.kMaxPool2d = 1;
  Pool2d.Kind.MIN_VALUE = 0;
  Pool2d.Kind.MAX_VALUE = 1;

  Pool2d.Kind.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
      return true;
    }
    return false;
  };

  Pool2d.Kind.toKnownEnumValue = function(value) {
    return value;
  };

  Pool2d.Kind.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };

  Pool2d.prototype.initDefaults_ = function() {
    this.kind = 0;
    this.layout = 0;
    this.inputOperandId = 0;
    this.outputOperandId = 0;
    this.windowDimensions = null;
    this.padding = null;
    this.strides = null;
    this.dilations = null;
  };
  Pool2d.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Pool2d.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 64}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Pool2d.kind
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, Pool2d.Kind);
    if (err !== validator.validationError.NONE)
        return err;




    // validate Pool2d.windowDimensions
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 24, Size2d, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Pool2d.padding
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 32, Padding2d, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Pool2d.strides
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 40, Size2d, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Pool2d.dilations
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 48, Size2d, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Pool2d.layout
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 4, InputOperandLayout);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Pool2d.encodedSize = codec.kStructHeaderSize + 56;

  Pool2d.decode = function(decoder) {
    var packed;
    var val = new Pool2d();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.kind =
        decoder.decodeStruct(new codec.Enum(Pool2d.Kind));
    val.layout =
        decoder.decodeStruct(new codec.Enum(InputOperandLayout));
    val.inputOperandId =
        decoder.decodeStruct(codec.Uint64);
    val.outputOperandId =
        decoder.decodeStruct(codec.Uint64);
    val.windowDimensions =
        decoder.decodeStructPointer(Size2d);
    val.padding =
        decoder.decodeStructPointer(Padding2d);
    val.strides =
        decoder.decodeStructPointer(Size2d);
    val.dilations =
        decoder.decodeStructPointer(Size2d);
    return val;
  };

  Pool2d.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Pool2d.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.kind);
    encoder.encodeStruct(codec.Int32, val.layout);
    encoder.encodeStruct(codec.Uint64, val.inputOperandId);
    encoder.encodeStruct(codec.Uint64, val.outputOperandId);
    encoder.encodeStructPointer(Size2d, val.windowDimensions);
    encoder.encodeStructPointer(Padding2d, val.padding);
    encoder.encodeStructPointer(Size2d, val.strides);
    encoder.encodeStructPointer(Size2d, val.dilations);
  };
  function GemmAttributes(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GemmAttributes.prototype.initDefaults_ = function() {
    this.c_operand_id_$flag = false;
    this.aTranspose = false;
    this.bTranspose = false;
    this.alpha = 1.0;
    this.c_operand_id_$value = 0;
    this.beta = 1.0;
  };
  GemmAttributes.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GemmAttributes.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 32}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;







    return validator.validationError.NONE;
  };

  GemmAttributes.encodedSize = codec.kStructHeaderSize + 24;

  GemmAttributes.decode = function(decoder) {
    var packed;
    var val = new GemmAttributes();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    packed = decoder.readUint8();
    val.c_operand_id_$flag = (packed >> 0) & 1 ? true : false;
    val.aTranspose = (packed >> 1) & 1 ? true : false;
    val.bTranspose = (packed >> 2) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.alpha =
        decoder.decodeStruct(codec.Float);
    val.c_operand_id_$value =
        decoder.decodeStruct(codec.Uint64);
    val.beta =
        decoder.decodeStruct(codec.Float);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  GemmAttributes.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GemmAttributes.encodedSize);
    encoder.writeUint32(0);
    packed = 0;
    packed |= (val.c_operand_id_$flag & 1) << 0
    packed |= (val.aTranspose & 1) << 1
    packed |= (val.bTranspose & 1) << 2
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.Float, val.alpha);
    encoder.encodeStruct(codec.Uint64, val.c_operand_id_$value);
    encoder.encodeStruct(codec.Float, val.beta);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function Operator(values) {
    this.initDefaults_();
    this.initFields_(values);
  }

  Operator.Kind = {};
  Operator.Kind.kClamp = 0;
  Operator.Kind.kConv2d = 1;
  Operator.Kind.kAdd = 2;
  Operator.Kind.kSub = 3;
  Operator.Kind.kMul = 4;
  Operator.Kind.kDiv = 5;
  Operator.Kind.kMax = 6;
  Operator.Kind.kMin = 7;
  Operator.Kind.kPow = 8;
  Operator.Kind.kGemm = 9;
  Operator.Kind.kRelu = 10;
  Operator.Kind.kReshape = 11;
  Operator.Kind.kSoftmax = 12;
  Operator.Kind.MIN_VALUE = 0;
  Operator.Kind.MAX_VALUE = 12;

  Operator.Kind.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    }
    return false;
  };

  Operator.Kind.toKnownEnumValue = function(value) {
    return value;
  };

  Operator.Kind.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };

  Operator.prototype.initDefaults_ = function() {
    this.kind = 0;
    this.inputOperands = null;
    this.outputOperands = null;
    this.attributes = null;
  };
  Operator.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Operator.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 48}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Operator.kind
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, Operator.Kind);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Operator.inputOperands
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 8, 8, codec.Uint64, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Operator.outputOperands
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 16, 8, codec.Uint64, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Operator.attributes
    err = messageValidator.validateUnion(offset + codec.kStructHeaderSize + 24, OperatorAttributes, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Operator.encodedSize = codec.kStructHeaderSize + 40;

  Operator.decode = function(decoder) {
    var packed;
    var val = new Operator();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.kind =
        decoder.decodeStruct(new codec.Enum(Operator.Kind));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.inputOperands =
        decoder.decodeArrayPointer(codec.Uint64);
    val.outputOperands =
        decoder.decodeArrayPointer(codec.Uint64);
    val.attributes =
        decoder.decodeStruct(OperatorAttributes);
    return val;
  };

  Operator.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Operator.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.kind);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeArrayPointer(codec.Uint64, val.inputOperands);
    encoder.encodeArrayPointer(codec.Uint64, val.outputOperands);
    encoder.encodeStruct(OperatorAttributes, val.attributes);
  };
  function GraphInfo(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GraphInfo.prototype.initDefaults_ = function() {
    this.idToOperandMap = null;
    this.inputOperands = null;
    this.outputOperands = null;
    this.operations = null;
    this.constantIdToBufferMap = null;
  };
  GraphInfo.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GraphInfo.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 48}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GraphInfo.idToOperandMap
    err = messageValidator.validateMapPointer(offset + codec.kStructHeaderSize + 0, false, codec.Uint64, new codec.PointerTo(Operand), false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GraphInfo.inputOperands
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 8, 8, codec.Uint64, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GraphInfo.outputOperands
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 16, 8, codec.Uint64, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GraphInfo.operations
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 24, 16, Operation, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GraphInfo.constantIdToBufferMap
    err = messageValidator.validateMapPointer(offset + codec.kStructHeaderSize + 32, false, codec.Uint64, big_buffer$.BigBuffer, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GraphInfo.encodedSize = codec.kStructHeaderSize + 40;

  GraphInfo.decode = function(decoder) {
    var packed;
    var val = new GraphInfo();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.idToOperandMap =
        decoder.decodeMapPointer(codec.Uint64, new codec.PointerTo(Operand));
    val.inputOperands =
        decoder.decodeArrayPointer(codec.Uint64);
    val.outputOperands =
        decoder.decodeArrayPointer(codec.Uint64);
    val.operations =
        decoder.decodeArrayPointer(Operation);
    val.constantIdToBufferMap =
        decoder.decodeMapPointer(codec.Uint64, big_buffer$.BigBuffer);
    return val;
  };

  GraphInfo.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GraphInfo.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeMapPointer(codec.Uint64, new codec.PointerTo(Operand), val.idToOperandMap);
    encoder.encodeArrayPointer(codec.Uint64, val.inputOperands);
    encoder.encodeArrayPointer(codec.Uint64, val.outputOperands);
    encoder.encodeArrayPointer(Operation, val.operations);
    encoder.encodeMapPointer(codec.Uint64, big_buffer$.BigBuffer, val.constantIdToBufferMap);
  };
  function WebNNGraph_Compute_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  WebNNGraph_Compute_Params.prototype.initDefaults_ = function() {
    this.namedInputs = null;
  };
  WebNNGraph_Compute_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  WebNNGraph_Compute_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate WebNNGraph_Compute_Params.namedInputs
    err = messageValidator.validateMapPointer(offset + codec.kStructHeaderSize + 0, false, codec.String, big_buffer$.BigBuffer, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  WebNNGraph_Compute_Params.encodedSize = codec.kStructHeaderSize + 8;

  WebNNGraph_Compute_Params.decode = function(decoder) {
    var packed;
    var val = new WebNNGraph_Compute_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.namedInputs =
        decoder.decodeMapPointer(codec.String, big_buffer$.BigBuffer);
    return val;
  };

  WebNNGraph_Compute_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(WebNNGraph_Compute_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeMapPointer(codec.String, big_buffer$.BigBuffer, val.namedInputs);
  };
  function WebNNGraph_Compute_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  WebNNGraph_Compute_ResponseParams.prototype.initDefaults_ = function() {
    this.result = 0;
    this.namedOutputs = null;
  };
  WebNNGraph_Compute_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  WebNNGraph_Compute_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate WebNNGraph_Compute_ResponseParams.result
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, ComputeResult);
    if (err !== validator.validationError.NONE)
        return err;


    // validate WebNNGraph_Compute_ResponseParams.namedOutputs
    err = messageValidator.validateMapPointer(offset + codec.kStructHeaderSize + 8, true, codec.String, big_buffer$.BigBuffer, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  WebNNGraph_Compute_ResponseParams.encodedSize = codec.kStructHeaderSize + 16;

  WebNNGraph_Compute_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new WebNNGraph_Compute_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.result =
        decoder.decodeStruct(new codec.Enum(ComputeResult));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.namedOutputs =
        decoder.decodeMapPointer(codec.String, big_buffer$.BigBuffer);
    return val;
  };

  WebNNGraph_Compute_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(WebNNGraph_Compute_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.result);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeMapPointer(codec.String, big_buffer$.BigBuffer, val.namedOutputs);
  };

  function OperatorAttributes(value) {
    this.initDefault_();
    this.initValue_(value);
  }


  OperatorAttributes.Tags = {
    clamp: 0,
    conv2d: 1,
    gemm: 2,
  };

  OperatorAttributes.prototype.initDefault_ = function() {
    this.$data = null;
    this.$tag = undefined;
  }

  OperatorAttributes.prototype.initValue_ = function(value) {
    if (value == undefined) {
      return;
    }

    var keys = Object.keys(value);
    if (keys.length == 0) {
      return;
    }

    if (keys.length > 1) {
      throw new TypeError("You may set only one member on a union.");
    }

    var fields = [
        "clamp",
        "conv2d",
        "gemm",
    ];

    if (fields.indexOf(keys[0]) < 0) {
      throw new ReferenceError(keys[0] + " is not a OperatorAttributes member.");

    }

    this[keys[0]] = value[keys[0]];
  }
  Object.defineProperty(OperatorAttributes.prototype, "clamp", {
    get: function() {
      if (this.$tag != OperatorAttributes.Tags.clamp) {
        throw new ReferenceError(
            "OperatorAttributes.clamp is not currently set.");
      }
      return this.$data;
    },

    set: function(value) {
      this.$tag = OperatorAttributes.Tags.clamp;
      this.$data = value;
    }
  });
  Object.defineProperty(OperatorAttributes.prototype, "conv2d", {
    get: function() {
      if (this.$tag != OperatorAttributes.Tags.conv2d) {
        throw new ReferenceError(
            "OperatorAttributes.conv2d is not currently set.");
      }
      return this.$data;
    },

    set: function(value) {
      this.$tag = OperatorAttributes.Tags.conv2d;
      this.$data = value;
    }
  });
  Object.defineProperty(OperatorAttributes.prototype, "gemm", {
    get: function() {
      if (this.$tag != OperatorAttributes.Tags.gemm) {
        throw new ReferenceError(
            "OperatorAttributes.gemm is not currently set.");
      }
      return this.$data;
    },

    set: function(value) {
      this.$tag = OperatorAttributes.Tags.gemm;
      this.$data = value;
    }
  });


    OperatorAttributes.encode = function(encoder, val) {
      if (val == null) {
        encoder.writeUint64(0);
        encoder.writeUint64(0);
        return;
      }
      if (val.$tag == undefined) {
        throw new TypeError("Cannot encode unions with an unknown member set.");
      }

      encoder.writeUint32(16);
      encoder.writeUint32(val.$tag);
      switch (val.$tag) {
        case OperatorAttributes.Tags.clamp:
          encoder.encodeStructPointer(ClampAttributes, val.clamp);
          break;
        case OperatorAttributes.Tags.conv2d:
          encoder.encodeStructPointer(Conv2dAttributes, val.conv2d);
          break;
        case OperatorAttributes.Tags.gemm:
          encoder.encodeStructPointer(GemmAttributes, val.gemm);
          break;
      }
      encoder.align();
    };


    OperatorAttributes.decode = function(decoder) {
      var size = decoder.readUint32();
      if (size == 0) {
        decoder.readUint32();
        decoder.readUint64();
        return null;
      }

      var result = new OperatorAttributes();
      var tag = decoder.readUint32();
      switch (tag) {
        case OperatorAttributes.Tags.clamp:
          result.clamp = decoder.decodeStructPointer(ClampAttributes);
          break;
        case OperatorAttributes.Tags.conv2d:
          result.conv2d = decoder.decodeStructPointer(Conv2dAttributes);
          break;
        case OperatorAttributes.Tags.gemm:
          result.gemm = decoder.decodeStructPointer(GemmAttributes);
          break;
      }
      decoder.align();

      return result;
    };


    OperatorAttributes.validate = function(messageValidator, offset) {
      var size = messageValidator.decodeUnionSize(offset);
      if (size != 16) {
        return validator.validationError.INVALID_UNION_SIZE;
      }

      var tag = messageValidator.decodeUnionTag(offset);
      var data_offset = offset + 8;
      var err;
      switch (tag) {
        case OperatorAttributes.Tags.clamp:
          

    // validate OperatorAttributes.clamp
    err = messageValidator.validateStructPointer(data_offset, ClampAttributes, false);
    if (err !== validator.validationError.NONE)
        return err;
          break;
        case OperatorAttributes.Tags.conv2d:
          

    // validate OperatorAttributes.conv2d
    err = messageValidator.validateStructPointer(data_offset, Conv2dAttributes, false);
    if (err !== validator.validationError.NONE)
        return err;
          break;
        case OperatorAttributes.Tags.gemm:
          

    // validate OperatorAttributes.gemm
    err = messageValidator.validateStructPointer(data_offset, GemmAttributes, false);
    if (err !== validator.validationError.NONE)
        return err;
          break;
      }

      return validator.validationError.NONE;
    };

  OperatorAttributes.encodedSize = 16;

  function Operation(value) {
    this.initDefault_();
    this.initValue_(value);
  }


  Operation.Tags = {
    pool2d: 0,
    genericOperator: 1,
  };

  Operation.prototype.initDefault_ = function() {
    this.$data = null;
    this.$tag = undefined;
  }

  Operation.prototype.initValue_ = function(value) {
    if (value == undefined) {
      return;
    }

    var keys = Object.keys(value);
    if (keys.length == 0) {
      return;
    }

    if (keys.length > 1) {
      throw new TypeError("You may set only one member on a union.");
    }

    var fields = [
        "pool2d",
        "genericOperator",
    ];

    if (fields.indexOf(keys[0]) < 0) {
      throw new ReferenceError(keys[0] + " is not a Operation member.");

    }

    this[keys[0]] = value[keys[0]];
  }
  Object.defineProperty(Operation.prototype, "pool2d", {
    get: function() {
      if (this.$tag != Operation.Tags.pool2d) {
        throw new ReferenceError(
            "Operation.pool2d is not currently set.");
      }
      return this.$data;
    },

    set: function(value) {
      this.$tag = Operation.Tags.pool2d;
      this.$data = value;
    }
  });
  Object.defineProperty(Operation.prototype, "genericOperator", {
    get: function() {
      if (this.$tag != Operation.Tags.genericOperator) {
        throw new ReferenceError(
            "Operation.genericOperator is not currently set.");
      }
      return this.$data;
    },

    set: function(value) {
      this.$tag = Operation.Tags.genericOperator;
      this.$data = value;
    }
  });


    Operation.encode = function(encoder, val) {
      if (val == null) {
        encoder.writeUint64(0);
        encoder.writeUint64(0);
        return;
      }
      if (val.$tag == undefined) {
        throw new TypeError("Cannot encode unions with an unknown member set.");
      }

      encoder.writeUint32(16);
      encoder.writeUint32(val.$tag);
      switch (val.$tag) {
        case Operation.Tags.pool2d:
          encoder.encodeStructPointer(Pool2d, val.pool2d);
          break;
        case Operation.Tags.genericOperator:
          encoder.encodeStructPointer(Operator, val.genericOperator);
          break;
      }
      encoder.align();
    };


    Operation.decode = function(decoder) {
      var size = decoder.readUint32();
      if (size == 0) {
        decoder.readUint32();
        decoder.readUint64();
        return null;
      }

      var result = new Operation();
      var tag = decoder.readUint32();
      switch (tag) {
        case Operation.Tags.pool2d:
          result.pool2d = decoder.decodeStructPointer(Pool2d);
          break;
        case Operation.Tags.genericOperator:
          result.genericOperator = decoder.decodeStructPointer(Operator);
          break;
      }
      decoder.align();

      return result;
    };


    Operation.validate = function(messageValidator, offset) {
      var size = messageValidator.decodeUnionSize(offset);
      if (size != 16) {
        return validator.validationError.INVALID_UNION_SIZE;
      }

      var tag = messageValidator.decodeUnionTag(offset);
      var data_offset = offset + 8;
      var err;
      switch (tag) {
        case Operation.Tags.pool2d:
          

    // validate Operation.pool2d
    err = messageValidator.validateStructPointer(data_offset, Pool2d, false);
    if (err !== validator.validationError.NONE)
        return err;
          break;
        case Operation.Tags.genericOperator:
          

    // validate Operation.genericOperator
    err = messageValidator.validateStructPointer(data_offset, Operator, false);
    if (err !== validator.validationError.NONE)
        return err;
          break;
      }

      return validator.validationError.NONE;
    };

  Operation.encodedSize = 16;
  var kWebNNGraph_Compute_Name = 1769726923;

  function WebNNGraphPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(WebNNGraph,
                                                   handleOrPtrInfo);
  }

  function WebNNGraphAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        WebNNGraph, associatedInterfacePtrInfo);
  }

  WebNNGraphAssociatedPtr.prototype =
      Object.create(WebNNGraphPtr.prototype);
  WebNNGraphAssociatedPtr.prototype.constructor =
      WebNNGraphAssociatedPtr;

  function WebNNGraphProxy(receiver) {
    this.receiver_ = receiver;
  }
  WebNNGraphPtr.prototype.compute = function() {
    return WebNNGraphProxy.prototype.compute
        .apply(this.ptr.getProxy(), arguments);
  };

  WebNNGraphProxy.prototype.compute = function(namedInputs) {
    var params_ = new WebNNGraph_Compute_Params();
    params_.namedInputs = namedInputs;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kWebNNGraph_Compute_Name,
          codec.align(WebNNGraph_Compute_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(WebNNGraph_Compute_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(WebNNGraph_Compute_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };

  function WebNNGraphStub(delegate) {
    this.delegate_ = delegate;
  }
  WebNNGraphStub.prototype.compute = function(namedInputs) {
    return this.delegate_ && this.delegate_.compute && this.delegate_.compute(namedInputs);
  }

  WebNNGraphStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  WebNNGraphStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kWebNNGraph_Compute_Name:
      var params = reader.decodeStruct(WebNNGraph_Compute_Params);
      this.compute(params.namedInputs).then(function(response) {
        var responseParams =
            new WebNNGraph_Compute_ResponseParams();
        responseParams.result = response.result;
        responseParams.namedOutputs = response.namedOutputs;
        var builder = new codec.MessageV1Builder(
            kWebNNGraph_Compute_Name,
            codec.align(WebNNGraph_Compute_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(WebNNGraph_Compute_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    default:
      return false;
    }
  };

  function validateWebNNGraphRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kWebNNGraph_Compute_Name:
        if (message.expectsResponse())
          paramsClass = WebNNGraph_Compute_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateWebNNGraphResponse(messageValidator) {
   var message = messageValidator.message;
   var paramsClass = null;
   switch (message.getName()) {
      case kWebNNGraph_Compute_Name:
        if (message.isResponse())
          paramsClass = WebNNGraph_Compute_ResponseParams;
        break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  var WebNNGraph = {
    name: 'webnn.mojom.WebNNGraph',
    kVersion: 0,
    ptrClass: WebNNGraphPtr,
    proxyClass: WebNNGraphProxy,
    stubClass: WebNNGraphStub,
    validateRequest: validateWebNNGraphRequest,
    validateResponse: validateWebNNGraphResponse,
  };
  WebNNGraphStub.prototype.validator = validateWebNNGraphRequest;
  WebNNGraphProxy.prototype.validator = validateWebNNGraphResponse;
  exports.InputOperandLayout = InputOperandLayout;
  exports.ComputeResult = ComputeResult;
  exports.Operand = Operand;
  exports.ClampAttributes = ClampAttributes;
  exports.Size2d = Size2d;
  exports.Padding2d = Padding2d;
  exports.Conv2dAttributes = Conv2dAttributes;
  exports.Pool2d = Pool2d;
  exports.GemmAttributes = GemmAttributes;
  exports.Operator = Operator;
  exports.GraphInfo = GraphInfo;
  exports.OperatorAttributes = OperatorAttributes;
  exports.Operation = Operation;
  exports.WebNNGraph = WebNNGraph;
  exports.WebNNGraphPtr = WebNNGraphPtr;
  exports.WebNNGraphAssociatedPtr = WebNNGraphAssociatedPtr;
})();