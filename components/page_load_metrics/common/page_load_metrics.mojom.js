// components/page_load_metrics/common/page_load_metrics.mojom.js is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2014 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

(function() {
  var mojomId = 'components/page_load_metrics/common/page_load_metrics.mojom';
  if (mojo.internal.isMojomLoaded(mojomId)) {
    console.warn('The following mojom is loaded multiple times: ' + mojomId);
    return;
  }
  mojo.internal.markMojomLoaded(mojomId);
  var bindings = mojo;
  var associatedBindings = mojo;
  var codec = mojo.internal;
  var validator = mojo.internal;

  var exports = mojo.internal.exposeNamespace('pageLoadMetrics.mojom');
  var geometry$ =
      mojo.internal.exposeNamespace('gfx.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'ui/gfx/geometry/mojom/geometry.mojom', '../../../ui/gfx/geometry/mojom/geometry.mojom.js');
  }
  var shared_memory$ =
      mojo.internal.exposeNamespace('mojoBase.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'mojo/public/mojom/base/shared_memory.mojom', '../../../mojo/public/mojom/base/shared_memory.mojom.js');
  }
  var time$ =
      mojo.internal.exposeNamespace('mojoBase.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'mojo/public/mojom/base/time.mojom', '../../../mojo/public/mojom/base/time.mojom.js');
  }
  var javascript_framework_detection$ =
      mojo.internal.exposeNamespace('blink.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'third_party/blink/public/mojom/loader/javascript_framework_detection.mojom', '../../../third_party/blink/public/mojom/loader/javascript_framework_detection.mojom.js');
  }
  var request_priority$ =
      mojo.internal.exposeNamespace('network.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'services/network/public/mojom/request_priority.mojom', '../../../services/network/public/mojom/request_priority.mojom.js');
  }
  var web_feature$ =
      mojo.internal.exposeNamespace('blink.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'third_party/blink/public/mojom/use_counter/metrics/web_feature.mojom', '../../../third_party/blink/public/mojom/use_counter/metrics/web_feature.mojom.js');
  }
  var use_counter_feature$ =
      mojo.internal.exposeNamespace('blink.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'third_party/blink/public/mojom/use_counter/use_counter_feature.mojom', '../../../third_party/blink/public/mojom/use_counter/use_counter_feature.mojom.js');
  }


  var CacheType = {};
  CacheType.kNotCached = 0;
  CacheType.kHttp = 1;
  CacheType.kMemory = 2;
  CacheType.MIN_VALUE = 0;
  CacheType.MAX_VALUE = 2;

  CacheType.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    }
    return false;
  };

  CacheType.toKnownEnumValue = function(value) {
    return value;
  };

  CacheType.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var UserInteractionType = {};
  UserInteractionType.kKeyboard = 0;
  UserInteractionType.kTapOrClick = 1;
  UserInteractionType.kDrag = 2;
  UserInteractionType.MIN_VALUE = 0;
  UserInteractionType.MAX_VALUE = 2;

  UserInteractionType.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    }
    return false;
  };

  UserInteractionType.toKnownEnumValue = function(value) {
    return value;
  };

  UserInteractionType.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };

  function DocumentTiming(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  DocumentTiming.prototype.initDefaults_ = function() {
    this.domContentLoadedEventStart = null;
    this.loadEventStart = null;
  };
  DocumentTiming.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  DocumentTiming.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate DocumentTiming.domContentLoadedEventStart
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate DocumentTiming.loadEventStart
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  DocumentTiming.encodedSize = codec.kStructHeaderSize + 16;

  DocumentTiming.decode = function(decoder) {
    var packed;
    var val = new DocumentTiming();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.domContentLoadedEventStart =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.loadEventStart =
        decoder.decodeStructPointer(time$.TimeDelta);
    return val;
  };

  DocumentTiming.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(DocumentTiming.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(time$.TimeDelta, val.domContentLoadedEventStart);
    encoder.encodeStructPointer(time$.TimeDelta, val.loadEventStart);
  };
  function LargestContentfulPaintTiming(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  LargestContentfulPaintTiming.prototype.initDefaults_ = function() {
    this.largestImagePaint = null;
    this.largestImageDiscoveryTime = null;
    this.largestImageLoadStart = null;
    this.largestImageLoadEnd = null;
    this.largestImagePaintSize = 0;
    this.largestTextPaint = null;
    this.largestTextPaintSize = 0;
    this.type = 0;
    this.imageBpp = 0;
    this.imageRequestPriorityValid = false;
    this.isLoadedFromMemoryCache = false;
    this.isPreloadedWithEarlyHints = false;
    this.imageRequestPriorityValue = 0;
  };
  LargestContentfulPaintTiming.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  LargestContentfulPaintTiming.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 88}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate LargestContentfulPaintTiming.largestImagePaint
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate LargestContentfulPaintTiming.largestImageDiscoveryTime
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate LargestContentfulPaintTiming.largestImageLoadStart
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate LargestContentfulPaintTiming.largestImageLoadEnd
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 24, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;



    // validate LargestContentfulPaintTiming.largestTextPaint
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 40, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;






    // validate LargestContentfulPaintTiming.imageRequestPriorityValue
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 76, request_priority$.RequestPriority);
    if (err !== validator.validationError.NONE)
        return err;



    return validator.validationError.NONE;
  };

  LargestContentfulPaintTiming.encodedSize = codec.kStructHeaderSize + 80;

  LargestContentfulPaintTiming.decode = function(decoder) {
    var packed;
    var val = new LargestContentfulPaintTiming();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.largestImagePaint =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.largestImageDiscoveryTime =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.largestImageLoadStart =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.largestImageLoadEnd =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.largestImagePaintSize =
        decoder.decodeStruct(codec.Uint64);
    val.largestTextPaint =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.largestTextPaintSize =
        decoder.decodeStruct(codec.Uint64);
    val.type =
        decoder.decodeStruct(codec.Uint64);
    val.imageBpp =
        decoder.decodeStruct(codec.Double);
    packed = decoder.readUint8();
    val.imageRequestPriorityValid = (packed >> 0) & 1 ? true : false;
    val.isLoadedFromMemoryCache = (packed >> 1) & 1 ? true : false;
    val.isPreloadedWithEarlyHints = (packed >> 2) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.imageRequestPriorityValue =
        decoder.decodeStruct(new codec.Enum(request_priority$.RequestPriority));
    return val;
  };

  LargestContentfulPaintTiming.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(LargestContentfulPaintTiming.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(time$.TimeDelta, val.largestImagePaint);
    encoder.encodeStructPointer(time$.TimeDelta, val.largestImageDiscoveryTime);
    encoder.encodeStructPointer(time$.TimeDelta, val.largestImageLoadStart);
    encoder.encodeStructPointer(time$.TimeDelta, val.largestImageLoadEnd);
    encoder.encodeStruct(codec.Uint64, val.largestImagePaintSize);
    encoder.encodeStructPointer(time$.TimeDelta, val.largestTextPaint);
    encoder.encodeStruct(codec.Uint64, val.largestTextPaintSize);
    encoder.encodeStruct(codec.Uint64, val.type);
    encoder.encodeStruct(codec.Double, val.imageBpp);
    packed = 0;
    packed |= (val.imageRequestPriorityValid & 1) << 0
    packed |= (val.isLoadedFromMemoryCache & 1) << 1
    packed |= (val.isPreloadedWithEarlyHints & 1) << 2
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.Int32, val.imageRequestPriorityValue);
  };
  function PaintTiming(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  PaintTiming.prototype.initDefaults_ = function() {
    this.firstPaint = null;
    this.firstImagePaint = null;
    this.firstContentfulPaint = null;
    this.firstMeaningfulPaint = null;
    this.largestContentfulPaint = null;
    this.experimentalLargestContentfulPaint = null;
    this.firstEligibleToPaint = null;
    this.firstInputOrScrollNotifiedTimestamp = null;
    this.portalActivatedPaint = null;
  };
  PaintTiming.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  PaintTiming.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 80}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PaintTiming.firstPaint
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PaintTiming.firstImagePaint
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PaintTiming.firstContentfulPaint
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PaintTiming.firstMeaningfulPaint
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 24, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PaintTiming.largestContentfulPaint
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 32, LargestContentfulPaintTiming, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PaintTiming.experimentalLargestContentfulPaint
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 40, LargestContentfulPaintTiming, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PaintTiming.firstEligibleToPaint
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 48, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PaintTiming.firstInputOrScrollNotifiedTimestamp
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 56, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PaintTiming.portalActivatedPaint
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 64, time$.TimeTicks, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  PaintTiming.encodedSize = codec.kStructHeaderSize + 72;

  PaintTiming.decode = function(decoder) {
    var packed;
    var val = new PaintTiming();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.firstPaint =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.firstImagePaint =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.firstContentfulPaint =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.firstMeaningfulPaint =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.largestContentfulPaint =
        decoder.decodeStructPointer(LargestContentfulPaintTiming);
    val.experimentalLargestContentfulPaint =
        decoder.decodeStructPointer(LargestContentfulPaintTiming);
    val.firstEligibleToPaint =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.firstInputOrScrollNotifiedTimestamp =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.portalActivatedPaint =
        decoder.decodeStructPointer(time$.TimeTicks);
    return val;
  };

  PaintTiming.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(PaintTiming.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(time$.TimeDelta, val.firstPaint);
    encoder.encodeStructPointer(time$.TimeDelta, val.firstImagePaint);
    encoder.encodeStructPointer(time$.TimeDelta, val.firstContentfulPaint);
    encoder.encodeStructPointer(time$.TimeDelta, val.firstMeaningfulPaint);
    encoder.encodeStructPointer(LargestContentfulPaintTiming, val.largestContentfulPaint);
    encoder.encodeStructPointer(LargestContentfulPaintTiming, val.experimentalLargestContentfulPaint);
    encoder.encodeStructPointer(time$.TimeDelta, val.firstEligibleToPaint);
    encoder.encodeStructPointer(time$.TimeDelta, val.firstInputOrScrollNotifiedTimestamp);
    encoder.encodeStructPointer(time$.TimeTicks, val.portalActivatedPaint);
  };
  function ParseTiming(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ParseTiming.prototype.initDefaults_ = function() {
    this.parseStart = null;
    this.parseStop = null;
    this.parseBlockedOnScriptLoadDuration = null;
    this.parseBlockedOnScriptLoadFromDocumentWriteDuration = null;
    this.parseBlockedOnScriptExecutionDuration = null;
    this.parseBlockedOnScriptExecutionFromDocumentWriteDuration = null;
  };
  ParseTiming.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ParseTiming.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 56}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ParseTiming.parseStart
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ParseTiming.parseStop
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ParseTiming.parseBlockedOnScriptLoadDuration
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ParseTiming.parseBlockedOnScriptLoadFromDocumentWriteDuration
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 24, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ParseTiming.parseBlockedOnScriptExecutionDuration
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 32, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ParseTiming.parseBlockedOnScriptExecutionFromDocumentWriteDuration
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 40, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ParseTiming.encodedSize = codec.kStructHeaderSize + 48;

  ParseTiming.decode = function(decoder) {
    var packed;
    var val = new ParseTiming();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.parseStart =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.parseStop =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.parseBlockedOnScriptLoadDuration =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.parseBlockedOnScriptLoadFromDocumentWriteDuration =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.parseBlockedOnScriptExecutionDuration =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.parseBlockedOnScriptExecutionFromDocumentWriteDuration =
        decoder.decodeStructPointer(time$.TimeDelta);
    return val;
  };

  ParseTiming.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ParseTiming.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(time$.TimeDelta, val.parseStart);
    encoder.encodeStructPointer(time$.TimeDelta, val.parseStop);
    encoder.encodeStructPointer(time$.TimeDelta, val.parseBlockedOnScriptLoadDuration);
    encoder.encodeStructPointer(time$.TimeDelta, val.parseBlockedOnScriptLoadFromDocumentWriteDuration);
    encoder.encodeStructPointer(time$.TimeDelta, val.parseBlockedOnScriptExecutionDuration);
    encoder.encodeStructPointer(time$.TimeDelta, val.parseBlockedOnScriptExecutionFromDocumentWriteDuration);
  };
  function InteractiveTiming(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  InteractiveTiming.prototype.initDefaults_ = function() {
    this.firstInputDelay = null;
    this.firstInputTimestamp = null;
    this.longestInputDelay = null;
    this.longestInputTimestamp = null;
    this.firstScrollDelay = null;
    this.firstScrollTimestamp = null;
    this.firstInputProcessingTime = null;
  };
  InteractiveTiming.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  InteractiveTiming.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 64}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate InteractiveTiming.firstInputDelay
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate InteractiveTiming.firstInputTimestamp
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate InteractiveTiming.longestInputDelay
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate InteractiveTiming.longestInputTimestamp
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 24, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate InteractiveTiming.firstScrollDelay
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 32, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate InteractiveTiming.firstScrollTimestamp
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 40, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate InteractiveTiming.firstInputProcessingTime
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 48, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  InteractiveTiming.encodedSize = codec.kStructHeaderSize + 56;

  InteractiveTiming.decode = function(decoder) {
    var packed;
    var val = new InteractiveTiming();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.firstInputDelay =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.firstInputTimestamp =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.longestInputDelay =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.longestInputTimestamp =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.firstScrollDelay =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.firstScrollTimestamp =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.firstInputProcessingTime =
        decoder.decodeStructPointer(time$.TimeDelta);
    return val;
  };

  InteractiveTiming.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(InteractiveTiming.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(time$.TimeDelta, val.firstInputDelay);
    encoder.encodeStructPointer(time$.TimeDelta, val.firstInputTimestamp);
    encoder.encodeStructPointer(time$.TimeDelta, val.longestInputDelay);
    encoder.encodeStructPointer(time$.TimeDelta, val.longestInputTimestamp);
    encoder.encodeStructPointer(time$.TimeDelta, val.firstScrollDelay);
    encoder.encodeStructPointer(time$.TimeDelta, val.firstScrollTimestamp);
    encoder.encodeStructPointer(time$.TimeDelta, val.firstInputProcessingTime);
  };
  function PageLoadTiming(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  PageLoadTiming.prototype.initDefaults_ = function() {
    this.navigationStart = null;
    this.responseStart = null;
    this.documentTiming = null;
    this.interactiveTiming = null;
    this.paintTiming = null;
    this.parseTiming = null;
    this.backForwardCacheTimings = null;
    this.activationStart = null;
    this.inputToNavigationStart = null;
    this.userTimingMarkFullyLoaded = null;
    this.userTimingMarkFullyVisible = null;
    this.userTimingMarkInteractive = null;
  };
  PageLoadTiming.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  PageLoadTiming.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 104}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageLoadTiming.navigationStart
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, time$.Time, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageLoadTiming.responseStart
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageLoadTiming.documentTiming
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, DocumentTiming, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageLoadTiming.interactiveTiming
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 24, InteractiveTiming, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageLoadTiming.paintTiming
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 32, PaintTiming, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageLoadTiming.parseTiming
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 40, ParseTiming, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageLoadTiming.backForwardCacheTimings
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 48, 8, new codec.PointerTo(BackForwardCacheTiming), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageLoadTiming.activationStart
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 56, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageLoadTiming.inputToNavigationStart
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 64, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageLoadTiming.userTimingMarkFullyLoaded
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 72, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageLoadTiming.userTimingMarkFullyVisible
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 80, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageLoadTiming.userTimingMarkInteractive
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 88, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  PageLoadTiming.encodedSize = codec.kStructHeaderSize + 96;

  PageLoadTiming.decode = function(decoder) {
    var packed;
    var val = new PageLoadTiming();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.navigationStart =
        decoder.decodeStructPointer(time$.Time);
    val.responseStart =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.documentTiming =
        decoder.decodeStructPointer(DocumentTiming);
    val.interactiveTiming =
        decoder.decodeStructPointer(InteractiveTiming);
    val.paintTiming =
        decoder.decodeStructPointer(PaintTiming);
    val.parseTiming =
        decoder.decodeStructPointer(ParseTiming);
    val.backForwardCacheTimings =
        decoder.decodeArrayPointer(new codec.PointerTo(BackForwardCacheTiming));
    val.activationStart =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.inputToNavigationStart =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.userTimingMarkFullyLoaded =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.userTimingMarkFullyVisible =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.userTimingMarkInteractive =
        decoder.decodeStructPointer(time$.TimeDelta);
    return val;
  };

  PageLoadTiming.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(PageLoadTiming.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(time$.Time, val.navigationStart);
    encoder.encodeStructPointer(time$.TimeDelta, val.responseStart);
    encoder.encodeStructPointer(DocumentTiming, val.documentTiming);
    encoder.encodeStructPointer(InteractiveTiming, val.interactiveTiming);
    encoder.encodeStructPointer(PaintTiming, val.paintTiming);
    encoder.encodeStructPointer(ParseTiming, val.parseTiming);
    encoder.encodeArrayPointer(new codec.PointerTo(BackForwardCacheTiming), val.backForwardCacheTimings);
    encoder.encodeStructPointer(time$.TimeDelta, val.activationStart);
    encoder.encodeStructPointer(time$.TimeDelta, val.inputToNavigationStart);
    encoder.encodeStructPointer(time$.TimeDelta, val.userTimingMarkFullyLoaded);
    encoder.encodeStructPointer(time$.TimeDelta, val.userTimingMarkFullyVisible);
    encoder.encodeStructPointer(time$.TimeDelta, val.userTimingMarkInteractive);
  };
  function FrameMetadata(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  FrameMetadata.prototype.initDefaults_ = function() {
    this.behaviorFlags = 0;
    this.mainFrameIntersectionRect = null;
    this.mainFrameViewportRect = null;
    this.mainFrameImageAdRects = null;
    this.frameworkDetectionResult = null;
  };
  FrameMetadata.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  FrameMetadata.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 48}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    // validate FrameMetadata.mainFrameIntersectionRect
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, geometry$.Rect, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FrameMetadata.mainFrameViewportRect
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, geometry$.Rect, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FrameMetadata.mainFrameImageAdRects
    err = messageValidator.validateMapPointer(offset + codec.kStructHeaderSize + 24, false, codec.Int32, new codec.PointerTo(geometry$.Rect), false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FrameMetadata.frameworkDetectionResult
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 32, javascript_framework_detection$.JavaScriptFrameworkDetectionResult, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  FrameMetadata.encodedSize = codec.kStructHeaderSize + 40;

  FrameMetadata.decode = function(decoder) {
    var packed;
    var val = new FrameMetadata();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.behaviorFlags =
        decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.mainFrameIntersectionRect =
        decoder.decodeStructPointer(geometry$.Rect);
    val.mainFrameViewportRect =
        decoder.decodeStructPointer(geometry$.Rect);
    val.mainFrameImageAdRects =
        decoder.decodeMapPointer(codec.Int32, new codec.PointerTo(geometry$.Rect));
    val.frameworkDetectionResult =
        decoder.decodeStructPointer(javascript_framework_detection$.JavaScriptFrameworkDetectionResult);
    return val;
  };

  FrameMetadata.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(FrameMetadata.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.behaviorFlags);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStructPointer(geometry$.Rect, val.mainFrameIntersectionRect);
    encoder.encodeStructPointer(geometry$.Rect, val.mainFrameViewportRect);
    encoder.encodeMapPointer(codec.Int32, new codec.PointerTo(geometry$.Rect), val.mainFrameImageAdRects);
    encoder.encodeStructPointer(javascript_framework_detection$.JavaScriptFrameworkDetectionResult, val.frameworkDetectionResult);
  };
  function SubresourceLoadMetrics(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SubresourceLoadMetrics.prototype.initDefaults_ = function() {
    this.numberOfSubresourcesLoaded = 0;
    this.numberOfSubresourceLoadsHandledByServiceWorker = 0;
    this.serviceWorkerSubresourceLoadMetrics = null;
  };
  SubresourceLoadMetrics.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SubresourceLoadMetrics.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;




    // validate SubresourceLoadMetrics.serviceWorkerSubresourceLoadMetrics
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, ServiceWorkerSubresourceLoadMetrics, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  SubresourceLoadMetrics.encodedSize = codec.kStructHeaderSize + 16;

  SubresourceLoadMetrics.decode = function(decoder) {
    var packed;
    var val = new SubresourceLoadMetrics();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.numberOfSubresourcesLoaded =
        decoder.decodeStruct(codec.Uint32);
    val.numberOfSubresourceLoadsHandledByServiceWorker =
        decoder.decodeStruct(codec.Uint32);
    val.serviceWorkerSubresourceLoadMetrics =
        decoder.decodeStructPointer(ServiceWorkerSubresourceLoadMetrics);
    return val;
  };

  SubresourceLoadMetrics.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SubresourceLoadMetrics.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint32, val.numberOfSubresourcesLoaded);
    encoder.encodeStruct(codec.Uint32, val.numberOfSubresourceLoadsHandledByServiceWorker);
    encoder.encodeStructPointer(ServiceWorkerSubresourceLoadMetrics, val.serviceWorkerSubresourceLoadMetrics);
  };
  function ServiceWorkerSubresourceLoadMetrics(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ServiceWorkerSubresourceLoadMetrics.prototype.initDefaults_ = function() {
    this.imageHandled = false;
    this.imageFallback = false;
    this.cssHandled = false;
    this.cssFallback = false;
    this.scriptHandled = false;
    this.scriptFallback = false;
    this.fontHandled = false;
    this.fontFallback = false;
    this.rawHandled = false;
    this.rawFallback = false;
    this.svgHandled = false;
    this.svgFallback = false;
    this.xslHandled = false;
    this.xslFallback = false;
    this.linkPrefetchHandled = false;
    this.linkPrefetchFallback = false;
    this.textTrackHandled = false;
    this.textTrackFallback = false;
    this.audioHandled = false;
    this.audioFallback = false;
    this.videoHandled = false;
    this.videoFallback = false;
    this.manifestHandled = false;
    this.manifestFallback = false;
    this.speculationRulesHandled = false;
    this.speculationRulesFallback = false;
    this.mockHandled = false;
    this.mockFallback = false;
    this.dictionaryHandled = false;
    this.dictionaryFallback = false;
  };
  ServiceWorkerSubresourceLoadMetrics.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ServiceWorkerSubresourceLoadMetrics.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;































    return validator.validationError.NONE;
  };

  ServiceWorkerSubresourceLoadMetrics.encodedSize = codec.kStructHeaderSize + 8;

  ServiceWorkerSubresourceLoadMetrics.decode = function(decoder) {
    var packed;
    var val = new ServiceWorkerSubresourceLoadMetrics();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    packed = decoder.readUint8();
    val.imageHandled = (packed >> 0) & 1 ? true : false;
    val.imageFallback = (packed >> 1) & 1 ? true : false;
    val.cssHandled = (packed >> 2) & 1 ? true : false;
    val.cssFallback = (packed >> 3) & 1 ? true : false;
    val.scriptHandled = (packed >> 4) & 1 ? true : false;
    val.scriptFallback = (packed >> 5) & 1 ? true : false;
    val.fontHandled = (packed >> 6) & 1 ? true : false;
    val.fontFallback = (packed >> 7) & 1 ? true : false;
    packed = decoder.readUint8();
    val.rawHandled = (packed >> 0) & 1 ? true : false;
    val.rawFallback = (packed >> 1) & 1 ? true : false;
    val.svgHandled = (packed >> 2) & 1 ? true : false;
    val.svgFallback = (packed >> 3) & 1 ? true : false;
    val.xslHandled = (packed >> 4) & 1 ? true : false;
    val.xslFallback = (packed >> 5) & 1 ? true : false;
    val.linkPrefetchHandled = (packed >> 6) & 1 ? true : false;
    val.linkPrefetchFallback = (packed >> 7) & 1 ? true : false;
    packed = decoder.readUint8();
    val.textTrackHandled = (packed >> 0) & 1 ? true : false;
    val.textTrackFallback = (packed >> 1) & 1 ? true : false;
    val.audioHandled = (packed >> 2) & 1 ? true : false;
    val.audioFallback = (packed >> 3) & 1 ? true : false;
    val.videoHandled = (packed >> 4) & 1 ? true : false;
    val.videoFallback = (packed >> 5) & 1 ? true : false;
    val.manifestHandled = (packed >> 6) & 1 ? true : false;
    val.manifestFallback = (packed >> 7) & 1 ? true : false;
    packed = decoder.readUint8();
    val.speculationRulesHandled = (packed >> 0) & 1 ? true : false;
    val.speculationRulesFallback = (packed >> 1) & 1 ? true : false;
    val.mockHandled = (packed >> 2) & 1 ? true : false;
    val.mockFallback = (packed >> 3) & 1 ? true : false;
    val.dictionaryHandled = (packed >> 4) & 1 ? true : false;
    val.dictionaryFallback = (packed >> 5) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  ServiceWorkerSubresourceLoadMetrics.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ServiceWorkerSubresourceLoadMetrics.encodedSize);
    encoder.writeUint32(0);
    packed = 0;
    packed |= (val.imageHandled & 1) << 0
    packed |= (val.imageFallback & 1) << 1
    packed |= (val.cssHandled & 1) << 2
    packed |= (val.cssFallback & 1) << 3
    packed |= (val.scriptHandled & 1) << 4
    packed |= (val.scriptFallback & 1) << 5
    packed |= (val.fontHandled & 1) << 6
    packed |= (val.fontFallback & 1) << 7
    encoder.writeUint8(packed);
    packed = 0;
    packed |= (val.rawHandled & 1) << 0
    packed |= (val.rawFallback & 1) << 1
    packed |= (val.svgHandled & 1) << 2
    packed |= (val.svgFallback & 1) << 3
    packed |= (val.xslHandled & 1) << 4
    packed |= (val.xslFallback & 1) << 5
    packed |= (val.linkPrefetchHandled & 1) << 6
    packed |= (val.linkPrefetchFallback & 1) << 7
    encoder.writeUint8(packed);
    packed = 0;
    packed |= (val.textTrackHandled & 1) << 0
    packed |= (val.textTrackFallback & 1) << 1
    packed |= (val.audioHandled & 1) << 2
    packed |= (val.audioFallback & 1) << 3
    packed |= (val.videoHandled & 1) << 4
    packed |= (val.videoFallback & 1) << 5
    packed |= (val.manifestHandled & 1) << 6
    packed |= (val.manifestFallback & 1) << 7
    encoder.writeUint8(packed);
    packed = 0;
    packed |= (val.speculationRulesHandled & 1) << 0
    packed |= (val.speculationRulesFallback & 1) << 1
    packed |= (val.mockHandled & 1) << 2
    packed |= (val.mockFallback & 1) << 3
    packed |= (val.dictionaryHandled & 1) << 4
    packed |= (val.dictionaryFallback & 1) << 5
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function ResourceDataUpdate(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ResourceDataUpdate.prototype.initDefaults_ = function() {
    this.requestId = 0;
    this.isComplete = false;
    this.reportedAsAdResource = false;
    this.isMainFrameResource = false;
    this.isPrimaryFrameResource = false;
    this.isSecureScheme = false;
    this.proxyUsed = false;
    this.completedBeforeFcp = false;
    this.deltaBytes = 0;
    this.receivedDataLength = 0;
    this.encodedBodyLength = 0;
    this.decodedBodyLength = 0;
    this.cacheType = 0;
    this.mimeType = null;
  };
  ResourceDataUpdate.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ResourceDataUpdate.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 64}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;










    // validate ResourceDataUpdate.cacheType
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 40, CacheType);
    if (err !== validator.validationError.NONE)
        return err;



    // validate ResourceDataUpdate.mimeType
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 48, false)
    if (err !== validator.validationError.NONE)
        return err;




    return validator.validationError.NONE;
  };

  ResourceDataUpdate.encodedSize = codec.kStructHeaderSize + 56;

  ResourceDataUpdate.decode = function(decoder) {
    var packed;
    var val = new ResourceDataUpdate();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.requestId =
        decoder.decodeStruct(codec.Int32);
    packed = decoder.readUint8();
    val.isComplete = (packed >> 0) & 1 ? true : false;
    val.reportedAsAdResource = (packed >> 1) & 1 ? true : false;
    val.isMainFrameResource = (packed >> 2) & 1 ? true : false;
    val.isPrimaryFrameResource = (packed >> 3) & 1 ? true : false;
    val.isSecureScheme = (packed >> 4) & 1 ? true : false;
    val.proxyUsed = (packed >> 5) & 1 ? true : false;
    val.completedBeforeFcp = (packed >> 6) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.deltaBytes =
        decoder.decodeStruct(codec.Int64);
    val.receivedDataLength =
        decoder.decodeStruct(codec.Int64);
    val.encodedBodyLength =
        decoder.decodeStruct(codec.Int64);
    val.decodedBodyLength =
        decoder.decodeStruct(codec.Int64);
    val.cacheType =
        decoder.decodeStruct(new codec.Enum(CacheType));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.mimeType =
        decoder.decodeStruct(codec.String);
    return val;
  };

  ResourceDataUpdate.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ResourceDataUpdate.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.requestId);
    packed = 0;
    packed |= (val.isComplete & 1) << 0
    packed |= (val.reportedAsAdResource & 1) << 1
    packed |= (val.isMainFrameResource & 1) << 2
    packed |= (val.isPrimaryFrameResource & 1) << 3
    packed |= (val.isSecureScheme & 1) << 4
    packed |= (val.proxyUsed & 1) << 5
    packed |= (val.completedBeforeFcp & 1) << 6
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.Int64, val.deltaBytes);
    encoder.encodeStruct(codec.Int64, val.receivedDataLength);
    encoder.encodeStruct(codec.Int64, val.encodedBodyLength);
    encoder.encodeStruct(codec.Int64, val.decodedBodyLength);
    encoder.encodeStruct(codec.Int32, val.cacheType);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.String, val.mimeType);
  };
  function LayoutShift(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  LayoutShift.prototype.initDefaults_ = function() {
    this.layoutShiftTime = null;
    this.layoutShiftScore = 0;
  };
  LayoutShift.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  LayoutShift.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate LayoutShift.layoutShiftTime
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, time$.TimeTicks, false);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  LayoutShift.encodedSize = codec.kStructHeaderSize + 16;

  LayoutShift.decode = function(decoder) {
    var packed;
    var val = new LayoutShift();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.layoutShiftTime =
        decoder.decodeStructPointer(time$.TimeTicks);
    val.layoutShiftScore =
        decoder.decodeStruct(codec.Double);
    return val;
  };

  LayoutShift.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(LayoutShift.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(time$.TimeTicks, val.layoutShiftTime);
    encoder.encodeStruct(codec.Double, val.layoutShiftScore);
  };
  function FrameRenderDataUpdate(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  FrameRenderDataUpdate.prototype.initDefaults_ = function() {
    this.layoutShiftDelta = 0;
    this.layoutShiftDeltaBeforeInputOrScroll = 0;
    this.newLayoutShifts = null;
  };
  FrameRenderDataUpdate.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  FrameRenderDataUpdate.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;




    // validate FrameRenderDataUpdate.newLayoutShifts
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 8, 8, new codec.PointerTo(LayoutShift), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  FrameRenderDataUpdate.encodedSize = codec.kStructHeaderSize + 16;

  FrameRenderDataUpdate.decode = function(decoder) {
    var packed;
    var val = new FrameRenderDataUpdate();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.layoutShiftDelta =
        decoder.decodeStruct(codec.Float);
    val.layoutShiftDeltaBeforeInputOrScroll =
        decoder.decodeStruct(codec.Float);
    val.newLayoutShifts =
        decoder.decodeArrayPointer(new codec.PointerTo(LayoutShift));
    return val;
  };

  FrameRenderDataUpdate.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(FrameRenderDataUpdate.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Float, val.layoutShiftDelta);
    encoder.encodeStruct(codec.Float, val.layoutShiftDeltaBeforeInputOrScroll);
    encoder.encodeArrayPointer(new codec.PointerTo(LayoutShift), val.newLayoutShifts);
  };
  function CpuTiming(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  CpuTiming.prototype.initDefaults_ = function() {
    this.taskTime = null;
  };
  CpuTiming.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  CpuTiming.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate CpuTiming.taskTime
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, time$.TimeDelta, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  CpuTiming.encodedSize = codec.kStructHeaderSize + 8;

  CpuTiming.decode = function(decoder) {
    var packed;
    var val = new CpuTiming();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.taskTime =
        decoder.decodeStructPointer(time$.TimeDelta);
    return val;
  };

  CpuTiming.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(CpuTiming.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(time$.TimeDelta, val.taskTime);
  };
  function InputTiming(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  InputTiming.prototype.initDefaults_ = function() {
    this.totalInputDelay = null;
    this.totalAdjustedInputDelay = null;
    this.numInputEvents = 0;
    this.numInteractions = 0;
    this.maxEventDurations = null;
  };
  InputTiming.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  InputTiming.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 56}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate InputTiming.totalInputDelay
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, time$.TimeDelta, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate InputTiming.totalAdjustedInputDelay
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, time$.TimeDelta, false);
    if (err !== validator.validationError.NONE)
        return err;




    // validate InputTiming.maxEventDurations
    err = messageValidator.validateUnion(offset + codec.kStructHeaderSize + 32, UserInteractionLatencies, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  InputTiming.encodedSize = codec.kStructHeaderSize + 48;

  InputTiming.decode = function(decoder) {
    var packed;
    var val = new InputTiming();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.totalInputDelay =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.totalAdjustedInputDelay =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.numInputEvents =
        decoder.decodeStruct(codec.Uint64);
    val.numInteractions =
        decoder.decodeStruct(codec.Uint64);
    val.maxEventDurations =
        decoder.decodeStruct(UserInteractionLatencies);
    return val;
  };

  InputTiming.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(InputTiming.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(time$.TimeDelta, val.totalInputDelay);
    encoder.encodeStructPointer(time$.TimeDelta, val.totalAdjustedInputDelay);
    encoder.encodeStruct(codec.Uint64, val.numInputEvents);
    encoder.encodeStruct(codec.Uint64, val.numInteractions);
    encoder.encodeStruct(UserInteractionLatencies, val.maxEventDurations);
  };
  function UserInteractionLatency(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  UserInteractionLatency.prototype.initDefaults_ = function() {
    this.interactionLatency = null;
    this.interactionType = 0;
  };
  UserInteractionLatency.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  UserInteractionLatency.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate UserInteractionLatency.interactionLatency
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, time$.TimeDelta, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate UserInteractionLatency.interactionType
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 8, UserInteractionType);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  UserInteractionLatency.encodedSize = codec.kStructHeaderSize + 16;

  UserInteractionLatency.decode = function(decoder) {
    var packed;
    var val = new UserInteractionLatency();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.interactionLatency =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.interactionType =
        decoder.decodeStruct(new codec.Enum(UserInteractionType));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  UserInteractionLatency.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(UserInteractionLatency.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(time$.TimeDelta, val.interactionLatency);
    encoder.encodeStruct(codec.Int32, val.interactionType);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function BackForwardCacheTiming(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  BackForwardCacheTiming.prototype.initDefaults_ = function() {
    this.firstPaintAfterBackForwardCacheRestore = null;
    this.requestAnimationFramesAfterBackForwardCacheRestore = null;
    this.firstInputDelayAfterBackForwardCacheRestore = null;
  };
  BackForwardCacheTiming.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  BackForwardCacheTiming.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 32}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate BackForwardCacheTiming.firstPaintAfterBackForwardCacheRestore
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, time$.TimeDelta, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate BackForwardCacheTiming.requestAnimationFramesAfterBackForwardCacheRestore
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 8, 8, new codec.PointerTo(time$.TimeDelta), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate BackForwardCacheTiming.firstInputDelayAfterBackForwardCacheRestore
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, time$.TimeDelta, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  BackForwardCacheTiming.encodedSize = codec.kStructHeaderSize + 24;

  BackForwardCacheTiming.decode = function(decoder) {
    var packed;
    var val = new BackForwardCacheTiming();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.firstPaintAfterBackForwardCacheRestore =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.requestAnimationFramesAfterBackForwardCacheRestore =
        decoder.decodeArrayPointer(new codec.PointerTo(time$.TimeDelta));
    val.firstInputDelayAfterBackForwardCacheRestore =
        decoder.decodeStructPointer(time$.TimeDelta);
    return val;
  };

  BackForwardCacheTiming.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(BackForwardCacheTiming.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(time$.TimeDelta, val.firstPaintAfterBackForwardCacheRestore);
    encoder.encodeArrayPointer(new codec.PointerTo(time$.TimeDelta), val.requestAnimationFramesAfterBackForwardCacheRestore);
    encoder.encodeStructPointer(time$.TimeDelta, val.firstInputDelayAfterBackForwardCacheRestore);
  };
  function SoftNavigationMetrics(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SoftNavigationMetrics.prototype.initDefaults_ = function() {
    this.count = 0;
    this.startTime = null;
    this.navigationId = null;
    this.largestContentfulPaint = null;
  };
  SoftNavigationMetrics.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SoftNavigationMetrics.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 40}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    // validate SoftNavigationMetrics.startTime
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, time$.TimeDelta, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate SoftNavigationMetrics.navigationId
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 16, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate SoftNavigationMetrics.largestContentfulPaint
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 24, LargestContentfulPaintTiming, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  SoftNavigationMetrics.encodedSize = codec.kStructHeaderSize + 32;

  SoftNavigationMetrics.decode = function(decoder) {
    var packed;
    var val = new SoftNavigationMetrics();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.count =
        decoder.decodeStruct(codec.Uint64);
    val.startTime =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.navigationId =
        decoder.decodeStruct(codec.String);
    val.largestContentfulPaint =
        decoder.decodeStructPointer(LargestContentfulPaintTiming);
    return val;
  };

  SoftNavigationMetrics.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SoftNavigationMetrics.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint64, val.count);
    encoder.encodeStructPointer(time$.TimeDelta, val.startTime);
    encoder.encodeStruct(codec.String, val.navigationId);
    encoder.encodeStructPointer(LargestContentfulPaintTiming, val.largestContentfulPaint);
  };
  function PageLoadMetrics_UpdateTiming_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  PageLoadMetrics_UpdateTiming_Params.prototype.initDefaults_ = function() {
    this.pageLoadTiming = null;
    this.frameMetadata = null;
    this.newFeatures = null;
    this.resources = null;
    this.renderData = null;
    this.cpuLoadTiming = null;
    this.inputTimingDelta = null;
    this.subresourceLoadMetrics = null;
    this.softNavigationMetrics = null;
  };
  PageLoadMetrics_UpdateTiming_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  PageLoadMetrics_UpdateTiming_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 80}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageLoadMetrics_UpdateTiming_Params.pageLoadTiming
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, PageLoadTiming, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageLoadMetrics_UpdateTiming_Params.frameMetadata
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, FrameMetadata, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageLoadMetrics_UpdateTiming_Params.newFeatures
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 16, 8, new codec.PointerTo(use_counter_feature$.UseCounterFeature), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageLoadMetrics_UpdateTiming_Params.resources
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 24, 8, new codec.PointerTo(ResourceDataUpdate), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageLoadMetrics_UpdateTiming_Params.renderData
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 32, FrameRenderDataUpdate, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageLoadMetrics_UpdateTiming_Params.cpuLoadTiming
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 40, CpuTiming, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageLoadMetrics_UpdateTiming_Params.inputTimingDelta
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 48, InputTiming, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageLoadMetrics_UpdateTiming_Params.subresourceLoadMetrics
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 56, SubresourceLoadMetrics, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageLoadMetrics_UpdateTiming_Params.softNavigationMetrics
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 64, SoftNavigationMetrics, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  PageLoadMetrics_UpdateTiming_Params.encodedSize = codec.kStructHeaderSize + 72;

  PageLoadMetrics_UpdateTiming_Params.decode = function(decoder) {
    var packed;
    var val = new PageLoadMetrics_UpdateTiming_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.pageLoadTiming =
        decoder.decodeStructPointer(PageLoadTiming);
    val.frameMetadata =
        decoder.decodeStructPointer(FrameMetadata);
    val.newFeatures =
        decoder.decodeArrayPointer(new codec.PointerTo(use_counter_feature$.UseCounterFeature));
    val.resources =
        decoder.decodeArrayPointer(new codec.PointerTo(ResourceDataUpdate));
    val.renderData =
        decoder.decodeStructPointer(FrameRenderDataUpdate);
    val.cpuLoadTiming =
        decoder.decodeStructPointer(CpuTiming);
    val.inputTimingDelta =
        decoder.decodeStructPointer(InputTiming);
    val.subresourceLoadMetrics =
        decoder.decodeStructPointer(SubresourceLoadMetrics);
    val.softNavigationMetrics =
        decoder.decodeStructPointer(SoftNavigationMetrics);
    return val;
  };

  PageLoadMetrics_UpdateTiming_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(PageLoadMetrics_UpdateTiming_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(PageLoadTiming, val.pageLoadTiming);
    encoder.encodeStructPointer(FrameMetadata, val.frameMetadata);
    encoder.encodeArrayPointer(new codec.PointerTo(use_counter_feature$.UseCounterFeature), val.newFeatures);
    encoder.encodeArrayPointer(new codec.PointerTo(ResourceDataUpdate), val.resources);
    encoder.encodeStructPointer(FrameRenderDataUpdate, val.renderData);
    encoder.encodeStructPointer(CpuTiming, val.cpuLoadTiming);
    encoder.encodeStructPointer(InputTiming, val.inputTimingDelta);
    encoder.encodeStructPointer(SubresourceLoadMetrics, val.subresourceLoadMetrics);
    encoder.encodeStructPointer(SoftNavigationMetrics, val.softNavigationMetrics);
  };
  function PageLoadMetrics_SetUpSharedMemoryForSmoothness_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  PageLoadMetrics_SetUpSharedMemoryForSmoothness_Params.prototype.initDefaults_ = function() {
    this.sharedMemory = null;
  };
  PageLoadMetrics_SetUpSharedMemoryForSmoothness_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  PageLoadMetrics_SetUpSharedMemoryForSmoothness_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PageLoadMetrics_SetUpSharedMemoryForSmoothness_Params.sharedMemory
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, shared_memory$.ReadOnlySharedMemoryRegion, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  PageLoadMetrics_SetUpSharedMemoryForSmoothness_Params.encodedSize = codec.kStructHeaderSize + 8;

  PageLoadMetrics_SetUpSharedMemoryForSmoothness_Params.decode = function(decoder) {
    var packed;
    var val = new PageLoadMetrics_SetUpSharedMemoryForSmoothness_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.sharedMemory =
        decoder.decodeStructPointer(shared_memory$.ReadOnlySharedMemoryRegion);
    return val;
  };

  PageLoadMetrics_SetUpSharedMemoryForSmoothness_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(PageLoadMetrics_SetUpSharedMemoryForSmoothness_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(shared_memory$.ReadOnlySharedMemoryRegion, val.sharedMemory);
  };

  function UserInteractionLatencies(value) {
    this.initDefault_();
    this.initValue_(value);
  }


  UserInteractionLatencies.Tags = {
    userInteractionLatencies: 0,
    worstInteractionLatency: 1,
  };

  UserInteractionLatencies.prototype.initDefault_ = function() {
    this.$data = null;
    this.$tag = undefined;
  }

  UserInteractionLatencies.prototype.initValue_ = function(value) {
    if (value == undefined) {
      return;
    }

    var keys = Object.keys(value);
    if (keys.length == 0) {
      return;
    }

    if (keys.length > 1) {
      throw new TypeError("You may set only one member on a union.");
    }

    var fields = [
        "userInteractionLatencies",
        "worstInteractionLatency",
    ];

    if (fields.indexOf(keys[0]) < 0) {
      throw new ReferenceError(keys[0] + " is not a UserInteractionLatencies member.");

    }

    this[keys[0]] = value[keys[0]];
  }
  Object.defineProperty(UserInteractionLatencies.prototype, "userInteractionLatencies", {
    get: function() {
      if (this.$tag != UserInteractionLatencies.Tags.userInteractionLatencies) {
        throw new ReferenceError(
            "UserInteractionLatencies.userInteractionLatencies is not currently set.");
      }
      return this.$data;
    },

    set: function(value) {
      this.$tag = UserInteractionLatencies.Tags.userInteractionLatencies;
      this.$data = value;
    }
  });
  Object.defineProperty(UserInteractionLatencies.prototype, "worstInteractionLatency", {
    get: function() {
      if (this.$tag != UserInteractionLatencies.Tags.worstInteractionLatency) {
        throw new ReferenceError(
            "UserInteractionLatencies.worstInteractionLatency is not currently set.");
      }
      return this.$data;
    },

    set: function(value) {
      this.$tag = UserInteractionLatencies.Tags.worstInteractionLatency;
      this.$data = value;
    }
  });


    UserInteractionLatencies.encode = function(encoder, val) {
      if (val == null) {
        encoder.writeUint64(0);
        encoder.writeUint64(0);
        return;
      }
      if (val.$tag == undefined) {
        throw new TypeError("Cannot encode unions with an unknown member set.");
      }

      encoder.writeUint32(16);
      encoder.writeUint32(val.$tag);
      switch (val.$tag) {
        case UserInteractionLatencies.Tags.userInteractionLatencies:
          encoder.encodeArrayPointer(new codec.PointerTo(UserInteractionLatency), val.userInteractionLatencies);
          break;
        case UserInteractionLatencies.Tags.worstInteractionLatency:
          encoder.encodeStructPointer(time$.TimeDelta, val.worstInteractionLatency);
          break;
      }
      encoder.align();
    };


    UserInteractionLatencies.decode = function(decoder) {
      var size = decoder.readUint32();
      if (size == 0) {
        decoder.readUint32();
        decoder.readUint64();
        return null;
      }

      var result = new UserInteractionLatencies();
      var tag = decoder.readUint32();
      switch (tag) {
        case UserInteractionLatencies.Tags.userInteractionLatencies:
          result.userInteractionLatencies = decoder.decodeArrayPointer(new codec.PointerTo(UserInteractionLatency));
          break;
        case UserInteractionLatencies.Tags.worstInteractionLatency:
          result.worstInteractionLatency = decoder.decodeStructPointer(time$.TimeDelta);
          break;
      }
      decoder.align();

      return result;
    };


    UserInteractionLatencies.validate = function(messageValidator, offset) {
      var size = messageValidator.decodeUnionSize(offset);
      if (size != 16) {
        return validator.validationError.INVALID_UNION_SIZE;
      }

      var tag = messageValidator.decodeUnionTag(offset);
      var data_offset = offset + 8;
      var err;
      switch (tag) {
        case UserInteractionLatencies.Tags.userInteractionLatencies:
          

    // validate UserInteractionLatencies.userInteractionLatencies
    err = messageValidator.validateArrayPointer(data_offset, 8, new codec.PointerTo(UserInteractionLatency), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;
          break;
        case UserInteractionLatencies.Tags.worstInteractionLatency:
          

    // validate UserInteractionLatencies.worstInteractionLatency
    err = messageValidator.validateStructPointer(data_offset, time$.TimeDelta, false);
    if (err !== validator.validationError.NONE)
        return err;
          break;
      }

      return validator.validationError.NONE;
    };

  UserInteractionLatencies.encodedSize = 16;
  var kPageLoadMetrics_UpdateTiming_Name = 1881093912;
  var kPageLoadMetrics_SetUpSharedMemoryForSmoothness_Name = 1561420069;

  function PageLoadMetricsPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(PageLoadMetrics,
                                                   handleOrPtrInfo);
  }

  function PageLoadMetricsAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        PageLoadMetrics, associatedInterfacePtrInfo);
  }

  PageLoadMetricsAssociatedPtr.prototype =
      Object.create(PageLoadMetricsPtr.prototype);
  PageLoadMetricsAssociatedPtr.prototype.constructor =
      PageLoadMetricsAssociatedPtr;

  function PageLoadMetricsProxy(receiver) {
    this.receiver_ = receiver;
  }
  PageLoadMetricsPtr.prototype.updateTiming = function() {
    return PageLoadMetricsProxy.prototype.updateTiming
        .apply(this.ptr.getProxy(), arguments);
  };

  PageLoadMetricsProxy.prototype.updateTiming = function(pageLoadTiming, frameMetadata, newFeatures, resources, renderData, cpuLoadTiming, inputTimingDelta, subresourceLoadMetrics, softNavigationMetrics) {
    var params_ = new PageLoadMetrics_UpdateTiming_Params();
    params_.pageLoadTiming = pageLoadTiming;
    params_.frameMetadata = frameMetadata;
    params_.newFeatures = newFeatures;
    params_.resources = resources;
    params_.renderData = renderData;
    params_.cpuLoadTiming = cpuLoadTiming;
    params_.inputTimingDelta = inputTimingDelta;
    params_.subresourceLoadMetrics = subresourceLoadMetrics;
    params_.softNavigationMetrics = softNavigationMetrics;
    var builder = new codec.MessageV0Builder(
        kPageLoadMetrics_UpdateTiming_Name,
        codec.align(PageLoadMetrics_UpdateTiming_Params.encodedSize));
    builder.encodeStruct(PageLoadMetrics_UpdateTiming_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  PageLoadMetricsPtr.prototype.setUpSharedMemoryForSmoothness = function() {
    return PageLoadMetricsProxy.prototype.setUpSharedMemoryForSmoothness
        .apply(this.ptr.getProxy(), arguments);
  };

  PageLoadMetricsProxy.prototype.setUpSharedMemoryForSmoothness = function(sharedMemory) {
    var params_ = new PageLoadMetrics_SetUpSharedMemoryForSmoothness_Params();
    params_.sharedMemory = sharedMemory;
    var builder = new codec.MessageV0Builder(
        kPageLoadMetrics_SetUpSharedMemoryForSmoothness_Name,
        codec.align(PageLoadMetrics_SetUpSharedMemoryForSmoothness_Params.encodedSize));
    builder.encodeStruct(PageLoadMetrics_SetUpSharedMemoryForSmoothness_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };

  function PageLoadMetricsStub(delegate) {
    this.delegate_ = delegate;
  }
  PageLoadMetricsStub.prototype.updateTiming = function(pageLoadTiming, frameMetadata, newFeatures, resources, renderData, cpuLoadTiming, inputTimingDelta, subresourceLoadMetrics, softNavigationMetrics) {
    return this.delegate_ && this.delegate_.updateTiming && this.delegate_.updateTiming(pageLoadTiming, frameMetadata, newFeatures, resources, renderData, cpuLoadTiming, inputTimingDelta, subresourceLoadMetrics, softNavigationMetrics);
  }
  PageLoadMetricsStub.prototype.setUpSharedMemoryForSmoothness = function(sharedMemory) {
    return this.delegate_ && this.delegate_.setUpSharedMemoryForSmoothness && this.delegate_.setUpSharedMemoryForSmoothness(sharedMemory);
  }

  PageLoadMetricsStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kPageLoadMetrics_UpdateTiming_Name:
      var params = reader.decodeStruct(PageLoadMetrics_UpdateTiming_Params);
      this.updateTiming(params.pageLoadTiming, params.frameMetadata, params.newFeatures, params.resources, params.renderData, params.cpuLoadTiming, params.inputTimingDelta, params.subresourceLoadMetrics, params.softNavigationMetrics);
      return true;
    case kPageLoadMetrics_SetUpSharedMemoryForSmoothness_Name:
      var params = reader.decodeStruct(PageLoadMetrics_SetUpSharedMemoryForSmoothness_Params);
      this.setUpSharedMemoryForSmoothness(params.sharedMemory);
      return true;
    default:
      return false;
    }
  };

  PageLoadMetricsStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  function validatePageLoadMetricsRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kPageLoadMetrics_UpdateTiming_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = PageLoadMetrics_UpdateTiming_Params;
      break;
      case kPageLoadMetrics_SetUpSharedMemoryForSmoothness_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = PageLoadMetrics_SetUpSharedMemoryForSmoothness_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validatePageLoadMetricsResponse(messageValidator) {
    return validator.validationError.NONE;
  }

  var PageLoadMetrics = {
    name: 'page_load_metrics.mojom.PageLoadMetrics',
    kVersion: 0,
    ptrClass: PageLoadMetricsPtr,
    proxyClass: PageLoadMetricsProxy,
    stubClass: PageLoadMetricsStub,
    validateRequest: validatePageLoadMetricsRequest,
    validateResponse: null,
  };
  PageLoadMetricsStub.prototype.validator = validatePageLoadMetricsRequest;
  PageLoadMetricsProxy.prototype.validator = null;
  exports.CacheType = CacheType;
  exports.UserInteractionType = UserInteractionType;
  exports.DocumentTiming = DocumentTiming;
  exports.LargestContentfulPaintTiming = LargestContentfulPaintTiming;
  exports.PaintTiming = PaintTiming;
  exports.ParseTiming = ParseTiming;
  exports.InteractiveTiming = InteractiveTiming;
  exports.PageLoadTiming = PageLoadTiming;
  exports.FrameMetadata = FrameMetadata;
  exports.SubresourceLoadMetrics = SubresourceLoadMetrics;
  exports.ServiceWorkerSubresourceLoadMetrics = ServiceWorkerSubresourceLoadMetrics;
  exports.ResourceDataUpdate = ResourceDataUpdate;
  exports.LayoutShift = LayoutShift;
  exports.FrameRenderDataUpdate = FrameRenderDataUpdate;
  exports.CpuTiming = CpuTiming;
  exports.InputTiming = InputTiming;
  exports.UserInteractionLatency = UserInteractionLatency;
  exports.BackForwardCacheTiming = BackForwardCacheTiming;
  exports.SoftNavigationMetrics = SoftNavigationMetrics;
  exports.UserInteractionLatencies = UserInteractionLatencies;
  exports.PageLoadMetrics = PageLoadMetrics;
  exports.PageLoadMetricsPtr = PageLoadMetricsPtr;
  exports.PageLoadMetricsAssociatedPtr = PageLoadMetricsAssociatedPtr;
})();