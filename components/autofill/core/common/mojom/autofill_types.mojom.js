// components/autofill/core/common/mojom/autofill_types.mojom.js is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2014 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

(function() {
  var mojomId = 'components/autofill/core/common/mojom/autofill_types.mojom';
  if (mojo.internal.isMojomLoaded(mojomId)) {
    console.warn('The following mojom is loaded multiple times: ' + mojomId);
    return;
  }
  mojo.internal.markMojomLoaded(mojomId);
  var bindings = mojo;
  var associatedBindings = mojo;
  var codec = mojo.internal;
  var validator = mojo.internal;

  var exports = mojo.internal.exposeNamespace('autofill.mojom');
  var text_direction$ =
      mojo.internal.exposeNamespace('mojoBase.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'mojo/public/mojom/base/text_direction.mojom', '../../../../../mojo/public/mojom/base/text_direction.mojom.js');
  }
  var time$ =
      mojo.internal.exposeNamespace('mojoBase.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'mojo/public/mojom/base/time.mojom', '../../../../../mojo/public/mojom/base/time.mojom.js');
  }
  var string16$ =
      mojo.internal.exposeNamespace('mojoBase.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'mojo/public/mojom/base/string16.mojom', '../../../../../mojo/public/mojom/base/string16.mojom.js');
  }
  var unguessable_token$ =
      mojo.internal.exposeNamespace('mojoBase.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'mojo/public/mojom/base/unguessable_token.mojom', '../../../../../mojo/public/mojom/base/unguessable_token.mojom.js');
  }
  var geometry$ =
      mojo.internal.exposeNamespace('gfx.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'ui/gfx/geometry/mojom/geometry.mojom', '../../../../../ui/gfx/geometry/mojom/geometry.mojom.js');
  }
  var url$ =
      mojo.internal.exposeNamespace('url.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'url/mojom/url.mojom', '../../../../../url/mojom/url.mojom.js');
  }


  var FormControlType = {};
  FormControlType.kContentEditable = 0;
  FormControlType.kInputCheckbox = 1;
  FormControlType.kInputEmail = 2;
  FormControlType.kInputMonth = 3;
  FormControlType.kInputNumber = 4;
  FormControlType.kInputPassword = 5;
  FormControlType.kInputRadio = 6;
  FormControlType.kInputSearch = 7;
  FormControlType.kInputTelephone = 8;
  FormControlType.kInputText = 9;
  FormControlType.kInputUrl = 10;
  FormControlType.kSelectOne = 11;
  FormControlType.kSelectMultiple = 12;
  FormControlType.kSelectList = 13;
  FormControlType.kTextArea = 14;
  FormControlType.MIN_VALUE = 0;
  FormControlType.MAX_VALUE = 14;

  FormControlType.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
      return true;
    }
    return false;
  };

  FormControlType.toKnownEnumValue = function(value) {
    return value;
  };

  FormControlType.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var HtmlFieldMode = {};
  HtmlFieldMode.kNone = 0;
  HtmlFieldMode.kBilling = 1;
  HtmlFieldMode.kShipping = 2;
  HtmlFieldMode.MIN_VALUE = 0;
  HtmlFieldMode.MAX_VALUE = 2;

  HtmlFieldMode.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    }
    return false;
  };

  HtmlFieldMode.toKnownEnumValue = function(value) {
    return value;
  };

  HtmlFieldMode.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var HtmlFieldType = {};
  HtmlFieldType.kUnspecified = 0;
  HtmlFieldType.kName = 1;
  HtmlFieldType.kHonorificPrefix = 2;
  HtmlFieldType.kGivenName = 3;
  HtmlFieldType.kAdditionalName = 4;
  HtmlFieldType.kFamilyName = 5;
  HtmlFieldType.kOrganization = 6;
  HtmlFieldType.kStreetAddress = 7;
  HtmlFieldType.kAddressLine1 = 8;
  HtmlFieldType.kAddressLine2 = 9;
  HtmlFieldType.kAddressLine3 = 10;
  HtmlFieldType.kAddressLevel1 = 11;
  HtmlFieldType.kAddressLevel2 = 12;
  HtmlFieldType.kAddressLevel3 = 13;
  HtmlFieldType.kCountryCode = 14;
  HtmlFieldType.kCountryName = 15;
  HtmlFieldType.kPostalCode = 16;
  HtmlFieldType.kCreditCardNameFull = 18;
  HtmlFieldType.kCreditCardNameFirst = 19;
  HtmlFieldType.kCreditCardNameLast = 20;
  HtmlFieldType.kCreditCardNumber = 21;
  HtmlFieldType.kCreditCardExp = 22;
  HtmlFieldType.kCreditCardExpMonth = 23;
  HtmlFieldType.kCreditCardExpYear = 24;
  HtmlFieldType.kCreditCardVerificationCode = 25;
  HtmlFieldType.kCreditCardType = 26;
  HtmlFieldType.kTel = 27;
  HtmlFieldType.kTelCountryCode = 28;
  HtmlFieldType.kTelNational = 29;
  HtmlFieldType.kTelAreaCode = 30;
  HtmlFieldType.kTelLocal = 31;
  HtmlFieldType.kTelLocalPrefix = 32;
  HtmlFieldType.kTelLocalSuffix = 33;
  HtmlFieldType.kTelExtension = 34;
  HtmlFieldType.kEmail = 35;
  HtmlFieldType.kBirthdateDay = 36;
  HtmlFieldType.kBirthdateMonth = 37;
  HtmlFieldType.kBirthdateYear = 38;
  HtmlFieldType.kTransactionAmount = 39;
  HtmlFieldType.kTransactionCurrency = 40;
  HtmlFieldType.kAdditionalNameInitial = 41;
  HtmlFieldType.kCreditCardExpDate2DigitYear = 42;
  HtmlFieldType.kCreditCardExpDate4DigitYear = 43;
  HtmlFieldType.kCreditCardExp2DigitYear = 44;
  HtmlFieldType.kCreditCardExp4DigitYear = 45;
  HtmlFieldType.kUpiVpa = 46;
  HtmlFieldType.kOneTimeCode = 47;
  HtmlFieldType.kMerchantPromoCode = 48;
  HtmlFieldType.kIban = 49;
  HtmlFieldType.kUnrecognized = 50;
  HtmlFieldType.MIN_VALUE = 0;
  HtmlFieldType.MAX_VALUE = 50;

  HtmlFieldType.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
      return true;
    }
    return false;
  };

  HtmlFieldType.toKnownEnumValue = function(value) {
    return value;
  };

  HtmlFieldType.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var SubmissionIndicatorEvent = {};
  SubmissionIndicatorEvent.NONE = 0;
  SubmissionIndicatorEvent.HTML_FORM_SUBMISSION = 1;
  SubmissionIndicatorEvent.SAME_DOCUMENT_NAVIGATION = 2;
  SubmissionIndicatorEvent.XHR_SUCCEEDED = 3;
  SubmissionIndicatorEvent.FRAME_DETACHED = 4;
  SubmissionIndicatorEvent.DOM_MUTATION_AFTER_XHR = 6;
  SubmissionIndicatorEvent.PROVISIONALLY_SAVED_FORM_ON_START_PROVISIONAL_LOAD = 7;
  SubmissionIndicatorEvent.PROBABLE_FORM_SUBMISSION = 10;
  SubmissionIndicatorEvent.CHANGE_PASSWORD_FORM_CLEARED = 11;
  SubmissionIndicatorEvent.MIN_VALUE = 0;
  SubmissionIndicatorEvent.MAX_VALUE = 11;

  SubmissionIndicatorEvent.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 6:
    case 7:
    case 10:
    case 11:
      return true;
    }
    return false;
  };

  SubmissionIndicatorEvent.toKnownEnumValue = function(value) {
    return value;
  };

  SubmissionIndicatorEvent.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var SubmissionSource = {};
  SubmissionSource.NONE = 0;
  SubmissionSource.SAME_DOCUMENT_NAVIGATION = 1;
  SubmissionSource.XHR_SUCCEEDED = 2;
  SubmissionSource.FRAME_DETACHED = 3;
  SubmissionSource.DOM_MUTATION_AFTER_XHR = 4;
  SubmissionSource.PROBABLY_FORM_SUBMITTED = 5;
  SubmissionSource.FORM_SUBMISSION = 6;
  SubmissionSource.MIN_VALUE = 0;
  SubmissionSource.MAX_VALUE = 6;

  SubmissionSource.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    }
    return false;
  };

  SubmissionSource.toKnownEnumValue = function(value) {
    return value;
  };

  SubmissionSource.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var FocusedFieldType = {};
  FocusedFieldType.kUnknown = 0;
  FocusedFieldType.kUnfillableElement = 1;
  FocusedFieldType.kFillableTextArea = 2;
  FocusedFieldType.kFillableSearchField = 3;
  FocusedFieldType.kFillableNonSearchField = 4;
  FocusedFieldType.kFillableWebauthnTaggedField = 5;
  FocusedFieldType.kFillableUsernameField = 6;
  FocusedFieldType.kFillablePasswordField = 7;
  FocusedFieldType.MIN_VALUE = 0;
  FocusedFieldType.MAX_VALUE = 7;

  FocusedFieldType.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    }
    return false;
  };

  FocusedFieldType.toKnownEnumValue = function(value) {
    return value;
  };

  FocusedFieldType.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var ButtonTitleType = {};
  ButtonTitleType.NONE = 0;
  ButtonTitleType.BUTTON_ELEMENT_SUBMIT_TYPE = 1;
  ButtonTitleType.BUTTON_ELEMENT_BUTTON_TYPE = 2;
  ButtonTitleType.INPUT_ELEMENT_SUBMIT_TYPE = 3;
  ButtonTitleType.INPUT_ELEMENT_BUTTON_TYPE = 4;
  ButtonTitleType.HYPERLINK = 5;
  ButtonTitleType.DIV = 6;
  ButtonTitleType.SPAN = 7;
  ButtonTitleType.MIN_VALUE = 0;
  ButtonTitleType.MAX_VALUE = 7;

  ButtonTitleType.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    }
    return false;
  };

  ButtonTitleType.toKnownEnumValue = function(value) {
    return value;
  };

  ButtonTitleType.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var SubmissionReadinessState = {};
  SubmissionReadinessState.kNoInformation = 0;
  SubmissionReadinessState.kError = 1;
  SubmissionReadinessState.kNoUsernameField = 2;
  SubmissionReadinessState.kFieldBetweenUsernameAndPassword = 3;
  SubmissionReadinessState.kFieldAfterPasswordField = 4;
  SubmissionReadinessState.kEmptyFields = 5;
  SubmissionReadinessState.kMoreThanTwoFields = 6;
  SubmissionReadinessState.kTwoFields = 7;
  SubmissionReadinessState.kNoPasswordField = 8;
  SubmissionReadinessState.MIN_VALUE = 0;
  SubmissionReadinessState.MAX_VALUE = 8;

  SubmissionReadinessState.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    }
    return false;
  };

  SubmissionReadinessState.toKnownEnumValue = function(value) {
    return value;
  };

  SubmissionReadinessState.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var AutofillState = {};
  AutofillState.kNoSuggestions = 0;
  AutofillState.kAutofillAvailable = 1;
  AutofillState.kAutocompleteAvailable = 2;
  AutofillState.MIN_VALUE = 0;
  AutofillState.MAX_VALUE = 2;

  AutofillState.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    }
    return false;
  };

  AutofillState.toKnownEnumValue = function(value) {
    return value;
  };

  AutofillState.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var AutofillActionPersistence = {};
  AutofillActionPersistence.kFill = 0;
  AutofillActionPersistence.kPreview = 1;
  AutofillActionPersistence.MIN_VALUE = 0;
  AutofillActionPersistence.MAX_VALUE = 1;

  AutofillActionPersistence.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
      return true;
    }
    return false;
  };

  AutofillActionPersistence.toKnownEnumValue = function(value) {
    return value;
  };

  AutofillActionPersistence.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var AutofillActionType = {};
  AutofillActionType.kFill = 0;
  AutofillActionType.kUndo = 1;
  AutofillActionType.MIN_VALUE = 0;
  AutofillActionType.MAX_VALUE = 1;

  AutofillActionType.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
      return true;
    }
    return false;
  };

  AutofillActionType.toKnownEnumValue = function(value) {
    return value;
  };

  AutofillActionType.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var AutofillSuggestionTriggerSource = {};
  AutofillSuggestionTriggerSource.kUnspecified = 0;
  AutofillSuggestionTriggerSource.kFormControlElementClicked = 1;
  AutofillSuggestionTriggerSource.kContentEditableClicked = 2;
  AutofillSuggestionTriggerSource.kTextFieldDidChange = 3;
  AutofillSuggestionTriggerSource.kTextFieldDidReceiveKeyDown = 4;
  AutofillSuggestionTriggerSource.kOpenTextDataListChooser = 5;
  AutofillSuggestionTriggerSource.kShowCardsFromAccount = 6;
  AutofillSuggestionTriggerSource.kPasswordManager = 7;
  AutofillSuggestionTriggerSource.kAndroidWebView = 8;
  AutofillSuggestionTriggerSource.kiOS = 9;
  AutofillSuggestionTriggerSource.kManualFallbackForAutocompleteUnrecognized = 10;
  AutofillSuggestionTriggerSource.kShowPromptAfterDialogClosed = 11;
  AutofillSuggestionTriggerSource.MIN_VALUE = 0;
  AutofillSuggestionTriggerSource.MAX_VALUE = 11;

  AutofillSuggestionTriggerSource.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return true;
    }
    return false;
  };

  AutofillSuggestionTriggerSource.toKnownEnumValue = function(value) {
    return value;
  };

  AutofillSuggestionTriggerSource.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };

  function FrameToken(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  FrameToken.prototype.initDefaults_ = function() {
    this.token = null;
    this.isLocal = false;
  };
  FrameToken.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  FrameToken.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FrameToken.token
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, unguessable_token$.UnguessableToken, false);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  FrameToken.encodedSize = codec.kStructHeaderSize + 16;

  FrameToken.decode = function(decoder) {
    var packed;
    var val = new FrameToken();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.token =
        decoder.decodeStructPointer(unguessable_token$.UnguessableToken);
    packed = decoder.readUint8();
    val.isLocal = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  FrameToken.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(FrameToken.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(unguessable_token$.UnguessableToken, val.token);
    packed = 0;
    packed |= (val.isLocal & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function FrameTokenWithPredecessor(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  FrameTokenWithPredecessor.prototype.initDefaults_ = function() {
    this.token = null;
    this.predecessor = 0;
  };
  FrameTokenWithPredecessor.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  FrameTokenWithPredecessor.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FrameTokenWithPredecessor.token
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, FrameToken, false);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  FrameTokenWithPredecessor.encodedSize = codec.kStructHeaderSize + 16;

  FrameTokenWithPredecessor.decode = function(decoder) {
    var packed;
    var val = new FrameTokenWithPredecessor();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.token =
        decoder.decodeStructPointer(FrameToken);
    val.predecessor =
        decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  FrameTokenWithPredecessor.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(FrameTokenWithPredecessor.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(FrameToken, val.token);
    encoder.encodeStruct(codec.Int32, val.predecessor);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function FormRendererId(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  FormRendererId.prototype.initDefaults_ = function() {
    this.id = 0;
  };
  FormRendererId.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  FormRendererId.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  FormRendererId.encodedSize = codec.kStructHeaderSize + 8;

  FormRendererId.decode = function(decoder) {
    var packed;
    var val = new FormRendererId();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.id =
        decoder.decodeStruct(codec.Uint64);
    return val;
  };

  FormRendererId.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(FormRendererId.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint64, val.id);
  };
  function FieldRendererId(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  FieldRendererId.prototype.initDefaults_ = function() {
    this.id = 0;
  };
  FieldRendererId.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  FieldRendererId.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  FieldRendererId.encodedSize = codec.kStructHeaderSize + 8;

  FieldRendererId.decode = function(decoder) {
    var packed;
    var val = new FieldRendererId();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.id =
        decoder.decodeStruct(codec.Uint64);
    return val;
  };

  FieldRendererId.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(FieldRendererId.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint64, val.id);
  };
  function SelectOption(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SelectOption.prototype.initDefaults_ = function() {
    this.value = null;
    this.content = null;
  };
  SelectOption.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SelectOption.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate SelectOption.value
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate SelectOption.content
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  SelectOption.encodedSize = codec.kStructHeaderSize + 16;

  SelectOption.decode = function(decoder) {
    var packed;
    var val = new SelectOption();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.value =
        decoder.decodeStructPointer(string16$.String16);
    val.content =
        decoder.decodeStructPointer(string16$.String16);
    return val;
  };

  SelectOption.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SelectOption.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(string16$.String16, val.value);
    encoder.encodeStructPointer(string16$.String16, val.content);
  };
  function SectionAutocomplete(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SectionAutocomplete.prototype.initDefaults_ = function() {
    this.section = null;
    this.htmlFieldMode = 0;
  };
  SectionAutocomplete.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SectionAutocomplete.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate SectionAutocomplete.section
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 0, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate SectionAutocomplete.htmlFieldMode
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 8, HtmlFieldMode);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  SectionAutocomplete.encodedSize = codec.kStructHeaderSize + 16;

  SectionAutocomplete.decode = function(decoder) {
    var packed;
    var val = new SectionAutocomplete();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.section =
        decoder.decodeStruct(codec.String);
    val.htmlFieldMode =
        decoder.decodeStruct(new codec.Enum(HtmlFieldMode));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  SectionAutocomplete.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SectionAutocomplete.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.String, val.section);
    encoder.encodeStruct(codec.Int32, val.htmlFieldMode);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function SectionFieldIdentifier(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SectionFieldIdentifier.prototype.initDefaults_ = function() {
    this.fieldName = null;
    this.localFrameId = 0;
    this.fieldRendererId = null;
  };
  SectionFieldIdentifier.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SectionFieldIdentifier.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 32}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate SectionFieldIdentifier.fieldName
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 0, false)
    if (err !== validator.validationError.NONE)
        return err;



    // validate SectionFieldIdentifier.fieldRendererId
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, FieldRendererId, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  SectionFieldIdentifier.encodedSize = codec.kStructHeaderSize + 24;

  SectionFieldIdentifier.decode = function(decoder) {
    var packed;
    var val = new SectionFieldIdentifier();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.fieldName =
        decoder.decodeStruct(codec.String);
    val.localFrameId =
        decoder.decodeStruct(codec.Uint64);
    val.fieldRendererId =
        decoder.decodeStructPointer(FieldRendererId);
    return val;
  };

  SectionFieldIdentifier.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SectionFieldIdentifier.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.String, val.fieldName);
    encoder.encodeStruct(codec.Uint64, val.localFrameId);
    encoder.encodeStructPointer(FieldRendererId, val.fieldRendererId);
  };
  function Section(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Section.prototype.initDefaults_ = function() {
    this.value = null;
  };
  Section.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Section.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Section.value
    err = messageValidator.validateUnion(offset + codec.kStructHeaderSize + 0, SectionValue, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Section.encodedSize = codec.kStructHeaderSize + 16;

  Section.decode = function(decoder) {
    var packed;
    var val = new Section();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.value =
        decoder.decodeStruct(SectionValue);
    return val;
  };

  Section.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Section.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(SectionValue, val.value);
  };
  function AutocompleteParsingResult(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  AutocompleteParsingResult.prototype.initDefaults_ = function() {
    this.section = null;
    this.mode = 0;
    this.fieldType = 0;
  };
  AutocompleteParsingResult.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  AutocompleteParsingResult.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate AutocompleteParsingResult.section
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 0, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate AutocompleteParsingResult.mode
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 8, HtmlFieldMode);
    if (err !== validator.validationError.NONE)
        return err;


    // validate AutocompleteParsingResult.fieldType
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 12, HtmlFieldType);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  AutocompleteParsingResult.encodedSize = codec.kStructHeaderSize + 16;

  AutocompleteParsingResult.decode = function(decoder) {
    var packed;
    var val = new AutocompleteParsingResult();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.section =
        decoder.decodeStruct(codec.String);
    val.mode =
        decoder.decodeStruct(new codec.Enum(HtmlFieldMode));
    val.fieldType =
        decoder.decodeStruct(new codec.Enum(HtmlFieldType));
    return val;
  };

  AutocompleteParsingResult.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(AutocompleteParsingResult.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.String, val.section);
    encoder.encodeStruct(codec.Int32, val.mode);
    encoder.encodeStruct(codec.Int32, val.fieldType);
  };
  function FormFieldData(values) {
    this.initDefaults_();
    this.initFields_(values);
  }

  FormFieldData.CheckStatus = {};
  FormFieldData.CheckStatus.kNotCheckable = 0;
  FormFieldData.CheckStatus.kCheckableButUnchecked = 1;
  FormFieldData.CheckStatus.kChecked = 2;
  FormFieldData.CheckStatus.MIN_VALUE = 0;
  FormFieldData.CheckStatus.MAX_VALUE = 2;

  FormFieldData.CheckStatus.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    }
    return false;
  };

  FormFieldData.CheckStatus.toKnownEnumValue = function(value) {
    return value;
  };

  FormFieldData.CheckStatus.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  FormFieldData.RoleAttribute = {};
  FormFieldData.RoleAttribute.kPresentation = 0;
  FormFieldData.RoleAttribute.kOther = 1;
  FormFieldData.RoleAttribute.MIN_VALUE = 0;
  FormFieldData.RoleAttribute.MAX_VALUE = 1;

  FormFieldData.RoleAttribute.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
      return true;
    }
    return false;
  };

  FormFieldData.RoleAttribute.toKnownEnumValue = function(value) {
    return value;
  };

  FormFieldData.RoleAttribute.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  FormFieldData.LabelSource = {};
  FormFieldData.LabelSource.kUnknown = 0;
  FormFieldData.LabelSource.kLabelTag = 1;
  FormFieldData.LabelSource.kPTag = 2;
  FormFieldData.LabelSource.kDivTable = 3;
  FormFieldData.LabelSource.kTdTag = 4;
  FormFieldData.LabelSource.kDdTag = 5;
  FormFieldData.LabelSource.kLiTag = 6;
  FormFieldData.LabelSource.kPlaceHolder = 7;
  FormFieldData.LabelSource.kAriaLabel = 8;
  FormFieldData.LabelSource.kCombined = 9;
  FormFieldData.LabelSource.kValue = 10;
  FormFieldData.LabelSource.kForId = 11;
  FormFieldData.LabelSource.kForName = 12;
  FormFieldData.LabelSource.kForShadowHostId = 13;
  FormFieldData.LabelSource.kForShadowHostName = 14;
  FormFieldData.LabelSource.kOverlayingLabel = 15;
  FormFieldData.LabelSource.MIN_VALUE = 0;
  FormFieldData.LabelSource.MAX_VALUE = 15;

  FormFieldData.LabelSource.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
      return true;
    }
    return false;
  };

  FormFieldData.LabelSource.toKnownEnumValue = function(value) {
    return value;
  };

  FormFieldData.LabelSource.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };

  FormFieldData.prototype.initDefaults_ = function() {
    this.label = null;
    this.name = null;
    this.idAttribute = null;
    this.nameAttribute = null;
    this.value = null;
    this.selectionStart = 0;
    this.selectionEnd = 0;
    this.formControlType = 0;
    this.propertiesMask = 0;
    this.autocompleteAttribute = null;
    this.parsedAutocomplete = null;
    this.placeholder = null;
    this.cssClasses = null;
    this.ariaLabel = null;
    this.ariaDescription = null;
    this.uniqueRendererId = null;
    this.hostFormId = null;
    this.formControlAxId = 0;
    this.isAutofilled = false;
    this.isFocusable = false;
    this.isVisible = false;
    this.shouldAutocomplete = false;
    this.isEnabled = false;
    this.isReadonly = false;
    this.forceOverride = false;
    this.maxLength = 0;
    this.section = null;
    this.checkStatus = 0;
    this.role = 0;
    this.textDirection = 0;
    this.labelSource = 0;
    this.userInput = null;
    this.options = null;
    this.bounds = null;
    this.datalistValues = null;
    this.datalistLabels = null;
  };
  FormFieldData.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  FormFieldData.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 208}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldData.label
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldData.name
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldData.idAttribute
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldData.nameAttribute
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 24, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldData.value
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 32, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;




    // validate FormFieldData.formControlType
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 48, FormControlType);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldData.autocompleteAttribute
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 56, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldData.parsedAutocomplete
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 64, AutocompleteParsingResult, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldData.placeholder
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 72, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldData.cssClasses
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 80, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldData.ariaLabel
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 88, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldData.ariaDescription
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 96, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldData.uniqueRendererId
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 104, FieldRendererId, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldData.hostFormId
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 112, FormRendererId, false);
    if (err !== validator.validationError.NONE)
        return err;






    // validate FormFieldData.section
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 136, Section, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldData.checkStatus
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 144, FormFieldData.CheckStatus);
    if (err !== validator.validationError.NONE)
        return err;





    // validate FormFieldData.role
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 148, FormFieldData.RoleAttribute);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldData.textDirection
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 152, text_direction$.TextDirection);
    if (err !== validator.validationError.NONE)
        return err;




    // validate FormFieldData.userInput
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 160, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldData.options
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 168, 8, new codec.PointerTo(SelectOption), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldData.labelSource
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 156, FormFieldData.LabelSource);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldData.bounds
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 176, geometry$.RectF, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldData.datalistValues
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 184, 8, new codec.PointerTo(string16$.String16), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldData.datalistLabels
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 192, 8, new codec.PointerTo(string16$.String16), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  FormFieldData.encodedSize = codec.kStructHeaderSize + 200;

  FormFieldData.decode = function(decoder) {
    var packed;
    var val = new FormFieldData();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.label =
        decoder.decodeStructPointer(string16$.String16);
    val.name =
        decoder.decodeStructPointer(string16$.String16);
    val.idAttribute =
        decoder.decodeStructPointer(string16$.String16);
    val.nameAttribute =
        decoder.decodeStructPointer(string16$.String16);
    val.value =
        decoder.decodeStructPointer(string16$.String16);
    val.selectionStart =
        decoder.decodeStruct(codec.Uint32);
    val.selectionEnd =
        decoder.decodeStruct(codec.Uint32);
    val.formControlType =
        decoder.decodeStruct(new codec.Enum(FormControlType));
    val.propertiesMask =
        decoder.decodeStruct(codec.Uint32);
    val.autocompleteAttribute =
        decoder.decodeStruct(codec.String);
    val.parsedAutocomplete =
        decoder.decodeStructPointer(AutocompleteParsingResult);
    val.placeholder =
        decoder.decodeStructPointer(string16$.String16);
    val.cssClasses =
        decoder.decodeStructPointer(string16$.String16);
    val.ariaLabel =
        decoder.decodeStructPointer(string16$.String16);
    val.ariaDescription =
        decoder.decodeStructPointer(string16$.String16);
    val.uniqueRendererId =
        decoder.decodeStructPointer(FieldRendererId);
    val.hostFormId =
        decoder.decodeStructPointer(FormRendererId);
    val.formControlAxId =
        decoder.decodeStruct(codec.Int32);
    packed = decoder.readUint8();
    val.isAutofilled = (packed >> 0) & 1 ? true : false;
    val.isFocusable = (packed >> 1) & 1 ? true : false;
    val.isVisible = (packed >> 2) & 1 ? true : false;
    val.shouldAutocomplete = (packed >> 3) & 1 ? true : false;
    val.isEnabled = (packed >> 4) & 1 ? true : false;
    val.isReadonly = (packed >> 5) & 1 ? true : false;
    val.forceOverride = (packed >> 6) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.maxLength =
        decoder.decodeStruct(codec.Uint64);
    val.section =
        decoder.decodeStructPointer(Section);
    val.checkStatus =
        decoder.decodeStruct(new codec.Enum(FormFieldData.CheckStatus));
    val.role =
        decoder.decodeStruct(new codec.Enum(FormFieldData.RoleAttribute));
    val.textDirection =
        decoder.decodeStruct(new codec.Enum(text_direction$.TextDirection));
    val.labelSource =
        decoder.decodeStruct(new codec.Enum(FormFieldData.LabelSource));
    val.userInput =
        decoder.decodeStructPointer(string16$.String16);
    val.options =
        decoder.decodeArrayPointer(new codec.PointerTo(SelectOption));
    val.bounds =
        decoder.decodeStructPointer(geometry$.RectF);
    val.datalistValues =
        decoder.decodeArrayPointer(new codec.PointerTo(string16$.String16));
    val.datalistLabels =
        decoder.decodeArrayPointer(new codec.PointerTo(string16$.String16));
    return val;
  };

  FormFieldData.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(FormFieldData.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(string16$.String16, val.label);
    encoder.encodeStructPointer(string16$.String16, val.name);
    encoder.encodeStructPointer(string16$.String16, val.idAttribute);
    encoder.encodeStructPointer(string16$.String16, val.nameAttribute);
    encoder.encodeStructPointer(string16$.String16, val.value);
    encoder.encodeStruct(codec.Uint32, val.selectionStart);
    encoder.encodeStruct(codec.Uint32, val.selectionEnd);
    encoder.encodeStruct(codec.Int32, val.formControlType);
    encoder.encodeStruct(codec.Uint32, val.propertiesMask);
    encoder.encodeStruct(codec.String, val.autocompleteAttribute);
    encoder.encodeStructPointer(AutocompleteParsingResult, val.parsedAutocomplete);
    encoder.encodeStructPointer(string16$.String16, val.placeholder);
    encoder.encodeStructPointer(string16$.String16, val.cssClasses);
    encoder.encodeStructPointer(string16$.String16, val.ariaLabel);
    encoder.encodeStructPointer(string16$.String16, val.ariaDescription);
    encoder.encodeStructPointer(FieldRendererId, val.uniqueRendererId);
    encoder.encodeStructPointer(FormRendererId, val.hostFormId);
    encoder.encodeStruct(codec.Int32, val.formControlAxId);
    packed = 0;
    packed |= (val.isAutofilled & 1) << 0
    packed |= (val.isFocusable & 1) << 1
    packed |= (val.isVisible & 1) << 2
    packed |= (val.shouldAutocomplete & 1) << 3
    packed |= (val.isEnabled & 1) << 4
    packed |= (val.isReadonly & 1) << 5
    packed |= (val.forceOverride & 1) << 6
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.Uint64, val.maxLength);
    encoder.encodeStructPointer(Section, val.section);
    encoder.encodeStruct(codec.Int32, val.checkStatus);
    encoder.encodeStruct(codec.Int32, val.role);
    encoder.encodeStruct(codec.Int32, val.textDirection);
    encoder.encodeStruct(codec.Int32, val.labelSource);
    encoder.encodeStructPointer(string16$.String16, val.userInput);
    encoder.encodeArrayPointer(new codec.PointerTo(SelectOption), val.options);
    encoder.encodeStructPointer(geometry$.RectF, val.bounds);
    encoder.encodeArrayPointer(new codec.PointerTo(string16$.String16), val.datalistValues);
    encoder.encodeArrayPointer(new codec.PointerTo(string16$.String16), val.datalistLabels);
  };
  function ButtonTitleInfo(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ButtonTitleInfo.prototype.initDefaults_ = function() {
    this.title = null;
    this.type = 0;
  };
  ButtonTitleInfo.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ButtonTitleInfo.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ButtonTitleInfo.title
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ButtonTitleInfo.type
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 8, ButtonTitleType);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ButtonTitleInfo.encodedSize = codec.kStructHeaderSize + 16;

  ButtonTitleInfo.decode = function(decoder) {
    var packed;
    var val = new ButtonTitleInfo();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.title =
        decoder.decodeStructPointer(string16$.String16);
    val.type =
        decoder.decodeStruct(new codec.Enum(ButtonTitleType));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  ButtonTitleInfo.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ButtonTitleInfo.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(string16$.String16, val.title);
    encoder.encodeStruct(codec.Int32, val.type);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function FormData(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  FormData.prototype.initDefaults_ = function() {
    this.idAttribute = null;
    this.nameAttribute = null;
    this.name = null;
    this.buttonTitles = null;
    this.action = null;
    this.isActionEmpty = false;
    this.isFormTag = false;
    this.isGaiaWithSkipSavePasswordForm = false;
    this.submissionEvent = 0;
    this.uniqueRendererId = null;
    this.childFrames = null;
    this.fields = null;
    this.usernamePredictions = null;
  };
  FormData.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  FormData.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 88}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormData.idAttribute
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormData.nameAttribute
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormData.name
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormData.buttonTitles
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 24, 8, new codec.PointerTo(ButtonTitleInfo), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormData.action
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 32, url$.Url, false);
    if (err !== validator.validationError.NONE)
        return err;




    // validate FormData.uniqueRendererId
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 48, FormRendererId, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormData.childFrames
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 56, 8, new codec.PointerTo(FrameTokenWithPredecessor), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormData.submissionEvent
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 44, SubmissionIndicatorEvent);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormData.fields
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 64, 8, new codec.PointerTo(FormFieldData), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormData.usernamePredictions
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 72, 8, new codec.PointerTo(FieldRendererId), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  FormData.encodedSize = codec.kStructHeaderSize + 80;

  FormData.decode = function(decoder) {
    var packed;
    var val = new FormData();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.idAttribute =
        decoder.decodeStructPointer(string16$.String16);
    val.nameAttribute =
        decoder.decodeStructPointer(string16$.String16);
    val.name =
        decoder.decodeStructPointer(string16$.String16);
    val.buttonTitles =
        decoder.decodeArrayPointer(new codec.PointerTo(ButtonTitleInfo));
    val.action =
        decoder.decodeStructPointer(url$.Url);
    packed = decoder.readUint8();
    val.isActionEmpty = (packed >> 0) & 1 ? true : false;
    val.isFormTag = (packed >> 1) & 1 ? true : false;
    val.isGaiaWithSkipSavePasswordForm = (packed >> 2) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.submissionEvent =
        decoder.decodeStruct(new codec.Enum(SubmissionIndicatorEvent));
    val.uniqueRendererId =
        decoder.decodeStructPointer(FormRendererId);
    val.childFrames =
        decoder.decodeArrayPointer(new codec.PointerTo(FrameTokenWithPredecessor));
    val.fields =
        decoder.decodeArrayPointer(new codec.PointerTo(FormFieldData));
    val.usernamePredictions =
        decoder.decodeArrayPointer(new codec.PointerTo(FieldRendererId));
    return val;
  };

  FormData.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(FormData.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(string16$.String16, val.idAttribute);
    encoder.encodeStructPointer(string16$.String16, val.nameAttribute);
    encoder.encodeStructPointer(string16$.String16, val.name);
    encoder.encodeArrayPointer(new codec.PointerTo(ButtonTitleInfo), val.buttonTitles);
    encoder.encodeStructPointer(url$.Url, val.action);
    packed = 0;
    packed |= (val.isActionEmpty & 1) << 0
    packed |= (val.isFormTag & 1) << 1
    packed |= (val.isGaiaWithSkipSavePasswordForm & 1) << 2
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.Int32, val.submissionEvent);
    encoder.encodeStructPointer(FormRendererId, val.uniqueRendererId);
    encoder.encodeArrayPointer(new codec.PointerTo(FrameTokenWithPredecessor), val.childFrames);
    encoder.encodeArrayPointer(new codec.PointerTo(FormFieldData), val.fields);
    encoder.encodeArrayPointer(new codec.PointerTo(FieldRendererId), val.usernamePredictions);
  };
  function FormFieldDataPredictions(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  FormFieldDataPredictions.prototype.initDefaults_ = function() {
    this.hostFormSignature = null;
    this.signature = null;
    this.heuristicType = null;
    this.serverType = null;
    this.overallType = null;
    this.parseableName = null;
    this.section = null;
    this.rank = 0;
    this.rankInSignatureGroup = 0;
    this.rankInHostForm = 0;
    this.rankInHostFormSignatureGroup = 0;
  };
  FormFieldDataPredictions.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  FormFieldDataPredictions.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 80}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldDataPredictions.hostFormSignature
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 0, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldDataPredictions.signature
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 8, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldDataPredictions.heuristicType
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 16, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldDataPredictions.serverType
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 24, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldDataPredictions.overallType
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 32, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldDataPredictions.parseableName
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 40, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormFieldDataPredictions.section
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 48, false)
    if (err !== validator.validationError.NONE)
        return err;





    return validator.validationError.NONE;
  };

  FormFieldDataPredictions.encodedSize = codec.kStructHeaderSize + 72;

  FormFieldDataPredictions.decode = function(decoder) {
    var packed;
    var val = new FormFieldDataPredictions();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.hostFormSignature =
        decoder.decodeStruct(codec.String);
    val.signature =
        decoder.decodeStruct(codec.String);
    val.heuristicType =
        decoder.decodeStruct(codec.String);
    val.serverType =
        decoder.decodeStruct(codec.String);
    val.overallType =
        decoder.decodeStruct(codec.String);
    val.parseableName =
        decoder.decodeStruct(codec.String);
    val.section =
        decoder.decodeStruct(codec.String);
    val.rank =
        decoder.decodeStruct(codec.Uint32);
    val.rankInSignatureGroup =
        decoder.decodeStruct(codec.Uint32);
    val.rankInHostForm =
        decoder.decodeStruct(codec.Uint32);
    val.rankInHostFormSignatureGroup =
        decoder.decodeStruct(codec.Uint32);
    return val;
  };

  FormFieldDataPredictions.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(FormFieldDataPredictions.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.String, val.hostFormSignature);
    encoder.encodeStruct(codec.String, val.signature);
    encoder.encodeStruct(codec.String, val.heuristicType);
    encoder.encodeStruct(codec.String, val.serverType);
    encoder.encodeStruct(codec.String, val.overallType);
    encoder.encodeStruct(codec.String, val.parseableName);
    encoder.encodeStruct(codec.String, val.section);
    encoder.encodeStruct(codec.Uint32, val.rank);
    encoder.encodeStruct(codec.Uint32, val.rankInSignatureGroup);
    encoder.encodeStruct(codec.Uint32, val.rankInHostForm);
    encoder.encodeStruct(codec.Uint32, val.rankInHostFormSignatureGroup);
  };
  function FormDataPredictions(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  FormDataPredictions.prototype.initDefaults_ = function() {
    this.data = null;
    this.signature = null;
    this.fields = null;
  };
  FormDataPredictions.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  FormDataPredictions.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 32}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormDataPredictions.data
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, FormData, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormDataPredictions.signature
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 8, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate FormDataPredictions.fields
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 16, 8, new codec.PointerTo(FormFieldDataPredictions), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  FormDataPredictions.encodedSize = codec.kStructHeaderSize + 24;

  FormDataPredictions.decode = function(decoder) {
    var packed;
    var val = new FormDataPredictions();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.data =
        decoder.decodeStructPointer(FormData);
    val.signature =
        decoder.decodeStruct(codec.String);
    val.fields =
        decoder.decodeArrayPointer(new codec.PointerTo(FormFieldDataPredictions));
    return val;
  };

  FormDataPredictions.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(FormDataPredictions.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(FormData, val.data);
    encoder.encodeStruct(codec.String, val.signature);
    encoder.encodeArrayPointer(new codec.PointerTo(FormFieldDataPredictions), val.fields);
  };
  function PasswordAndMetadata(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  PasswordAndMetadata.prototype.initDefaults_ = function() {
    this.usernameValue = null;
    this.passwordValue = null;
    this.realm = null;
    this.usesAccountStore = false;
  };
  PasswordAndMetadata.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  PasswordAndMetadata.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 40}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PasswordAndMetadata.usernameValue
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PasswordAndMetadata.passwordValue
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PasswordAndMetadata.realm
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 16, false)
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  PasswordAndMetadata.encodedSize = codec.kStructHeaderSize + 32;

  PasswordAndMetadata.decode = function(decoder) {
    var packed;
    var val = new PasswordAndMetadata();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.usernameValue =
        decoder.decodeStructPointer(string16$.String16);
    val.passwordValue =
        decoder.decodeStructPointer(string16$.String16);
    val.realm =
        decoder.decodeStruct(codec.String);
    packed = decoder.readUint8();
    val.usesAccountStore = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  PasswordAndMetadata.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(PasswordAndMetadata.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(string16$.String16, val.usernameValue);
    encoder.encodeStructPointer(string16$.String16, val.passwordValue);
    encoder.encodeStruct(codec.String, val.realm);
    packed = 0;
    packed |= (val.usesAccountStore & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function PasswordFormFillData(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  PasswordFormFillData.prototype.initDefaults_ = function() {
    this.formRendererId = null;
    this.url = null;
    this.usernameElementRendererId = null;
    this.passwordElementRendererId = null;
    this.usernameMayUsePrefilledPlaceholder = false;
    this.waitForUsername = false;
    this.preferredLogin = null;
    this.additionalLogins = null;
  };
  PasswordFormFillData.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  PasswordFormFillData.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 64}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PasswordFormFillData.formRendererId
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, FormRendererId, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PasswordFormFillData.url
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, url$.Url, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PasswordFormFillData.usernameElementRendererId
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, FieldRendererId, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PasswordFormFillData.passwordElementRendererId
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 24, FieldRendererId, false);
    if (err !== validator.validationError.NONE)
        return err;



    // validate PasswordFormFillData.preferredLogin
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 40, PasswordAndMetadata, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PasswordFormFillData.additionalLogins
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 48, 8, new codec.PointerTo(PasswordAndMetadata), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  PasswordFormFillData.encodedSize = codec.kStructHeaderSize + 56;

  PasswordFormFillData.decode = function(decoder) {
    var packed;
    var val = new PasswordFormFillData();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.formRendererId =
        decoder.decodeStructPointer(FormRendererId);
    val.url =
        decoder.decodeStructPointer(url$.Url);
    val.usernameElementRendererId =
        decoder.decodeStructPointer(FieldRendererId);
    val.passwordElementRendererId =
        decoder.decodeStructPointer(FieldRendererId);
    packed = decoder.readUint8();
    val.usernameMayUsePrefilledPlaceholder = (packed >> 0) & 1 ? true : false;
    val.waitForUsername = (packed >> 1) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.preferredLogin =
        decoder.decodeStructPointer(PasswordAndMetadata);
    val.additionalLogins =
        decoder.decodeArrayPointer(new codec.PointerTo(PasswordAndMetadata));
    return val;
  };

  PasswordFormFillData.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(PasswordFormFillData.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(FormRendererId, val.formRendererId);
    encoder.encodeStructPointer(url$.Url, val.url);
    encoder.encodeStructPointer(FieldRendererId, val.usernameElementRendererId);
    encoder.encodeStructPointer(FieldRendererId, val.passwordElementRendererId);
    packed = 0;
    packed |= (val.usernameMayUsePrefilledPlaceholder & 1) << 0
    packed |= (val.waitForUsername & 1) << 1
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStructPointer(PasswordAndMetadata, val.preferredLogin);
    encoder.encodeArrayPointer(new codec.PointerTo(PasswordAndMetadata), val.additionalLogins);
  };
  function PasswordFormGenerationData(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  PasswordFormGenerationData.prototype.initDefaults_ = function() {
    this.newPasswordRendererId = null;
    this.confirmationPasswordRendererId = null;
  };
  PasswordFormGenerationData.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  PasswordFormGenerationData.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PasswordFormGenerationData.newPasswordRendererId
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, FieldRendererId, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PasswordFormGenerationData.confirmationPasswordRendererId
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, FieldRendererId, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  PasswordFormGenerationData.encodedSize = codec.kStructHeaderSize + 16;

  PasswordFormGenerationData.decode = function(decoder) {
    var packed;
    var val = new PasswordFormGenerationData();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.newPasswordRendererId =
        decoder.decodeStructPointer(FieldRendererId);
    val.confirmationPasswordRendererId =
        decoder.decodeStructPointer(FieldRendererId);
    return val;
  };

  PasswordFormGenerationData.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(PasswordFormGenerationData.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(FieldRendererId, val.newPasswordRendererId);
    encoder.encodeStructPointer(FieldRendererId, val.confirmationPasswordRendererId);
  };
  function PasswordGenerationUIData(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  PasswordGenerationUIData.prototype.initDefaults_ = function() {
    this.bounds = null;
    this.maxLength = 0;
    this.isGenerationElementPasswordType = false;
    this.generationElement = null;
    this.generationElementId = null;
    this.textDirection = 0;
    this.formData = null;
  };
  PasswordGenerationUIData.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  PasswordGenerationUIData.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 56}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PasswordGenerationUIData.bounds
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, geometry$.RectF, false);
    if (err !== validator.validationError.NONE)
        return err;



    // validate PasswordGenerationUIData.generationElement
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, string16$.String16, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PasswordGenerationUIData.generationElementId
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 24, FieldRendererId, false);
    if (err !== validator.validationError.NONE)
        return err;



    // validate PasswordGenerationUIData.textDirection
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 32, text_direction$.TextDirection);
    if (err !== validator.validationError.NONE)
        return err;


    // validate PasswordGenerationUIData.formData
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 40, FormData, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  PasswordGenerationUIData.encodedSize = codec.kStructHeaderSize + 48;

  PasswordGenerationUIData.decode = function(decoder) {
    var packed;
    var val = new PasswordGenerationUIData();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.bounds =
        decoder.decodeStructPointer(geometry$.RectF);
    val.maxLength =
        decoder.decodeStruct(codec.Int32);
    packed = decoder.readUint8();
    val.isGenerationElementPasswordType = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.generationElement =
        decoder.decodeStructPointer(string16$.String16);
    val.generationElementId =
        decoder.decodeStructPointer(FieldRendererId);
    val.textDirection =
        decoder.decodeStruct(new codec.Enum(text_direction$.TextDirection));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.formData =
        decoder.decodeStructPointer(FormData);
    return val;
  };

  PasswordGenerationUIData.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(PasswordGenerationUIData.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(geometry$.RectF, val.bounds);
    encoder.encodeStruct(codec.Int32, val.maxLength);
    packed = 0;
    packed |= (val.isGenerationElementPasswordType & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStructPointer(string16$.String16, val.generationElement);
    encoder.encodeStructPointer(FieldRendererId, val.generationElementId);
    encoder.encodeStruct(codec.Int32, val.textDirection);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStructPointer(FormData, val.formData);
  };
  function ParsingResult(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ParsingResult.prototype.initDefaults_ = function() {
    this.usernameRendererId = null;
    this.passwordRendererId = null;
    this.newPasswordRendererId = null;
    this.confirmPasswordRendererId = null;
  };
  ParsingResult.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ParsingResult.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 40}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ParsingResult.usernameRendererId
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, FieldRendererId, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ParsingResult.passwordRendererId
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, FieldRendererId, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ParsingResult.newPasswordRendererId
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, FieldRendererId, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ParsingResult.confirmPasswordRendererId
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 24, FieldRendererId, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ParsingResult.encodedSize = codec.kStructHeaderSize + 32;

  ParsingResult.decode = function(decoder) {
    var packed;
    var val = new ParsingResult();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.usernameRendererId =
        decoder.decodeStructPointer(FieldRendererId);
    val.passwordRendererId =
        decoder.decodeStructPointer(FieldRendererId);
    val.newPasswordRendererId =
        decoder.decodeStructPointer(FieldRendererId);
    val.confirmPasswordRendererId =
        decoder.decodeStructPointer(FieldRendererId);
    return val;
  };

  ParsingResult.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ParsingResult.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(FieldRendererId, val.usernameRendererId);
    encoder.encodeStructPointer(FieldRendererId, val.passwordRendererId);
    encoder.encodeStructPointer(FieldRendererId, val.newPasswordRendererId);
    encoder.encodeStructPointer(FieldRendererId, val.confirmPasswordRendererId);
  };

  function SectionValue(value) {
    this.initDefault_();
    this.initValue_(value);
  }


  SectionValue.Tags = {
    defaultSection: 0,
    autocomplete: 1,
    fieldIdentifier: 2,
  };

  SectionValue.prototype.initDefault_ = function() {
    this.$data = null;
    this.$tag = undefined;
  }

  SectionValue.prototype.initValue_ = function(value) {
    if (value == undefined) {
      return;
    }

    var keys = Object.keys(value);
    if (keys.length == 0) {
      return;
    }

    if (keys.length > 1) {
      throw new TypeError("You may set only one member on a union.");
    }

    var fields = [
        "defaultSection",
        "autocomplete",
        "fieldIdentifier",
    ];

    if (fields.indexOf(keys[0]) < 0) {
      throw new ReferenceError(keys[0] + " is not a SectionValue member.");

    }

    this[keys[0]] = value[keys[0]];
  }
  Object.defineProperty(SectionValue.prototype, "defaultSection", {
    get: function() {
      if (this.$tag != SectionValue.Tags.defaultSection) {
        throw new ReferenceError(
            "SectionValue.defaultSection is not currently set.");
      }
      return this.$data;
    },

    set: function(value) {
      this.$tag = SectionValue.Tags.defaultSection;
      this.$data = value;
    }
  });
  Object.defineProperty(SectionValue.prototype, "autocomplete", {
    get: function() {
      if (this.$tag != SectionValue.Tags.autocomplete) {
        throw new ReferenceError(
            "SectionValue.autocomplete is not currently set.");
      }
      return this.$data;
    },

    set: function(value) {
      this.$tag = SectionValue.Tags.autocomplete;
      this.$data = value;
    }
  });
  Object.defineProperty(SectionValue.prototype, "fieldIdentifier", {
    get: function() {
      if (this.$tag != SectionValue.Tags.fieldIdentifier) {
        throw new ReferenceError(
            "SectionValue.fieldIdentifier is not currently set.");
      }
      return this.$data;
    },

    set: function(value) {
      this.$tag = SectionValue.Tags.fieldIdentifier;
      this.$data = value;
    }
  });


    SectionValue.encode = function(encoder, val) {
      if (val == null) {
        encoder.writeUint64(0);
        encoder.writeUint64(0);
        return;
      }
      if (val.$tag == undefined) {
        throw new TypeError("Cannot encode unions with an unknown member set.");
      }

      encoder.writeUint32(16);
      encoder.writeUint32(val.$tag);
      switch (val.$tag) {
        case SectionValue.Tags.defaultSection:
          encoder.writeUint8(val.defaultSection ? 1 : 0);
          break;
        case SectionValue.Tags.autocomplete:
          encoder.encodeStructPointer(SectionAutocomplete, val.autocomplete);
          break;
        case SectionValue.Tags.fieldIdentifier:
          encoder.encodeStructPointer(SectionFieldIdentifier, val.fieldIdentifier);
          break;
      }
      encoder.align();
    };


    SectionValue.decode = function(decoder) {
      var size = decoder.readUint32();
      if (size == 0) {
        decoder.readUint32();
        decoder.readUint64();
        return null;
      }

      var result = new SectionValue();
      var tag = decoder.readUint32();
      switch (tag) {
        case SectionValue.Tags.defaultSection:
          result.defaultSection = decoder.readUint8() ? true : false;
          break;
        case SectionValue.Tags.autocomplete:
          result.autocomplete = decoder.decodeStructPointer(SectionAutocomplete);
          break;
        case SectionValue.Tags.fieldIdentifier:
          result.fieldIdentifier = decoder.decodeStructPointer(SectionFieldIdentifier);
          break;
      }
      decoder.align();

      return result;
    };


    SectionValue.validate = function(messageValidator, offset) {
      var size = messageValidator.decodeUnionSize(offset);
      if (size != 16) {
        return validator.validationError.INVALID_UNION_SIZE;
      }

      var tag = messageValidator.decodeUnionTag(offset);
      var data_offset = offset + 8;
      var err;
      switch (tag) {
        case SectionValue.Tags.defaultSection:
          

          break;
        case SectionValue.Tags.autocomplete:
          

    // validate SectionValue.autocomplete
    err = messageValidator.validateStructPointer(data_offset, SectionAutocomplete, false);
    if (err !== validator.validationError.NONE)
        return err;
          break;
        case SectionValue.Tags.fieldIdentifier:
          

    // validate SectionValue.fieldIdentifier
    err = messageValidator.validateStructPointer(data_offset, SectionFieldIdentifier, false);
    if (err !== validator.validationError.NONE)
        return err;
          break;
      }

      return validator.validationError.NONE;
    };

  SectionValue.encodedSize = 16;
  exports.FormControlType = FormControlType;
  exports.HtmlFieldMode = HtmlFieldMode;
  exports.HtmlFieldType = HtmlFieldType;
  exports.SubmissionIndicatorEvent = SubmissionIndicatorEvent;
  exports.SubmissionSource = SubmissionSource;
  exports.FocusedFieldType = FocusedFieldType;
  exports.ButtonTitleType = ButtonTitleType;
  exports.SubmissionReadinessState = SubmissionReadinessState;
  exports.AutofillState = AutofillState;
  exports.AutofillActionPersistence = AutofillActionPersistence;
  exports.AutofillActionType = AutofillActionType;
  exports.AutofillSuggestionTriggerSource = AutofillSuggestionTriggerSource;
  exports.FrameToken = FrameToken;
  exports.FrameTokenWithPredecessor = FrameTokenWithPredecessor;
  exports.FormRendererId = FormRendererId;
  exports.FieldRendererId = FieldRendererId;
  exports.SelectOption = SelectOption;
  exports.SectionAutocomplete = SectionAutocomplete;
  exports.SectionFieldIdentifier = SectionFieldIdentifier;
  exports.Section = Section;
  exports.AutocompleteParsingResult = AutocompleteParsingResult;
  exports.FormFieldData = FormFieldData;
  exports.ButtonTitleInfo = ButtonTitleInfo;
  exports.FormData = FormData;
  exports.FormFieldDataPredictions = FormFieldDataPredictions;
  exports.FormDataPredictions = FormDataPredictions;
  exports.PasswordAndMetadata = PasswordAndMetadata;
  exports.PasswordFormFillData = PasswordFormFillData;
  exports.PasswordFormGenerationData = PasswordFormGenerationData;
  exports.PasswordGenerationUIData = PasswordGenerationUIData;
  exports.ParsingResult = ParsingResult;
  exports.SectionValue = SectionValue;
})();