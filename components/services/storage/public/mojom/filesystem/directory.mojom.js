// components/services/storage/public/mojom/filesystem/directory.mojom.js is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2014 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

(function() {
  var mojomId = 'components/services/storage/public/mojom/filesystem/directory.mojom';
  if (mojo.internal.isMojomLoaded(mojomId)) {
    console.warn('The following mojom is loaded multiple times: ' + mojomId);
    return;
  }
  mojo.internal.markMojomLoaded(mojomId);
  var bindings = mojo;
  var associatedBindings = mojo;
  var codec = mojo.internal;
  var validator = mojo.internal;

  var exports = mojo.internal.exposeNamespace('storage.mojom');
  var big_string$ =
      mojo.internal.exposeNamespace('mojoBase.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'mojo/public/mojom/base/big_string.mojom', '../../../../../../mojo/public/mojom/base/big_string.mojom.js');
  }
  var file$ =
      mojo.internal.exposeNamespace('mojoBase.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'mojo/public/mojom/base/file.mojom', '../../../../../../mojo/public/mojom/base/file.mojom.js');
  }
  var file_error$ =
      mojo.internal.exposeNamespace('mojoBase.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'mojo/public/mojom/base/file_error.mojom', '../../../../../../mojo/public/mojom/base/file_error.mojom.js');
  }
  var file_info$ =
      mojo.internal.exposeNamespace('mojoBase.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'mojo/public/mojom/base/file_info.mojom', '../../../../../../mojo/public/mojom/base/file_info.mojom.js');
  }
  var file_path$ =
      mojo.internal.exposeNamespace('mojoBase.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'mojo/public/mojom/base/file_path.mojom', '../../../../../../mojo/public/mojom/base/file_path.mojom.js');
  }


  var GetEntriesMode = {};
  GetEntriesMode.kFilesOnly = 0;
  GetEntriesMode.kFilesAndDirectories = 1;
  GetEntriesMode.MIN_VALUE = 0;
  GetEntriesMode.MAX_VALUE = 1;

  GetEntriesMode.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
      return true;
    }
    return false;
  };

  GetEntriesMode.toKnownEnumValue = function(value) {
    return value;
  };

  GetEntriesMode.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var FileOpenMode = {};
  FileOpenMode.kOpenIfExists = 0;
  FileOpenMode.kCreateAndOpenOnlyIfNotExists = 1;
  FileOpenMode.kAlwaysOpen = 2;
  FileOpenMode.kAlwaysCreate = 3;
  FileOpenMode.kOpenIfExistsAndTruncate = 4;
  FileOpenMode.MIN_VALUE = 0;
  FileOpenMode.MAX_VALUE = 4;

  FileOpenMode.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    }
    return false;
  };

  FileOpenMode.toKnownEnumValue = function(value) {
    return value;
  };

  FileOpenMode.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var FileReadAccess = {};
  FileReadAccess.kReadNotAllowed = 0;
  FileReadAccess.kReadAllowed = 1;
  FileReadAccess.MIN_VALUE = 0;
  FileReadAccess.MAX_VALUE = 1;

  FileReadAccess.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
      return true;
    }
    return false;
  };

  FileReadAccess.toKnownEnumValue = function(value) {
    return value;
  };

  FileReadAccess.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var FileWriteAccess = {};
  FileWriteAccess.kWriteNotAllowed = 0;
  FileWriteAccess.kWriteAllowed = 1;
  FileWriteAccess.kAppendOnly = 2;
  FileWriteAccess.MIN_VALUE = 0;
  FileWriteAccess.MAX_VALUE = 2;

  FileWriteAccess.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    }
    return false;
  };

  FileWriteAccess.toKnownEnumValue = function(value) {
    return value;
  };

  FileWriteAccess.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };

  function StrictRelativePath(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  StrictRelativePath.prototype.initDefaults_ = function() {
    this.path = null;
  };
  StrictRelativePath.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  StrictRelativePath.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate StrictRelativePath.path
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, file_path$.FilePath, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  StrictRelativePath.encodedSize = codec.kStructHeaderSize + 8;

  StrictRelativePath.decode = function(decoder) {
    var packed;
    var val = new StrictRelativePath();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.path =
        decoder.decodeStructPointer(file_path$.FilePath);
    return val;
  };

  StrictRelativePath.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(StrictRelativePath.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(file_path$.FilePath, val.path);
  };
  function PathAccessInfo(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  PathAccessInfo.prototype.initDefaults_ = function() {
    this.canRead = false;
    this.canWrite = false;
  };
  PathAccessInfo.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  PathAccessInfo.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    return validator.validationError.NONE;
  };

  PathAccessInfo.encodedSize = codec.kStructHeaderSize + 8;

  PathAccessInfo.decode = function(decoder) {
    var packed;
    var val = new PathAccessInfo();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    packed = decoder.readUint8();
    val.canRead = (packed >> 0) & 1 ? true : false;
    val.canWrite = (packed >> 1) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  PathAccessInfo.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(PathAccessInfo.encodedSize);
    encoder.writeUint32(0);
    packed = 0;
    packed |= (val.canRead & 1) << 0
    packed |= (val.canWrite & 1) << 1
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function FileLock_Release_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  FileLock_Release_Params.prototype.initDefaults_ = function() {
  };
  FileLock_Release_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  FileLock_Release_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  FileLock_Release_Params.encodedSize = codec.kStructHeaderSize + 0;

  FileLock_Release_Params.decode = function(decoder) {
    var packed;
    var val = new FileLock_Release_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  FileLock_Release_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(FileLock_Release_Params.encodedSize);
    encoder.writeUint32(0);
  };
  function FileLock_Release_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  FileLock_Release_ResponseParams.prototype.initDefaults_ = function() {
    this.error = 0;
  };
  FileLock_Release_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  FileLock_Release_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate FileLock_Release_ResponseParams.error
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, file_error$.FileError);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  FileLock_Release_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  FileLock_Release_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new FileLock_Release_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.error =
        decoder.decodeStruct(new codec.Enum(file_error$.FileError));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  FileLock_Release_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(FileLock_Release_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.error);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function Directory_Clone_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Directory_Clone_Params.prototype.initDefaults_ = function() {
    this.receiver = new bindings.InterfaceRequest();
  };
  Directory_Clone_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Directory_Clone_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Directory_Clone_Params.receiver
    err = messageValidator.validateInterfaceRequest(offset + codec.kStructHeaderSize + 0, false)
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Directory_Clone_Params.encodedSize = codec.kStructHeaderSize + 8;

  Directory_Clone_Params.decode = function(decoder) {
    var packed;
    var val = new Directory_Clone_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.receiver =
        decoder.decodeStruct(codec.InterfaceRequest);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  Directory_Clone_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Directory_Clone_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.InterfaceRequest, val.receiver);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function Directory_PathExists_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Directory_PathExists_Params.prototype.initDefaults_ = function() {
    this.path = null;
  };
  Directory_PathExists_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Directory_PathExists_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Directory_PathExists_Params.path
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, StrictRelativePath, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Directory_PathExists_Params.encodedSize = codec.kStructHeaderSize + 8;

  Directory_PathExists_Params.decode = function(decoder) {
    var packed;
    var val = new Directory_PathExists_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.path =
        decoder.decodeStructPointer(StrictRelativePath);
    return val;
  };

  Directory_PathExists_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Directory_PathExists_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(StrictRelativePath, val.path);
  };
  function Directory_PathExists_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Directory_PathExists_ResponseParams.prototype.initDefaults_ = function() {
    this.exists = false;
  };
  Directory_PathExists_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Directory_PathExists_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  Directory_PathExists_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  Directory_PathExists_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new Directory_PathExists_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    packed = decoder.readUint8();
    val.exists = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  Directory_PathExists_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Directory_PathExists_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    packed = 0;
    packed |= (val.exists & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function Directory_GetEntries_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Directory_GetEntries_Params.prototype.initDefaults_ = function() {
    this.path = null;
    this.mode = 0;
  };
  Directory_GetEntries_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Directory_GetEntries_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Directory_GetEntries_Params.path
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, StrictRelativePath, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Directory_GetEntries_Params.mode
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 8, GetEntriesMode);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Directory_GetEntries_Params.encodedSize = codec.kStructHeaderSize + 16;

  Directory_GetEntries_Params.decode = function(decoder) {
    var packed;
    var val = new Directory_GetEntries_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.path =
        decoder.decodeStructPointer(StrictRelativePath);
    val.mode =
        decoder.decodeStruct(new codec.Enum(GetEntriesMode));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  Directory_GetEntries_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Directory_GetEntries_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(StrictRelativePath, val.path);
    encoder.encodeStruct(codec.Int32, val.mode);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function Directory_GetEntries_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Directory_GetEntries_ResponseParams.prototype.initDefaults_ = function() {
    this.error = 0;
    this.entries = null;
  };
  Directory_GetEntries_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Directory_GetEntries_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Directory_GetEntries_ResponseParams.error
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, file_error$.FileError);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Directory_GetEntries_ResponseParams.entries
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 8, 8, new codec.PointerTo(file_path$.FilePath), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Directory_GetEntries_ResponseParams.encodedSize = codec.kStructHeaderSize + 16;

  Directory_GetEntries_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new Directory_GetEntries_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.error =
        decoder.decodeStruct(new codec.Enum(file_error$.FileError));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.entries =
        decoder.decodeArrayPointer(new codec.PointerTo(file_path$.FilePath));
    return val;
  };

  Directory_GetEntries_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Directory_GetEntries_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.error);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeArrayPointer(new codec.PointerTo(file_path$.FilePath), val.entries);
  };
  function Directory_OpenFile_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Directory_OpenFile_Params.prototype.initDefaults_ = function() {
    this.path = null;
    this.mode = 0;
    this.readAccess = 0;
    this.writeAccess = 0;
  };
  Directory_OpenFile_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Directory_OpenFile_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 32}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Directory_OpenFile_Params.path
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, StrictRelativePath, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Directory_OpenFile_Params.mode
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 8, FileOpenMode);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Directory_OpenFile_Params.readAccess
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 12, FileReadAccess);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Directory_OpenFile_Params.writeAccess
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 16, FileWriteAccess);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Directory_OpenFile_Params.encodedSize = codec.kStructHeaderSize + 24;

  Directory_OpenFile_Params.decode = function(decoder) {
    var packed;
    var val = new Directory_OpenFile_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.path =
        decoder.decodeStructPointer(StrictRelativePath);
    val.mode =
        decoder.decodeStruct(new codec.Enum(FileOpenMode));
    val.readAccess =
        decoder.decodeStruct(new codec.Enum(FileReadAccess));
    val.writeAccess =
        decoder.decodeStruct(new codec.Enum(FileWriteAccess));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  Directory_OpenFile_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Directory_OpenFile_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(StrictRelativePath, val.path);
    encoder.encodeStruct(codec.Int32, val.mode);
    encoder.encodeStruct(codec.Int32, val.readAccess);
    encoder.encodeStruct(codec.Int32, val.writeAccess);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function Directory_OpenFile_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Directory_OpenFile_ResponseParams.prototype.initDefaults_ = function() {
    this.error = 0;
    this.file = null;
  };
  Directory_OpenFile_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Directory_OpenFile_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Directory_OpenFile_ResponseParams.error
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, file_error$.FileError);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Directory_OpenFile_ResponseParams.file
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, file$.File, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Directory_OpenFile_ResponseParams.encodedSize = codec.kStructHeaderSize + 16;

  Directory_OpenFile_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new Directory_OpenFile_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.error =
        decoder.decodeStruct(new codec.Enum(file_error$.FileError));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.file =
        decoder.decodeStructPointer(file$.File);
    return val;
  };

  Directory_OpenFile_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Directory_OpenFile_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.error);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStructPointer(file$.File, val.file);
  };
  function Directory_WriteFileAtomically_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Directory_WriteFileAtomically_Params.prototype.initDefaults_ = function() {
    this.path = null;
    this.contents = null;
  };
  Directory_WriteFileAtomically_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Directory_WriteFileAtomically_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Directory_WriteFileAtomically_Params.path
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, StrictRelativePath, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Directory_WriteFileAtomically_Params.contents
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, big_string$.BigString, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Directory_WriteFileAtomically_Params.encodedSize = codec.kStructHeaderSize + 16;

  Directory_WriteFileAtomically_Params.decode = function(decoder) {
    var packed;
    var val = new Directory_WriteFileAtomically_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.path =
        decoder.decodeStructPointer(StrictRelativePath);
    val.contents =
        decoder.decodeStructPointer(big_string$.BigString);
    return val;
  };

  Directory_WriteFileAtomically_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Directory_WriteFileAtomically_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(StrictRelativePath, val.path);
    encoder.encodeStructPointer(big_string$.BigString, val.contents);
  };
  function Directory_WriteFileAtomically_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Directory_WriteFileAtomically_ResponseParams.prototype.initDefaults_ = function() {
    this.success = false;
  };
  Directory_WriteFileAtomically_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Directory_WriteFileAtomically_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  Directory_WriteFileAtomically_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  Directory_WriteFileAtomically_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new Directory_WriteFileAtomically_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    packed = decoder.readUint8();
    val.success = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  Directory_WriteFileAtomically_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Directory_WriteFileAtomically_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    packed = 0;
    packed |= (val.success & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function Directory_CreateDirectory_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Directory_CreateDirectory_Params.prototype.initDefaults_ = function() {
    this.path = null;
  };
  Directory_CreateDirectory_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Directory_CreateDirectory_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Directory_CreateDirectory_Params.path
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, StrictRelativePath, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Directory_CreateDirectory_Params.encodedSize = codec.kStructHeaderSize + 8;

  Directory_CreateDirectory_Params.decode = function(decoder) {
    var packed;
    var val = new Directory_CreateDirectory_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.path =
        decoder.decodeStructPointer(StrictRelativePath);
    return val;
  };

  Directory_CreateDirectory_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Directory_CreateDirectory_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(StrictRelativePath, val.path);
  };
  function Directory_CreateDirectory_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Directory_CreateDirectory_ResponseParams.prototype.initDefaults_ = function() {
    this.error = 0;
  };
  Directory_CreateDirectory_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Directory_CreateDirectory_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Directory_CreateDirectory_ResponseParams.error
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, file_error$.FileError);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Directory_CreateDirectory_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  Directory_CreateDirectory_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new Directory_CreateDirectory_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.error =
        decoder.decodeStruct(new codec.Enum(file_error$.FileError));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  Directory_CreateDirectory_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Directory_CreateDirectory_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.error);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function Directory_DeleteFile_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Directory_DeleteFile_Params.prototype.initDefaults_ = function() {
    this.path = null;
  };
  Directory_DeleteFile_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Directory_DeleteFile_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Directory_DeleteFile_Params.path
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, StrictRelativePath, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Directory_DeleteFile_Params.encodedSize = codec.kStructHeaderSize + 8;

  Directory_DeleteFile_Params.decode = function(decoder) {
    var packed;
    var val = new Directory_DeleteFile_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.path =
        decoder.decodeStructPointer(StrictRelativePath);
    return val;
  };

  Directory_DeleteFile_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Directory_DeleteFile_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(StrictRelativePath, val.path);
  };
  function Directory_DeleteFile_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Directory_DeleteFile_ResponseParams.prototype.initDefaults_ = function() {
    this.success = false;
  };
  Directory_DeleteFile_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Directory_DeleteFile_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  Directory_DeleteFile_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  Directory_DeleteFile_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new Directory_DeleteFile_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    packed = decoder.readUint8();
    val.success = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  Directory_DeleteFile_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Directory_DeleteFile_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    packed = 0;
    packed |= (val.success & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function Directory_DeletePathRecursively_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Directory_DeletePathRecursively_Params.prototype.initDefaults_ = function() {
    this.path = null;
  };
  Directory_DeletePathRecursively_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Directory_DeletePathRecursively_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Directory_DeletePathRecursively_Params.path
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, StrictRelativePath, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Directory_DeletePathRecursively_Params.encodedSize = codec.kStructHeaderSize + 8;

  Directory_DeletePathRecursively_Params.decode = function(decoder) {
    var packed;
    var val = new Directory_DeletePathRecursively_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.path =
        decoder.decodeStructPointer(StrictRelativePath);
    return val;
  };

  Directory_DeletePathRecursively_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Directory_DeletePathRecursively_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(StrictRelativePath, val.path);
  };
  function Directory_DeletePathRecursively_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Directory_DeletePathRecursively_ResponseParams.prototype.initDefaults_ = function() {
    this.success = false;
  };
  Directory_DeletePathRecursively_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Directory_DeletePathRecursively_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  Directory_DeletePathRecursively_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  Directory_DeletePathRecursively_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new Directory_DeletePathRecursively_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    packed = decoder.readUint8();
    val.success = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  Directory_DeletePathRecursively_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Directory_DeletePathRecursively_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    packed = 0;
    packed |= (val.success & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function Directory_GetFileInfo_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Directory_GetFileInfo_Params.prototype.initDefaults_ = function() {
    this.path = null;
  };
  Directory_GetFileInfo_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Directory_GetFileInfo_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Directory_GetFileInfo_Params.path
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, StrictRelativePath, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Directory_GetFileInfo_Params.encodedSize = codec.kStructHeaderSize + 8;

  Directory_GetFileInfo_Params.decode = function(decoder) {
    var packed;
    var val = new Directory_GetFileInfo_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.path =
        decoder.decodeStructPointer(StrictRelativePath);
    return val;
  };

  Directory_GetFileInfo_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Directory_GetFileInfo_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(StrictRelativePath, val.path);
  };
  function Directory_GetFileInfo_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Directory_GetFileInfo_ResponseParams.prototype.initDefaults_ = function() {
    this.info = null;
  };
  Directory_GetFileInfo_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Directory_GetFileInfo_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Directory_GetFileInfo_ResponseParams.info
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, file_info$.FileInfo, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Directory_GetFileInfo_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  Directory_GetFileInfo_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new Directory_GetFileInfo_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.info =
        decoder.decodeStructPointer(file_info$.FileInfo);
    return val;
  };

  Directory_GetFileInfo_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Directory_GetFileInfo_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(file_info$.FileInfo, val.info);
  };
  function Directory_GetPathAccess_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Directory_GetPathAccess_Params.prototype.initDefaults_ = function() {
    this.path = null;
  };
  Directory_GetPathAccess_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Directory_GetPathAccess_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Directory_GetPathAccess_Params.path
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, StrictRelativePath, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Directory_GetPathAccess_Params.encodedSize = codec.kStructHeaderSize + 8;

  Directory_GetPathAccess_Params.decode = function(decoder) {
    var packed;
    var val = new Directory_GetPathAccess_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.path =
        decoder.decodeStructPointer(StrictRelativePath);
    return val;
  };

  Directory_GetPathAccess_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Directory_GetPathAccess_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(StrictRelativePath, val.path);
  };
  function Directory_GetPathAccess_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Directory_GetPathAccess_ResponseParams.prototype.initDefaults_ = function() {
    this.info = null;
  };
  Directory_GetPathAccess_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Directory_GetPathAccess_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Directory_GetPathAccess_ResponseParams.info
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, PathAccessInfo, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Directory_GetPathAccess_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  Directory_GetPathAccess_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new Directory_GetPathAccess_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.info =
        decoder.decodeStructPointer(PathAccessInfo);
    return val;
  };

  Directory_GetPathAccess_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Directory_GetPathAccess_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(PathAccessInfo, val.info);
  };
  function Directory_GetMaximumPathComponentLength_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Directory_GetMaximumPathComponentLength_Params.prototype.initDefaults_ = function() {
    this.path = null;
  };
  Directory_GetMaximumPathComponentLength_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Directory_GetMaximumPathComponentLength_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Directory_GetMaximumPathComponentLength_Params.path
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, StrictRelativePath, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Directory_GetMaximumPathComponentLength_Params.encodedSize = codec.kStructHeaderSize + 8;

  Directory_GetMaximumPathComponentLength_Params.decode = function(decoder) {
    var packed;
    var val = new Directory_GetMaximumPathComponentLength_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.path =
        decoder.decodeStructPointer(StrictRelativePath);
    return val;
  };

  Directory_GetMaximumPathComponentLength_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Directory_GetMaximumPathComponentLength_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(StrictRelativePath, val.path);
  };
  function Directory_GetMaximumPathComponentLength_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Directory_GetMaximumPathComponentLength_ResponseParams.prototype.initDefaults_ = function() {
    this.success = false;
    this.length = 0;
  };
  Directory_GetMaximumPathComponentLength_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Directory_GetMaximumPathComponentLength_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    return validator.validationError.NONE;
  };

  Directory_GetMaximumPathComponentLength_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  Directory_GetMaximumPathComponentLength_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new Directory_GetMaximumPathComponentLength_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    packed = decoder.readUint8();
    val.success = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.length =
        decoder.decodeStruct(codec.Int32);
    return val;
  };

  Directory_GetMaximumPathComponentLength_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Directory_GetMaximumPathComponentLength_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    packed = 0;
    packed |= (val.success & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.Int32, val.length);
  };
  function Directory_RenameFile_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Directory_RenameFile_Params.prototype.initDefaults_ = function() {
    this.oldPath = null;
    this.newPath = null;
  };
  Directory_RenameFile_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Directory_RenameFile_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Directory_RenameFile_Params.oldPath
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, StrictRelativePath, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Directory_RenameFile_Params.newPath
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, StrictRelativePath, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Directory_RenameFile_Params.encodedSize = codec.kStructHeaderSize + 16;

  Directory_RenameFile_Params.decode = function(decoder) {
    var packed;
    var val = new Directory_RenameFile_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.oldPath =
        decoder.decodeStructPointer(StrictRelativePath);
    val.newPath =
        decoder.decodeStructPointer(StrictRelativePath);
    return val;
  };

  Directory_RenameFile_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Directory_RenameFile_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(StrictRelativePath, val.oldPath);
    encoder.encodeStructPointer(StrictRelativePath, val.newPath);
  };
  function Directory_RenameFile_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Directory_RenameFile_ResponseParams.prototype.initDefaults_ = function() {
    this.error = 0;
  };
  Directory_RenameFile_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Directory_RenameFile_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Directory_RenameFile_ResponseParams.error
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, file_error$.FileError);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Directory_RenameFile_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  Directory_RenameFile_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new Directory_RenameFile_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.error =
        decoder.decodeStruct(new codec.Enum(file_error$.FileError));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  Directory_RenameFile_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Directory_RenameFile_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.error);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function Directory_LockFile_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Directory_LockFile_Params.prototype.initDefaults_ = function() {
    this.path = null;
  };
  Directory_LockFile_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Directory_LockFile_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Directory_LockFile_Params.path
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, StrictRelativePath, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Directory_LockFile_Params.encodedSize = codec.kStructHeaderSize + 8;

  Directory_LockFile_Params.decode = function(decoder) {
    var packed;
    var val = new Directory_LockFile_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.path =
        decoder.decodeStructPointer(StrictRelativePath);
    return val;
  };

  Directory_LockFile_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Directory_LockFile_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(StrictRelativePath, val.path);
  };
  function Directory_LockFile_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Directory_LockFile_ResponseParams.prototype.initDefaults_ = function() {
    this.error = 0;
    this.lock = new FileLockPtr();
  };
  Directory_LockFile_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Directory_LockFile_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Directory_LockFile_ResponseParams.error
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, file_error$.FileError);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Directory_LockFile_ResponseParams.lock
    err = messageValidator.validateInterface(offset + codec.kStructHeaderSize + 4, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Directory_LockFile_ResponseParams.encodedSize = codec.kStructHeaderSize + 16;

  Directory_LockFile_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new Directory_LockFile_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.error =
        decoder.decodeStruct(new codec.Enum(file_error$.FileError));
    val.lock =
        decoder.decodeStruct(new codec.NullableInterface(FileLockPtr));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  Directory_LockFile_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Directory_LockFile_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.error);
    encoder.encodeStruct(new codec.NullableInterface(FileLockPtr), val.lock);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function Directory_SetOpenedFileLength_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Directory_SetOpenedFileLength_Params.prototype.initDefaults_ = function() {
    this.file = null;
    this.size = 0;
  };
  Directory_SetOpenedFileLength_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Directory_SetOpenedFileLength_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Directory_SetOpenedFileLength_Params.file
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, file$.File, false);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  Directory_SetOpenedFileLength_Params.encodedSize = codec.kStructHeaderSize + 16;

  Directory_SetOpenedFileLength_Params.decode = function(decoder) {
    var packed;
    var val = new Directory_SetOpenedFileLength_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.file =
        decoder.decodeStructPointer(file$.File);
    val.size =
        decoder.decodeStruct(codec.Uint64);
    return val;
  };

  Directory_SetOpenedFileLength_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Directory_SetOpenedFileLength_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(file$.File, val.file);
    encoder.encodeStruct(codec.Uint64, val.size);
  };
  function Directory_SetOpenedFileLength_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Directory_SetOpenedFileLength_ResponseParams.prototype.initDefaults_ = function() {
    this.success = false;
    this.file = null;
  };
  Directory_SetOpenedFileLength_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Directory_SetOpenedFileLength_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    // validate Directory_SetOpenedFileLength_ResponseParams.file
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, file$.File, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Directory_SetOpenedFileLength_ResponseParams.encodedSize = codec.kStructHeaderSize + 16;

  Directory_SetOpenedFileLength_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new Directory_SetOpenedFileLength_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    packed = decoder.readUint8();
    val.success = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.file =
        decoder.decodeStructPointer(file$.File);
    return val;
  };

  Directory_SetOpenedFileLength_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Directory_SetOpenedFileLength_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    packed = 0;
    packed |= (val.success & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStructPointer(file$.File, val.file);
  };
  var kFileLock_Release_Name = 1571118061;

  function FileLockPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(FileLock,
                                                   handleOrPtrInfo);
  }

  function FileLockAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        FileLock, associatedInterfacePtrInfo);
  }

  FileLockAssociatedPtr.prototype =
      Object.create(FileLockPtr.prototype);
  FileLockAssociatedPtr.prototype.constructor =
      FileLockAssociatedPtr;

  function FileLockProxy(receiver) {
    this.receiver_ = receiver;
  }
  FileLockPtr.prototype.release = function() {
    return FileLockProxy.prototype.release
        .apply(this.ptr.getProxy(), arguments);
  };

  FileLockProxy.prototype.release = function() {
    var params_ = new FileLock_Release_Params();
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kFileLock_Release_Name,
          codec.align(FileLock_Release_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(FileLock_Release_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(FileLock_Release_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };

  function FileLockStub(delegate) {
    this.delegate_ = delegate;
  }
  FileLockStub.prototype.release = function() {
    return this.delegate_ && this.delegate_.release && this.delegate_.release();
  }

  FileLockStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  FileLockStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kFileLock_Release_Name:
      var params = reader.decodeStruct(FileLock_Release_Params);
      this.release().then(function(response) {
        var responseParams =
            new FileLock_Release_ResponseParams();
        responseParams.error = response.error;
        var builder = new codec.MessageV1Builder(
            kFileLock_Release_Name,
            codec.align(FileLock_Release_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(FileLock_Release_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    default:
      return false;
    }
  };

  function validateFileLockRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kFileLock_Release_Name:
        if (message.expectsResponse())
          paramsClass = FileLock_Release_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateFileLockResponse(messageValidator) {
   var message = messageValidator.message;
   var paramsClass = null;
   switch (message.getName()) {
      case kFileLock_Release_Name:
        if (message.isResponse())
          paramsClass = FileLock_Release_ResponseParams;
        break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  var FileLock = {
    name: 'storage.mojom.FileLock',
    kVersion: 0,
    ptrClass: FileLockPtr,
    proxyClass: FileLockProxy,
    stubClass: FileLockStub,
    validateRequest: validateFileLockRequest,
    validateResponse: validateFileLockResponse,
  };
  FileLockStub.prototype.validator = validateFileLockRequest;
  FileLockProxy.prototype.validator = validateFileLockResponse;
  var kDirectory_Clone_Name = 1915286789;
  var kDirectory_PathExists_Name = 218732951;
  var kDirectory_GetEntries_Name = 749018407;
  var kDirectory_OpenFile_Name = 1574932891;
  var kDirectory_WriteFileAtomically_Name = 1674915795;
  var kDirectory_CreateDirectory_Name = 643009519;
  var kDirectory_DeleteFile_Name = 944386197;
  var kDirectory_DeletePathRecursively_Name = 616788014;
  var kDirectory_GetFileInfo_Name = 1067450208;
  var kDirectory_GetPathAccess_Name = 1988180985;
  var kDirectory_GetMaximumPathComponentLength_Name = 763789192;
  var kDirectory_RenameFile_Name = 1028952726;
  var kDirectory_LockFile_Name = 1093073739;
  var kDirectory_SetOpenedFileLength_Name = 152760014;

  function DirectoryPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(Directory,
                                                   handleOrPtrInfo);
  }

  function DirectoryAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        Directory, associatedInterfacePtrInfo);
  }

  DirectoryAssociatedPtr.prototype =
      Object.create(DirectoryPtr.prototype);
  DirectoryAssociatedPtr.prototype.constructor =
      DirectoryAssociatedPtr;

  function DirectoryProxy(receiver) {
    this.receiver_ = receiver;
  }
  DirectoryPtr.prototype.clone = function() {
    return DirectoryProxy.prototype.clone
        .apply(this.ptr.getProxy(), arguments);
  };

  DirectoryProxy.prototype.clone = function(receiver) {
    var params_ = new Directory_Clone_Params();
    params_.receiver = receiver;
    var builder = new codec.MessageV0Builder(
        kDirectory_Clone_Name,
        codec.align(Directory_Clone_Params.encodedSize));
    builder.encodeStruct(Directory_Clone_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  DirectoryPtr.prototype.pathExists = function() {
    return DirectoryProxy.prototype.pathExists
        .apply(this.ptr.getProxy(), arguments);
  };

  DirectoryProxy.prototype.pathExists = function(path) {
    var params_ = new Directory_PathExists_Params();
    params_.path = path;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kDirectory_PathExists_Name,
          codec.align(Directory_PathExists_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(Directory_PathExists_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(Directory_PathExists_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  DirectoryPtr.prototype.getEntries = function() {
    return DirectoryProxy.prototype.getEntries
        .apply(this.ptr.getProxy(), arguments);
  };

  DirectoryProxy.prototype.getEntries = function(path, mode) {
    var params_ = new Directory_GetEntries_Params();
    params_.path = path;
    params_.mode = mode;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kDirectory_GetEntries_Name,
          codec.align(Directory_GetEntries_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(Directory_GetEntries_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(Directory_GetEntries_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  DirectoryPtr.prototype.openFile = function() {
    return DirectoryProxy.prototype.openFile
        .apply(this.ptr.getProxy(), arguments);
  };

  DirectoryProxy.prototype.openFile = function(path, mode, readAccess, writeAccess) {
    var params_ = new Directory_OpenFile_Params();
    params_.path = path;
    params_.mode = mode;
    params_.readAccess = readAccess;
    params_.writeAccess = writeAccess;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kDirectory_OpenFile_Name,
          codec.align(Directory_OpenFile_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(Directory_OpenFile_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(Directory_OpenFile_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  DirectoryPtr.prototype.writeFileAtomically = function() {
    return DirectoryProxy.prototype.writeFileAtomically
        .apply(this.ptr.getProxy(), arguments);
  };

  DirectoryProxy.prototype.writeFileAtomically = function(path, contents) {
    var params_ = new Directory_WriteFileAtomically_Params();
    params_.path = path;
    params_.contents = contents;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kDirectory_WriteFileAtomically_Name,
          codec.align(Directory_WriteFileAtomically_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(Directory_WriteFileAtomically_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(Directory_WriteFileAtomically_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  DirectoryPtr.prototype.createDirectory = function() {
    return DirectoryProxy.prototype.createDirectory
        .apply(this.ptr.getProxy(), arguments);
  };

  DirectoryProxy.prototype.createDirectory = function(path) {
    var params_ = new Directory_CreateDirectory_Params();
    params_.path = path;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kDirectory_CreateDirectory_Name,
          codec.align(Directory_CreateDirectory_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(Directory_CreateDirectory_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(Directory_CreateDirectory_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  DirectoryPtr.prototype.deleteFile = function() {
    return DirectoryProxy.prototype.deleteFile
        .apply(this.ptr.getProxy(), arguments);
  };

  DirectoryProxy.prototype.deleteFile = function(path) {
    var params_ = new Directory_DeleteFile_Params();
    params_.path = path;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kDirectory_DeleteFile_Name,
          codec.align(Directory_DeleteFile_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(Directory_DeleteFile_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(Directory_DeleteFile_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  DirectoryPtr.prototype.deletePathRecursively = function() {
    return DirectoryProxy.prototype.deletePathRecursively
        .apply(this.ptr.getProxy(), arguments);
  };

  DirectoryProxy.prototype.deletePathRecursively = function(path) {
    var params_ = new Directory_DeletePathRecursively_Params();
    params_.path = path;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kDirectory_DeletePathRecursively_Name,
          codec.align(Directory_DeletePathRecursively_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(Directory_DeletePathRecursively_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(Directory_DeletePathRecursively_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  DirectoryPtr.prototype.getFileInfo = function() {
    return DirectoryProxy.prototype.getFileInfo
        .apply(this.ptr.getProxy(), arguments);
  };

  DirectoryProxy.prototype.getFileInfo = function(path) {
    var params_ = new Directory_GetFileInfo_Params();
    params_.path = path;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kDirectory_GetFileInfo_Name,
          codec.align(Directory_GetFileInfo_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(Directory_GetFileInfo_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(Directory_GetFileInfo_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  DirectoryPtr.prototype.getPathAccess = function() {
    return DirectoryProxy.prototype.getPathAccess
        .apply(this.ptr.getProxy(), arguments);
  };

  DirectoryProxy.prototype.getPathAccess = function(path) {
    var params_ = new Directory_GetPathAccess_Params();
    params_.path = path;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kDirectory_GetPathAccess_Name,
          codec.align(Directory_GetPathAccess_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(Directory_GetPathAccess_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(Directory_GetPathAccess_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  DirectoryPtr.prototype.getMaximumPathComponentLength = function() {
    return DirectoryProxy.prototype.getMaximumPathComponentLength
        .apply(this.ptr.getProxy(), arguments);
  };

  DirectoryProxy.prototype.getMaximumPathComponentLength = function(path) {
    var params_ = new Directory_GetMaximumPathComponentLength_Params();
    params_.path = path;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kDirectory_GetMaximumPathComponentLength_Name,
          codec.align(Directory_GetMaximumPathComponentLength_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(Directory_GetMaximumPathComponentLength_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(Directory_GetMaximumPathComponentLength_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  DirectoryPtr.prototype.renameFile = function() {
    return DirectoryProxy.prototype.renameFile
        .apply(this.ptr.getProxy(), arguments);
  };

  DirectoryProxy.prototype.renameFile = function(oldPath, newPath) {
    var params_ = new Directory_RenameFile_Params();
    params_.oldPath = oldPath;
    params_.newPath = newPath;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kDirectory_RenameFile_Name,
          codec.align(Directory_RenameFile_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(Directory_RenameFile_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(Directory_RenameFile_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  DirectoryPtr.prototype.lockFile = function() {
    return DirectoryProxy.prototype.lockFile
        .apply(this.ptr.getProxy(), arguments);
  };

  DirectoryProxy.prototype.lockFile = function(path) {
    var params_ = new Directory_LockFile_Params();
    params_.path = path;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kDirectory_LockFile_Name,
          codec.align(Directory_LockFile_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(Directory_LockFile_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(Directory_LockFile_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  DirectoryPtr.prototype.setOpenedFileLength = function() {
    return DirectoryProxy.prototype.setOpenedFileLength
        .apply(this.ptr.getProxy(), arguments);
  };

  DirectoryProxy.prototype.setOpenedFileLength = function(file, size) {
    var params_ = new Directory_SetOpenedFileLength_Params();
    params_.file = file;
    params_.size = size;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kDirectory_SetOpenedFileLength_Name,
          codec.align(Directory_SetOpenedFileLength_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(Directory_SetOpenedFileLength_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(Directory_SetOpenedFileLength_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };

  function DirectoryStub(delegate) {
    this.delegate_ = delegate;
  }
  DirectoryStub.prototype.clone = function(receiver) {
    return this.delegate_ && this.delegate_.clone && this.delegate_.clone(receiver);
  }
  DirectoryStub.prototype.pathExists = function(path) {
    return this.delegate_ && this.delegate_.pathExists && this.delegate_.pathExists(path);
  }
  DirectoryStub.prototype.getEntries = function(path, mode) {
    return this.delegate_ && this.delegate_.getEntries && this.delegate_.getEntries(path, mode);
  }
  DirectoryStub.prototype.openFile = function(path, mode, readAccess, writeAccess) {
    return this.delegate_ && this.delegate_.openFile && this.delegate_.openFile(path, mode, readAccess, writeAccess);
  }
  DirectoryStub.prototype.writeFileAtomically = function(path, contents) {
    return this.delegate_ && this.delegate_.writeFileAtomically && this.delegate_.writeFileAtomically(path, contents);
  }
  DirectoryStub.prototype.createDirectory = function(path) {
    return this.delegate_ && this.delegate_.createDirectory && this.delegate_.createDirectory(path);
  }
  DirectoryStub.prototype.deleteFile = function(path) {
    return this.delegate_ && this.delegate_.deleteFile && this.delegate_.deleteFile(path);
  }
  DirectoryStub.prototype.deletePathRecursively = function(path) {
    return this.delegate_ && this.delegate_.deletePathRecursively && this.delegate_.deletePathRecursively(path);
  }
  DirectoryStub.prototype.getFileInfo = function(path) {
    return this.delegate_ && this.delegate_.getFileInfo && this.delegate_.getFileInfo(path);
  }
  DirectoryStub.prototype.getPathAccess = function(path) {
    return this.delegate_ && this.delegate_.getPathAccess && this.delegate_.getPathAccess(path);
  }
  DirectoryStub.prototype.getMaximumPathComponentLength = function(path) {
    return this.delegate_ && this.delegate_.getMaximumPathComponentLength && this.delegate_.getMaximumPathComponentLength(path);
  }
  DirectoryStub.prototype.renameFile = function(oldPath, newPath) {
    return this.delegate_ && this.delegate_.renameFile && this.delegate_.renameFile(oldPath, newPath);
  }
  DirectoryStub.prototype.lockFile = function(path) {
    return this.delegate_ && this.delegate_.lockFile && this.delegate_.lockFile(path);
  }
  DirectoryStub.prototype.setOpenedFileLength = function(file, size) {
    return this.delegate_ && this.delegate_.setOpenedFileLength && this.delegate_.setOpenedFileLength(file, size);
  }

  DirectoryStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kDirectory_Clone_Name:
      var params = reader.decodeStruct(Directory_Clone_Params);
      this.clone(params.receiver);
      return true;
    default:
      return false;
    }
  };

  DirectoryStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kDirectory_PathExists_Name:
      var params = reader.decodeStruct(Directory_PathExists_Params);
      this.pathExists(params.path).then(function(response) {
        var responseParams =
            new Directory_PathExists_ResponseParams();
        responseParams.exists = response.exists;
        var builder = new codec.MessageV1Builder(
            kDirectory_PathExists_Name,
            codec.align(Directory_PathExists_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(Directory_PathExists_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kDirectory_GetEntries_Name:
      var params = reader.decodeStruct(Directory_GetEntries_Params);
      this.getEntries(params.path, params.mode).then(function(response) {
        var responseParams =
            new Directory_GetEntries_ResponseParams();
        responseParams.error = response.error;
        responseParams.entries = response.entries;
        var builder = new codec.MessageV1Builder(
            kDirectory_GetEntries_Name,
            codec.align(Directory_GetEntries_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(Directory_GetEntries_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kDirectory_OpenFile_Name:
      var params = reader.decodeStruct(Directory_OpenFile_Params);
      this.openFile(params.path, params.mode, params.readAccess, params.writeAccess).then(function(response) {
        var responseParams =
            new Directory_OpenFile_ResponseParams();
        responseParams.error = response.error;
        responseParams.file = response.file;
        var builder = new codec.MessageV1Builder(
            kDirectory_OpenFile_Name,
            codec.align(Directory_OpenFile_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(Directory_OpenFile_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kDirectory_WriteFileAtomically_Name:
      var params = reader.decodeStruct(Directory_WriteFileAtomically_Params);
      this.writeFileAtomically(params.path, params.contents).then(function(response) {
        var responseParams =
            new Directory_WriteFileAtomically_ResponseParams();
        responseParams.success = response.success;
        var builder = new codec.MessageV1Builder(
            kDirectory_WriteFileAtomically_Name,
            codec.align(Directory_WriteFileAtomically_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(Directory_WriteFileAtomically_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kDirectory_CreateDirectory_Name:
      var params = reader.decodeStruct(Directory_CreateDirectory_Params);
      this.createDirectory(params.path).then(function(response) {
        var responseParams =
            new Directory_CreateDirectory_ResponseParams();
        responseParams.error = response.error;
        var builder = new codec.MessageV1Builder(
            kDirectory_CreateDirectory_Name,
            codec.align(Directory_CreateDirectory_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(Directory_CreateDirectory_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kDirectory_DeleteFile_Name:
      var params = reader.decodeStruct(Directory_DeleteFile_Params);
      this.deleteFile(params.path).then(function(response) {
        var responseParams =
            new Directory_DeleteFile_ResponseParams();
        responseParams.success = response.success;
        var builder = new codec.MessageV1Builder(
            kDirectory_DeleteFile_Name,
            codec.align(Directory_DeleteFile_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(Directory_DeleteFile_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kDirectory_DeletePathRecursively_Name:
      var params = reader.decodeStruct(Directory_DeletePathRecursively_Params);
      this.deletePathRecursively(params.path).then(function(response) {
        var responseParams =
            new Directory_DeletePathRecursively_ResponseParams();
        responseParams.success = response.success;
        var builder = new codec.MessageV1Builder(
            kDirectory_DeletePathRecursively_Name,
            codec.align(Directory_DeletePathRecursively_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(Directory_DeletePathRecursively_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kDirectory_GetFileInfo_Name:
      var params = reader.decodeStruct(Directory_GetFileInfo_Params);
      this.getFileInfo(params.path).then(function(response) {
        var responseParams =
            new Directory_GetFileInfo_ResponseParams();
        responseParams.info = response.info;
        var builder = new codec.MessageV1Builder(
            kDirectory_GetFileInfo_Name,
            codec.align(Directory_GetFileInfo_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(Directory_GetFileInfo_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kDirectory_GetPathAccess_Name:
      var params = reader.decodeStruct(Directory_GetPathAccess_Params);
      this.getPathAccess(params.path).then(function(response) {
        var responseParams =
            new Directory_GetPathAccess_ResponseParams();
        responseParams.info = response.info;
        var builder = new codec.MessageV1Builder(
            kDirectory_GetPathAccess_Name,
            codec.align(Directory_GetPathAccess_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(Directory_GetPathAccess_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kDirectory_GetMaximumPathComponentLength_Name:
      var params = reader.decodeStruct(Directory_GetMaximumPathComponentLength_Params);
      this.getMaximumPathComponentLength(params.path).then(function(response) {
        var responseParams =
            new Directory_GetMaximumPathComponentLength_ResponseParams();
        responseParams.success = response.success;
        responseParams.length = response.length;
        var builder = new codec.MessageV1Builder(
            kDirectory_GetMaximumPathComponentLength_Name,
            codec.align(Directory_GetMaximumPathComponentLength_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(Directory_GetMaximumPathComponentLength_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kDirectory_RenameFile_Name:
      var params = reader.decodeStruct(Directory_RenameFile_Params);
      this.renameFile(params.oldPath, params.newPath).then(function(response) {
        var responseParams =
            new Directory_RenameFile_ResponseParams();
        responseParams.error = response.error;
        var builder = new codec.MessageV1Builder(
            kDirectory_RenameFile_Name,
            codec.align(Directory_RenameFile_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(Directory_RenameFile_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kDirectory_LockFile_Name:
      var params = reader.decodeStruct(Directory_LockFile_Params);
      this.lockFile(params.path).then(function(response) {
        var responseParams =
            new Directory_LockFile_ResponseParams();
        responseParams.error = response.error;
        responseParams.lock = response.lock;
        var builder = new codec.MessageV1Builder(
            kDirectory_LockFile_Name,
            codec.align(Directory_LockFile_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(Directory_LockFile_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kDirectory_SetOpenedFileLength_Name:
      var params = reader.decodeStruct(Directory_SetOpenedFileLength_Params);
      this.setOpenedFileLength(params.file, params.size).then(function(response) {
        var responseParams =
            new Directory_SetOpenedFileLength_ResponseParams();
        responseParams.success = response.success;
        responseParams.file = response.file;
        var builder = new codec.MessageV1Builder(
            kDirectory_SetOpenedFileLength_Name,
            codec.align(Directory_SetOpenedFileLength_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(Directory_SetOpenedFileLength_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    default:
      return false;
    }
  };

  function validateDirectoryRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kDirectory_Clone_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = Directory_Clone_Params;
      break;
      case kDirectory_PathExists_Name:
        if (message.expectsResponse())
          paramsClass = Directory_PathExists_Params;
      break;
      case kDirectory_GetEntries_Name:
        if (message.expectsResponse())
          paramsClass = Directory_GetEntries_Params;
      break;
      case kDirectory_OpenFile_Name:
        if (message.expectsResponse())
          paramsClass = Directory_OpenFile_Params;
      break;
      case kDirectory_WriteFileAtomically_Name:
        if (message.expectsResponse())
          paramsClass = Directory_WriteFileAtomically_Params;
      break;
      case kDirectory_CreateDirectory_Name:
        if (message.expectsResponse())
          paramsClass = Directory_CreateDirectory_Params;
      break;
      case kDirectory_DeleteFile_Name:
        if (message.expectsResponse())
          paramsClass = Directory_DeleteFile_Params;
      break;
      case kDirectory_DeletePathRecursively_Name:
        if (message.expectsResponse())
          paramsClass = Directory_DeletePathRecursively_Params;
      break;
      case kDirectory_GetFileInfo_Name:
        if (message.expectsResponse())
          paramsClass = Directory_GetFileInfo_Params;
      break;
      case kDirectory_GetPathAccess_Name:
        if (message.expectsResponse())
          paramsClass = Directory_GetPathAccess_Params;
      break;
      case kDirectory_GetMaximumPathComponentLength_Name:
        if (message.expectsResponse())
          paramsClass = Directory_GetMaximumPathComponentLength_Params;
      break;
      case kDirectory_RenameFile_Name:
        if (message.expectsResponse())
          paramsClass = Directory_RenameFile_Params;
      break;
      case kDirectory_LockFile_Name:
        if (message.expectsResponse())
          paramsClass = Directory_LockFile_Params;
      break;
      case kDirectory_SetOpenedFileLength_Name:
        if (message.expectsResponse())
          paramsClass = Directory_SetOpenedFileLength_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateDirectoryResponse(messageValidator) {
   var message = messageValidator.message;
   var paramsClass = null;
   switch (message.getName()) {
      case kDirectory_PathExists_Name:
        if (message.isResponse())
          paramsClass = Directory_PathExists_ResponseParams;
        break;
      case kDirectory_GetEntries_Name:
        if (message.isResponse())
          paramsClass = Directory_GetEntries_ResponseParams;
        break;
      case kDirectory_OpenFile_Name:
        if (message.isResponse())
          paramsClass = Directory_OpenFile_ResponseParams;
        break;
      case kDirectory_WriteFileAtomically_Name:
        if (message.isResponse())
          paramsClass = Directory_WriteFileAtomically_ResponseParams;
        break;
      case kDirectory_CreateDirectory_Name:
        if (message.isResponse())
          paramsClass = Directory_CreateDirectory_ResponseParams;
        break;
      case kDirectory_DeleteFile_Name:
        if (message.isResponse())
          paramsClass = Directory_DeleteFile_ResponseParams;
        break;
      case kDirectory_DeletePathRecursively_Name:
        if (message.isResponse())
          paramsClass = Directory_DeletePathRecursively_ResponseParams;
        break;
      case kDirectory_GetFileInfo_Name:
        if (message.isResponse())
          paramsClass = Directory_GetFileInfo_ResponseParams;
        break;
      case kDirectory_GetPathAccess_Name:
        if (message.isResponse())
          paramsClass = Directory_GetPathAccess_ResponseParams;
        break;
      case kDirectory_GetMaximumPathComponentLength_Name:
        if (message.isResponse())
          paramsClass = Directory_GetMaximumPathComponentLength_ResponseParams;
        break;
      case kDirectory_RenameFile_Name:
        if (message.isResponse())
          paramsClass = Directory_RenameFile_ResponseParams;
        break;
      case kDirectory_LockFile_Name:
        if (message.isResponse())
          paramsClass = Directory_LockFile_ResponseParams;
        break;
      case kDirectory_SetOpenedFileLength_Name:
        if (message.isResponse())
          paramsClass = Directory_SetOpenedFileLength_ResponseParams;
        break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  var Directory = {
    name: 'storage.mojom.Directory',
    kVersion: 0,
    ptrClass: DirectoryPtr,
    proxyClass: DirectoryProxy,
    stubClass: DirectoryStub,
    validateRequest: validateDirectoryRequest,
    validateResponse: validateDirectoryResponse,
  };
  DirectoryStub.prototype.validator = validateDirectoryRequest;
  DirectoryProxy.prototype.validator = validateDirectoryResponse;
  exports.GetEntriesMode = GetEntriesMode;
  exports.FileOpenMode = FileOpenMode;
  exports.FileReadAccess = FileReadAccess;
  exports.FileWriteAccess = FileWriteAccess;
  exports.StrictRelativePath = StrictRelativePath;
  exports.PathAccessInfo = PathAccessInfo;
  exports.FileLock = FileLock;
  exports.FileLockPtr = FileLockPtr;
  exports.FileLockAssociatedPtr = FileLockAssociatedPtr;
  exports.Directory = Directory;
  exports.DirectoryPtr = DirectoryPtr;
  exports.DirectoryAssociatedPtr = DirectoryAssociatedPtr;
})();