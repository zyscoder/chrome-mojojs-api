// components/cast_streaming/common/public/mojom/demuxer_connector.mojom.js is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2014 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

(function() {
  var mojomId = 'components/cast_streaming/common/public/mojom/demuxer_connector.mojom';
  if (mojo.internal.isMojomLoaded(mojomId)) {
    console.warn('The following mojom is loaded multiple times: ' + mojomId);
    return;
  }
  mojo.internal.markMojomLoaded(mojomId);
  var bindings = mojo;
  var associatedBindings = mojo;
  var codec = mojo.internal;
  var validator = mojo.internal;

  var exports = mojo.internal.exposeNamespace('castStreaming.mojom');
  var media_types$ =
      mojo.internal.exposeNamespace('media.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'media/mojo/mojom/media_types.mojom', '../../../../../media/mojo/mojom/media_types.mojom.js');
  }



  function AudioStreamInfo(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  AudioStreamInfo.prototype.initDefaults_ = function() {
    this.decoderConfig = null;
    this.dataPipe = null;
  };
  AudioStreamInfo.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  AudioStreamInfo.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate AudioStreamInfo.decoderConfig
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, media_types$.AudioDecoderConfig, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate AudioStreamInfo.dataPipe
    err = messageValidator.validateHandle(offset + codec.kStructHeaderSize + 8, false)
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  AudioStreamInfo.encodedSize = codec.kStructHeaderSize + 16;

  AudioStreamInfo.decode = function(decoder) {
    var packed;
    var val = new AudioStreamInfo();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.decoderConfig =
        decoder.decodeStructPointer(media_types$.AudioDecoderConfig);
    val.dataPipe =
        decoder.decodeStruct(codec.Handle);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  AudioStreamInfo.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(AudioStreamInfo.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(media_types$.AudioDecoderConfig, val.decoderConfig);
    encoder.encodeStruct(codec.Handle, val.dataPipe);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function VideoStreamInfo(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  VideoStreamInfo.prototype.initDefaults_ = function() {
    this.decoderConfig = null;
    this.dataPipe = null;
  };
  VideoStreamInfo.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  VideoStreamInfo.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoStreamInfo.decoderConfig
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, media_types$.VideoDecoderConfig, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoStreamInfo.dataPipe
    err = messageValidator.validateHandle(offset + codec.kStructHeaderSize + 8, false)
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  VideoStreamInfo.encodedSize = codec.kStructHeaderSize + 16;

  VideoStreamInfo.decode = function(decoder) {
    var packed;
    var val = new VideoStreamInfo();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.decoderConfig =
        decoder.decodeStructPointer(media_types$.VideoDecoderConfig);
    val.dataPipe =
        decoder.decodeStruct(codec.Handle);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  VideoStreamInfo.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(VideoStreamInfo.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(media_types$.VideoDecoderConfig, val.decoderConfig);
    encoder.encodeStruct(codec.Handle, val.dataPipe);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function AudioStreamInitializationInfo(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  AudioStreamInitializationInfo.prototype.initDefaults_ = function() {
    this.bufferRequester = new AudioBufferRequesterPtr();
    this.streamInitializationInfo = null;
  };
  AudioStreamInitializationInfo.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  AudioStreamInitializationInfo.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate AudioStreamInitializationInfo.bufferRequester
    err = messageValidator.validateInterface(offset + codec.kStructHeaderSize + 0, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate AudioStreamInitializationInfo.streamInitializationInfo
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, AudioStreamInfo, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  AudioStreamInitializationInfo.encodedSize = codec.kStructHeaderSize + 16;

  AudioStreamInitializationInfo.decode = function(decoder) {
    var packed;
    var val = new AudioStreamInitializationInfo();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.bufferRequester =
        decoder.decodeStruct(new codec.Interface(AudioBufferRequesterPtr));
    val.streamInitializationInfo =
        decoder.decodeStructPointer(AudioStreamInfo);
    return val;
  };

  AudioStreamInitializationInfo.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(AudioStreamInitializationInfo.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(new codec.Interface(AudioBufferRequesterPtr), val.bufferRequester);
    encoder.encodeStructPointer(AudioStreamInfo, val.streamInitializationInfo);
  };
  function VideoStreamInitializationInfo(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  VideoStreamInitializationInfo.prototype.initDefaults_ = function() {
    this.bufferRequester = new VideoBufferRequesterPtr();
    this.streamInitializationInfo = null;
  };
  VideoStreamInitializationInfo.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  VideoStreamInitializationInfo.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoStreamInitializationInfo.bufferRequester
    err = messageValidator.validateInterface(offset + codec.kStructHeaderSize + 0, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoStreamInitializationInfo.streamInitializationInfo
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, VideoStreamInfo, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  VideoStreamInitializationInfo.encodedSize = codec.kStructHeaderSize + 16;

  VideoStreamInitializationInfo.decode = function(decoder) {
    var packed;
    var val = new VideoStreamInitializationInfo();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.bufferRequester =
        decoder.decodeStruct(new codec.Interface(VideoBufferRequesterPtr));
    val.streamInitializationInfo =
        decoder.decodeStructPointer(VideoStreamInfo);
    return val;
  };

  VideoStreamInitializationInfo.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(VideoStreamInitializationInfo.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(new codec.Interface(VideoBufferRequesterPtr), val.bufferRequester);
    encoder.encodeStructPointer(VideoStreamInfo, val.streamInitializationInfo);
  };
  function AudioBufferRequester_GetBuffer_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  AudioBufferRequester_GetBuffer_Params.prototype.initDefaults_ = function() {
  };
  AudioBufferRequester_GetBuffer_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  AudioBufferRequester_GetBuffer_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  AudioBufferRequester_GetBuffer_Params.encodedSize = codec.kStructHeaderSize + 0;

  AudioBufferRequester_GetBuffer_Params.decode = function(decoder) {
    var packed;
    var val = new AudioBufferRequester_GetBuffer_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  AudioBufferRequester_GetBuffer_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(AudioBufferRequester_GetBuffer_Params.encodedSize);
    encoder.writeUint32(0);
  };
  function AudioBufferRequester_GetBuffer_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  AudioBufferRequester_GetBuffer_ResponseParams.prototype.initDefaults_ = function() {
    this.bufferResponse = null;
  };
  AudioBufferRequester_GetBuffer_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  AudioBufferRequester_GetBuffer_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate AudioBufferRequester_GetBuffer_ResponseParams.bufferResponse
    err = messageValidator.validateUnion(offset + codec.kStructHeaderSize + 0, GetAudioBufferResponse, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  AudioBufferRequester_GetBuffer_ResponseParams.encodedSize = codec.kStructHeaderSize + 16;

  AudioBufferRequester_GetBuffer_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new AudioBufferRequester_GetBuffer_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.bufferResponse =
        decoder.decodeStruct(GetAudioBufferResponse);
    return val;
  };

  AudioBufferRequester_GetBuffer_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(AudioBufferRequester_GetBuffer_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(GetAudioBufferResponse, val.bufferResponse);
  };
  function AudioBufferRequester_EnableBitstreamConverter_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  AudioBufferRequester_EnableBitstreamConverter_Params.prototype.initDefaults_ = function() {
  };
  AudioBufferRequester_EnableBitstreamConverter_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  AudioBufferRequester_EnableBitstreamConverter_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  AudioBufferRequester_EnableBitstreamConverter_Params.encodedSize = codec.kStructHeaderSize + 0;

  AudioBufferRequester_EnableBitstreamConverter_Params.decode = function(decoder) {
    var packed;
    var val = new AudioBufferRequester_EnableBitstreamConverter_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  AudioBufferRequester_EnableBitstreamConverter_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(AudioBufferRequester_EnableBitstreamConverter_Params.encodedSize);
    encoder.writeUint32(0);
  };
  function AudioBufferRequester_EnableBitstreamConverter_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  AudioBufferRequester_EnableBitstreamConverter_ResponseParams.prototype.initDefaults_ = function() {
    this.success = false;
  };
  AudioBufferRequester_EnableBitstreamConverter_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  AudioBufferRequester_EnableBitstreamConverter_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  AudioBufferRequester_EnableBitstreamConverter_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  AudioBufferRequester_EnableBitstreamConverter_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new AudioBufferRequester_EnableBitstreamConverter_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    packed = decoder.readUint8();
    val.success = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  AudioBufferRequester_EnableBitstreamConverter_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(AudioBufferRequester_EnableBitstreamConverter_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    packed = 0;
    packed |= (val.success & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function VideoBufferRequester_GetBuffer_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  VideoBufferRequester_GetBuffer_Params.prototype.initDefaults_ = function() {
  };
  VideoBufferRequester_GetBuffer_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  VideoBufferRequester_GetBuffer_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  VideoBufferRequester_GetBuffer_Params.encodedSize = codec.kStructHeaderSize + 0;

  VideoBufferRequester_GetBuffer_Params.decode = function(decoder) {
    var packed;
    var val = new VideoBufferRequester_GetBuffer_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  VideoBufferRequester_GetBuffer_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(VideoBufferRequester_GetBuffer_Params.encodedSize);
    encoder.writeUint32(0);
  };
  function VideoBufferRequester_GetBuffer_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  VideoBufferRequester_GetBuffer_ResponseParams.prototype.initDefaults_ = function() {
    this.bufferResponse = null;
  };
  VideoBufferRequester_GetBuffer_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  VideoBufferRequester_GetBuffer_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoBufferRequester_GetBuffer_ResponseParams.bufferResponse
    err = messageValidator.validateUnion(offset + codec.kStructHeaderSize + 0, GetVideoBufferResponse, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  VideoBufferRequester_GetBuffer_ResponseParams.encodedSize = codec.kStructHeaderSize + 16;

  VideoBufferRequester_GetBuffer_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new VideoBufferRequester_GetBuffer_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.bufferResponse =
        decoder.decodeStruct(GetVideoBufferResponse);
    return val;
  };

  VideoBufferRequester_GetBuffer_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(VideoBufferRequester_GetBuffer_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(GetVideoBufferResponse, val.bufferResponse);
  };
  function VideoBufferRequester_EnableBitstreamConverter_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  VideoBufferRequester_EnableBitstreamConverter_Params.prototype.initDefaults_ = function() {
  };
  VideoBufferRequester_EnableBitstreamConverter_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  VideoBufferRequester_EnableBitstreamConverter_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  VideoBufferRequester_EnableBitstreamConverter_Params.encodedSize = codec.kStructHeaderSize + 0;

  VideoBufferRequester_EnableBitstreamConverter_Params.decode = function(decoder) {
    var packed;
    var val = new VideoBufferRequester_EnableBitstreamConverter_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  VideoBufferRequester_EnableBitstreamConverter_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(VideoBufferRequester_EnableBitstreamConverter_Params.encodedSize);
    encoder.writeUint32(0);
  };
  function VideoBufferRequester_EnableBitstreamConverter_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  VideoBufferRequester_EnableBitstreamConverter_ResponseParams.prototype.initDefaults_ = function() {
    this.success = false;
  };
  VideoBufferRequester_EnableBitstreamConverter_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  VideoBufferRequester_EnableBitstreamConverter_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  VideoBufferRequester_EnableBitstreamConverter_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  VideoBufferRequester_EnableBitstreamConverter_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new VideoBufferRequester_EnableBitstreamConverter_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    packed = decoder.readUint8();
    val.success = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  VideoBufferRequester_EnableBitstreamConverter_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(VideoBufferRequester_EnableBitstreamConverter_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    packed = 0;
    packed |= (val.success & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function DemuxerConnector_EnableReceiver_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  DemuxerConnector_EnableReceiver_Params.prototype.initDefaults_ = function() {
  };
  DemuxerConnector_EnableReceiver_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  DemuxerConnector_EnableReceiver_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  DemuxerConnector_EnableReceiver_Params.encodedSize = codec.kStructHeaderSize + 0;

  DemuxerConnector_EnableReceiver_Params.decode = function(decoder) {
    var packed;
    var val = new DemuxerConnector_EnableReceiver_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  DemuxerConnector_EnableReceiver_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(DemuxerConnector_EnableReceiver_Params.encodedSize);
    encoder.writeUint32(0);
  };
  function DemuxerConnector_EnableReceiver_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  DemuxerConnector_EnableReceiver_ResponseParams.prototype.initDefaults_ = function() {
  };
  DemuxerConnector_EnableReceiver_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  DemuxerConnector_EnableReceiver_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  DemuxerConnector_EnableReceiver_ResponseParams.encodedSize = codec.kStructHeaderSize + 0;

  DemuxerConnector_EnableReceiver_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new DemuxerConnector_EnableReceiver_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  DemuxerConnector_EnableReceiver_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(DemuxerConnector_EnableReceiver_ResponseParams.encodedSize);
    encoder.writeUint32(0);
  };
  function DemuxerConnector_OnStreamsInitialized_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  DemuxerConnector_OnStreamsInitialized_Params.prototype.initDefaults_ = function() {
    this.audioBufferRequester = null;
    this.videoBufferRequester = null;
  };
  DemuxerConnector_OnStreamsInitialized_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  DemuxerConnector_OnStreamsInitialized_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate DemuxerConnector_OnStreamsInitialized_Params.audioBufferRequester
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, AudioStreamInitializationInfo, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate DemuxerConnector_OnStreamsInitialized_Params.videoBufferRequester
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, VideoStreamInitializationInfo, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  DemuxerConnector_OnStreamsInitialized_Params.encodedSize = codec.kStructHeaderSize + 16;

  DemuxerConnector_OnStreamsInitialized_Params.decode = function(decoder) {
    var packed;
    var val = new DemuxerConnector_OnStreamsInitialized_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.audioBufferRequester =
        decoder.decodeStructPointer(AudioStreamInitializationInfo);
    val.videoBufferRequester =
        decoder.decodeStructPointer(VideoStreamInitializationInfo);
    return val;
  };

  DemuxerConnector_OnStreamsInitialized_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(DemuxerConnector_OnStreamsInitialized_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(AudioStreamInitializationInfo, val.audioBufferRequester);
    encoder.encodeStructPointer(VideoStreamInitializationInfo, val.videoBufferRequester);
  };

  function GetAudioBufferResponse(value) {
    this.initDefault_();
    this.initValue_(value);
  }


  GetAudioBufferResponse.Tags = {
    streamInfo: 0,
    buffer: 1,
  };

  GetAudioBufferResponse.prototype.initDefault_ = function() {
    this.$data = null;
    this.$tag = undefined;
  }

  GetAudioBufferResponse.prototype.initValue_ = function(value) {
    if (value == undefined) {
      return;
    }

    var keys = Object.keys(value);
    if (keys.length == 0) {
      return;
    }

    if (keys.length > 1) {
      throw new TypeError("You may set only one member on a union.");
    }

    var fields = [
        "streamInfo",
        "buffer",
    ];

    if (fields.indexOf(keys[0]) < 0) {
      throw new ReferenceError(keys[0] + " is not a GetAudioBufferResponse member.");

    }

    this[keys[0]] = value[keys[0]];
  }
  Object.defineProperty(GetAudioBufferResponse.prototype, "streamInfo", {
    get: function() {
      if (this.$tag != GetAudioBufferResponse.Tags.streamInfo) {
        throw new ReferenceError(
            "GetAudioBufferResponse.streamInfo is not currently set.");
      }
      return this.$data;
    },

    set: function(value) {
      this.$tag = GetAudioBufferResponse.Tags.streamInfo;
      this.$data = value;
    }
  });
  Object.defineProperty(GetAudioBufferResponse.prototype, "buffer", {
    get: function() {
      if (this.$tag != GetAudioBufferResponse.Tags.buffer) {
        throw new ReferenceError(
            "GetAudioBufferResponse.buffer is not currently set.");
      }
      return this.$data;
    },

    set: function(value) {
      this.$tag = GetAudioBufferResponse.Tags.buffer;
      this.$data = value;
    }
  });


    GetAudioBufferResponse.encode = function(encoder, val) {
      if (val == null) {
        encoder.writeUint64(0);
        encoder.writeUint64(0);
        return;
      }
      if (val.$tag == undefined) {
        throw new TypeError("Cannot encode unions with an unknown member set.");
      }

      encoder.writeUint32(16);
      encoder.writeUint32(val.$tag);
      switch (val.$tag) {
        case GetAudioBufferResponse.Tags.streamInfo:
          encoder.encodeStructPointer(AudioStreamInfo, val.streamInfo);
          break;
        case GetAudioBufferResponse.Tags.buffer:
          encoder.encodeStructPointer(media_types$.DecoderBuffer, val.buffer);
          break;
      }
      encoder.align();
    };


    GetAudioBufferResponse.decode = function(decoder) {
      var size = decoder.readUint32();
      if (size == 0) {
        decoder.readUint32();
        decoder.readUint64();
        return null;
      }

      var result = new GetAudioBufferResponse();
      var tag = decoder.readUint32();
      switch (tag) {
        case GetAudioBufferResponse.Tags.streamInfo:
          result.streamInfo = decoder.decodeStructPointer(AudioStreamInfo);
          break;
        case GetAudioBufferResponse.Tags.buffer:
          result.buffer = decoder.decodeStructPointer(media_types$.DecoderBuffer);
          break;
      }
      decoder.align();

      return result;
    };


    GetAudioBufferResponse.validate = function(messageValidator, offset) {
      var size = messageValidator.decodeUnionSize(offset);
      if (size != 16) {
        return validator.validationError.INVALID_UNION_SIZE;
      }

      var tag = messageValidator.decodeUnionTag(offset);
      var data_offset = offset + 8;
      var err;
      switch (tag) {
        case GetAudioBufferResponse.Tags.streamInfo:
          

    // validate GetAudioBufferResponse.streamInfo
    err = messageValidator.validateStructPointer(data_offset, AudioStreamInfo, false);
    if (err !== validator.validationError.NONE)
        return err;
          break;
        case GetAudioBufferResponse.Tags.buffer:
          

    // validate GetAudioBufferResponse.buffer
    err = messageValidator.validateStructPointer(data_offset, media_types$.DecoderBuffer, false);
    if (err !== validator.validationError.NONE)
        return err;
          break;
      }

      return validator.validationError.NONE;
    };

  GetAudioBufferResponse.encodedSize = 16;

  function GetVideoBufferResponse(value) {
    this.initDefault_();
    this.initValue_(value);
  }


  GetVideoBufferResponse.Tags = {
    streamInfo: 0,
    buffer: 1,
  };

  GetVideoBufferResponse.prototype.initDefault_ = function() {
    this.$data = null;
    this.$tag = undefined;
  }

  GetVideoBufferResponse.prototype.initValue_ = function(value) {
    if (value == undefined) {
      return;
    }

    var keys = Object.keys(value);
    if (keys.length == 0) {
      return;
    }

    if (keys.length > 1) {
      throw new TypeError("You may set only one member on a union.");
    }

    var fields = [
        "streamInfo",
        "buffer",
    ];

    if (fields.indexOf(keys[0]) < 0) {
      throw new ReferenceError(keys[0] + " is not a GetVideoBufferResponse member.");

    }

    this[keys[0]] = value[keys[0]];
  }
  Object.defineProperty(GetVideoBufferResponse.prototype, "streamInfo", {
    get: function() {
      if (this.$tag != GetVideoBufferResponse.Tags.streamInfo) {
        throw new ReferenceError(
            "GetVideoBufferResponse.streamInfo is not currently set.");
      }
      return this.$data;
    },

    set: function(value) {
      this.$tag = GetVideoBufferResponse.Tags.streamInfo;
      this.$data = value;
    }
  });
  Object.defineProperty(GetVideoBufferResponse.prototype, "buffer", {
    get: function() {
      if (this.$tag != GetVideoBufferResponse.Tags.buffer) {
        throw new ReferenceError(
            "GetVideoBufferResponse.buffer is not currently set.");
      }
      return this.$data;
    },

    set: function(value) {
      this.$tag = GetVideoBufferResponse.Tags.buffer;
      this.$data = value;
    }
  });


    GetVideoBufferResponse.encode = function(encoder, val) {
      if (val == null) {
        encoder.writeUint64(0);
        encoder.writeUint64(0);
        return;
      }
      if (val.$tag == undefined) {
        throw new TypeError("Cannot encode unions with an unknown member set.");
      }

      encoder.writeUint32(16);
      encoder.writeUint32(val.$tag);
      switch (val.$tag) {
        case GetVideoBufferResponse.Tags.streamInfo:
          encoder.encodeStructPointer(VideoStreamInfo, val.streamInfo);
          break;
        case GetVideoBufferResponse.Tags.buffer:
          encoder.encodeStructPointer(media_types$.DecoderBuffer, val.buffer);
          break;
      }
      encoder.align();
    };


    GetVideoBufferResponse.decode = function(decoder) {
      var size = decoder.readUint32();
      if (size == 0) {
        decoder.readUint32();
        decoder.readUint64();
        return null;
      }

      var result = new GetVideoBufferResponse();
      var tag = decoder.readUint32();
      switch (tag) {
        case GetVideoBufferResponse.Tags.streamInfo:
          result.streamInfo = decoder.decodeStructPointer(VideoStreamInfo);
          break;
        case GetVideoBufferResponse.Tags.buffer:
          result.buffer = decoder.decodeStructPointer(media_types$.DecoderBuffer);
          break;
      }
      decoder.align();

      return result;
    };


    GetVideoBufferResponse.validate = function(messageValidator, offset) {
      var size = messageValidator.decodeUnionSize(offset);
      if (size != 16) {
        return validator.validationError.INVALID_UNION_SIZE;
      }

      var tag = messageValidator.decodeUnionTag(offset);
      var data_offset = offset + 8;
      var err;
      switch (tag) {
        case GetVideoBufferResponse.Tags.streamInfo:
          

    // validate GetVideoBufferResponse.streamInfo
    err = messageValidator.validateStructPointer(data_offset, VideoStreamInfo, false);
    if (err !== validator.validationError.NONE)
        return err;
          break;
        case GetVideoBufferResponse.Tags.buffer:
          

    // validate GetVideoBufferResponse.buffer
    err = messageValidator.validateStructPointer(data_offset, media_types$.DecoderBuffer, false);
    if (err !== validator.validationError.NONE)
        return err;
          break;
      }

      return validator.validationError.NONE;
    };

  GetVideoBufferResponse.encodedSize = 16;
  var kAudioBufferRequester_GetBuffer_Name = 1164917357;
  var kAudioBufferRequester_EnableBitstreamConverter_Name = 1996059551;

  function AudioBufferRequesterPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(AudioBufferRequester,
                                                   handleOrPtrInfo);
  }

  function AudioBufferRequesterAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        AudioBufferRequester, associatedInterfacePtrInfo);
  }

  AudioBufferRequesterAssociatedPtr.prototype =
      Object.create(AudioBufferRequesterPtr.prototype);
  AudioBufferRequesterAssociatedPtr.prototype.constructor =
      AudioBufferRequesterAssociatedPtr;

  function AudioBufferRequesterProxy(receiver) {
    this.receiver_ = receiver;
  }
  AudioBufferRequesterPtr.prototype.getBuffer = function() {
    return AudioBufferRequesterProxy.prototype.getBuffer
        .apply(this.ptr.getProxy(), arguments);
  };

  AudioBufferRequesterProxy.prototype.getBuffer = function() {
    var params_ = new AudioBufferRequester_GetBuffer_Params();
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kAudioBufferRequester_GetBuffer_Name,
          codec.align(AudioBufferRequester_GetBuffer_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(AudioBufferRequester_GetBuffer_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(AudioBufferRequester_GetBuffer_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  AudioBufferRequesterPtr.prototype.enableBitstreamConverter = function() {
    return AudioBufferRequesterProxy.prototype.enableBitstreamConverter
        .apply(this.ptr.getProxy(), arguments);
  };

  AudioBufferRequesterProxy.prototype.enableBitstreamConverter = function() {
    var params_ = new AudioBufferRequester_EnableBitstreamConverter_Params();
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kAudioBufferRequester_EnableBitstreamConverter_Name,
          codec.align(AudioBufferRequester_EnableBitstreamConverter_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(AudioBufferRequester_EnableBitstreamConverter_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(AudioBufferRequester_EnableBitstreamConverter_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };

  function AudioBufferRequesterStub(delegate) {
    this.delegate_ = delegate;
  }
  AudioBufferRequesterStub.prototype.getBuffer = function() {
    return this.delegate_ && this.delegate_.getBuffer && this.delegate_.getBuffer();
  }
  AudioBufferRequesterStub.prototype.enableBitstreamConverter = function() {
    return this.delegate_ && this.delegate_.enableBitstreamConverter && this.delegate_.enableBitstreamConverter();
  }

  AudioBufferRequesterStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  AudioBufferRequesterStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kAudioBufferRequester_GetBuffer_Name:
      var params = reader.decodeStruct(AudioBufferRequester_GetBuffer_Params);
      this.getBuffer().then(function(response) {
        var responseParams =
            new AudioBufferRequester_GetBuffer_ResponseParams();
        responseParams.bufferResponse = response.bufferResponse;
        var builder = new codec.MessageV1Builder(
            kAudioBufferRequester_GetBuffer_Name,
            codec.align(AudioBufferRequester_GetBuffer_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(AudioBufferRequester_GetBuffer_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kAudioBufferRequester_EnableBitstreamConverter_Name:
      var params = reader.decodeStruct(AudioBufferRequester_EnableBitstreamConverter_Params);
      this.enableBitstreamConverter().then(function(response) {
        var responseParams =
            new AudioBufferRequester_EnableBitstreamConverter_ResponseParams();
        responseParams.success = response.success;
        var builder = new codec.MessageV1Builder(
            kAudioBufferRequester_EnableBitstreamConverter_Name,
            codec.align(AudioBufferRequester_EnableBitstreamConverter_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(AudioBufferRequester_EnableBitstreamConverter_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    default:
      return false;
    }
  };

  function validateAudioBufferRequesterRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kAudioBufferRequester_GetBuffer_Name:
        if (message.expectsResponse())
          paramsClass = AudioBufferRequester_GetBuffer_Params;
      break;
      case kAudioBufferRequester_EnableBitstreamConverter_Name:
        if (message.expectsResponse())
          paramsClass = AudioBufferRequester_EnableBitstreamConverter_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateAudioBufferRequesterResponse(messageValidator) {
   var message = messageValidator.message;
   var paramsClass = null;
   switch (message.getName()) {
      case kAudioBufferRequester_GetBuffer_Name:
        if (message.isResponse())
          paramsClass = AudioBufferRequester_GetBuffer_ResponseParams;
        break;
      case kAudioBufferRequester_EnableBitstreamConverter_Name:
        if (message.isResponse())
          paramsClass = AudioBufferRequester_EnableBitstreamConverter_ResponseParams;
        break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  var AudioBufferRequester = {
    name: 'cast_streaming.mojom.AudioBufferRequester',
    kVersion: 0,
    ptrClass: AudioBufferRequesterPtr,
    proxyClass: AudioBufferRequesterProxy,
    stubClass: AudioBufferRequesterStub,
    validateRequest: validateAudioBufferRequesterRequest,
    validateResponse: validateAudioBufferRequesterResponse,
  };
  AudioBufferRequesterStub.prototype.validator = validateAudioBufferRequesterRequest;
  AudioBufferRequesterProxy.prototype.validator = validateAudioBufferRequesterResponse;
  var kVideoBufferRequester_GetBuffer_Name = 471797002;
  var kVideoBufferRequester_EnableBitstreamConverter_Name = 1869119270;

  function VideoBufferRequesterPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(VideoBufferRequester,
                                                   handleOrPtrInfo);
  }

  function VideoBufferRequesterAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        VideoBufferRequester, associatedInterfacePtrInfo);
  }

  VideoBufferRequesterAssociatedPtr.prototype =
      Object.create(VideoBufferRequesterPtr.prototype);
  VideoBufferRequesterAssociatedPtr.prototype.constructor =
      VideoBufferRequesterAssociatedPtr;

  function VideoBufferRequesterProxy(receiver) {
    this.receiver_ = receiver;
  }
  VideoBufferRequesterPtr.prototype.getBuffer = function() {
    return VideoBufferRequesterProxy.prototype.getBuffer
        .apply(this.ptr.getProxy(), arguments);
  };

  VideoBufferRequesterProxy.prototype.getBuffer = function() {
    var params_ = new VideoBufferRequester_GetBuffer_Params();
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kVideoBufferRequester_GetBuffer_Name,
          codec.align(VideoBufferRequester_GetBuffer_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(VideoBufferRequester_GetBuffer_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(VideoBufferRequester_GetBuffer_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  VideoBufferRequesterPtr.prototype.enableBitstreamConverter = function() {
    return VideoBufferRequesterProxy.prototype.enableBitstreamConverter
        .apply(this.ptr.getProxy(), arguments);
  };

  VideoBufferRequesterProxy.prototype.enableBitstreamConverter = function() {
    var params_ = new VideoBufferRequester_EnableBitstreamConverter_Params();
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kVideoBufferRequester_EnableBitstreamConverter_Name,
          codec.align(VideoBufferRequester_EnableBitstreamConverter_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(VideoBufferRequester_EnableBitstreamConverter_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(VideoBufferRequester_EnableBitstreamConverter_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };

  function VideoBufferRequesterStub(delegate) {
    this.delegate_ = delegate;
  }
  VideoBufferRequesterStub.prototype.getBuffer = function() {
    return this.delegate_ && this.delegate_.getBuffer && this.delegate_.getBuffer();
  }
  VideoBufferRequesterStub.prototype.enableBitstreamConverter = function() {
    return this.delegate_ && this.delegate_.enableBitstreamConverter && this.delegate_.enableBitstreamConverter();
  }

  VideoBufferRequesterStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  VideoBufferRequesterStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kVideoBufferRequester_GetBuffer_Name:
      var params = reader.decodeStruct(VideoBufferRequester_GetBuffer_Params);
      this.getBuffer().then(function(response) {
        var responseParams =
            new VideoBufferRequester_GetBuffer_ResponseParams();
        responseParams.bufferResponse = response.bufferResponse;
        var builder = new codec.MessageV1Builder(
            kVideoBufferRequester_GetBuffer_Name,
            codec.align(VideoBufferRequester_GetBuffer_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(VideoBufferRequester_GetBuffer_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kVideoBufferRequester_EnableBitstreamConverter_Name:
      var params = reader.decodeStruct(VideoBufferRequester_EnableBitstreamConverter_Params);
      this.enableBitstreamConverter().then(function(response) {
        var responseParams =
            new VideoBufferRequester_EnableBitstreamConverter_ResponseParams();
        responseParams.success = response.success;
        var builder = new codec.MessageV1Builder(
            kVideoBufferRequester_EnableBitstreamConverter_Name,
            codec.align(VideoBufferRequester_EnableBitstreamConverter_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(VideoBufferRequester_EnableBitstreamConverter_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    default:
      return false;
    }
  };

  function validateVideoBufferRequesterRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kVideoBufferRequester_GetBuffer_Name:
        if (message.expectsResponse())
          paramsClass = VideoBufferRequester_GetBuffer_Params;
      break;
      case kVideoBufferRequester_EnableBitstreamConverter_Name:
        if (message.expectsResponse())
          paramsClass = VideoBufferRequester_EnableBitstreamConverter_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateVideoBufferRequesterResponse(messageValidator) {
   var message = messageValidator.message;
   var paramsClass = null;
   switch (message.getName()) {
      case kVideoBufferRequester_GetBuffer_Name:
        if (message.isResponse())
          paramsClass = VideoBufferRequester_GetBuffer_ResponseParams;
        break;
      case kVideoBufferRequester_EnableBitstreamConverter_Name:
        if (message.isResponse())
          paramsClass = VideoBufferRequester_EnableBitstreamConverter_ResponseParams;
        break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  var VideoBufferRequester = {
    name: 'cast_streaming.mojom.VideoBufferRequester',
    kVersion: 0,
    ptrClass: VideoBufferRequesterPtr,
    proxyClass: VideoBufferRequesterProxy,
    stubClass: VideoBufferRequesterStub,
    validateRequest: validateVideoBufferRequesterRequest,
    validateResponse: validateVideoBufferRequesterResponse,
  };
  VideoBufferRequesterStub.prototype.validator = validateVideoBufferRequesterRequest;
  VideoBufferRequesterProxy.prototype.validator = validateVideoBufferRequesterResponse;
  var kDemuxerConnector_EnableReceiver_Name = 57891390;
  var kDemuxerConnector_OnStreamsInitialized_Name = 902872897;

  function DemuxerConnectorPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(DemuxerConnector,
                                                   handleOrPtrInfo);
  }

  function DemuxerConnectorAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        DemuxerConnector, associatedInterfacePtrInfo);
  }

  DemuxerConnectorAssociatedPtr.prototype =
      Object.create(DemuxerConnectorPtr.prototype);
  DemuxerConnectorAssociatedPtr.prototype.constructor =
      DemuxerConnectorAssociatedPtr;

  function DemuxerConnectorProxy(receiver) {
    this.receiver_ = receiver;
  }
  DemuxerConnectorPtr.prototype.enableReceiver = function() {
    return DemuxerConnectorProxy.prototype.enableReceiver
        .apply(this.ptr.getProxy(), arguments);
  };

  DemuxerConnectorProxy.prototype.enableReceiver = function() {
    var params_ = new DemuxerConnector_EnableReceiver_Params();
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kDemuxerConnector_EnableReceiver_Name,
          codec.align(DemuxerConnector_EnableReceiver_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(DemuxerConnector_EnableReceiver_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(DemuxerConnector_EnableReceiver_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  DemuxerConnectorPtr.prototype.onStreamsInitialized = function() {
    return DemuxerConnectorProxy.prototype.onStreamsInitialized
        .apply(this.ptr.getProxy(), arguments);
  };

  DemuxerConnectorProxy.prototype.onStreamsInitialized = function(audioBufferRequester, videoBufferRequester) {
    var params_ = new DemuxerConnector_OnStreamsInitialized_Params();
    params_.audioBufferRequester = audioBufferRequester;
    params_.videoBufferRequester = videoBufferRequester;
    var builder = new codec.MessageV0Builder(
        kDemuxerConnector_OnStreamsInitialized_Name,
        codec.align(DemuxerConnector_OnStreamsInitialized_Params.encodedSize));
    builder.encodeStruct(DemuxerConnector_OnStreamsInitialized_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };

  function DemuxerConnectorStub(delegate) {
    this.delegate_ = delegate;
  }
  DemuxerConnectorStub.prototype.enableReceiver = function() {
    return this.delegate_ && this.delegate_.enableReceiver && this.delegate_.enableReceiver();
  }
  DemuxerConnectorStub.prototype.onStreamsInitialized = function(audioBufferRequester, videoBufferRequester) {
    return this.delegate_ && this.delegate_.onStreamsInitialized && this.delegate_.onStreamsInitialized(audioBufferRequester, videoBufferRequester);
  }

  DemuxerConnectorStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kDemuxerConnector_OnStreamsInitialized_Name:
      var params = reader.decodeStruct(DemuxerConnector_OnStreamsInitialized_Params);
      this.onStreamsInitialized(params.audioBufferRequester, params.videoBufferRequester);
      return true;
    default:
      return false;
    }
  };

  DemuxerConnectorStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kDemuxerConnector_EnableReceiver_Name:
      var params = reader.decodeStruct(DemuxerConnector_EnableReceiver_Params);
      this.enableReceiver().then(function(response) {
        var responseParams =
            new DemuxerConnector_EnableReceiver_ResponseParams();
        var builder = new codec.MessageV1Builder(
            kDemuxerConnector_EnableReceiver_Name,
            codec.align(DemuxerConnector_EnableReceiver_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(DemuxerConnector_EnableReceiver_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    default:
      return false;
    }
  };

  function validateDemuxerConnectorRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kDemuxerConnector_EnableReceiver_Name:
        if (message.expectsResponse())
          paramsClass = DemuxerConnector_EnableReceiver_Params;
      break;
      case kDemuxerConnector_OnStreamsInitialized_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = DemuxerConnector_OnStreamsInitialized_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateDemuxerConnectorResponse(messageValidator) {
   var message = messageValidator.message;
   var paramsClass = null;
   switch (message.getName()) {
      case kDemuxerConnector_EnableReceiver_Name:
        if (message.isResponse())
          paramsClass = DemuxerConnector_EnableReceiver_ResponseParams;
        break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  var DemuxerConnector = {
    name: 'cast_streaming.mojom.DemuxerConnector',
    kVersion: 0,
    ptrClass: DemuxerConnectorPtr,
    proxyClass: DemuxerConnectorProxy,
    stubClass: DemuxerConnectorStub,
    validateRequest: validateDemuxerConnectorRequest,
    validateResponse: validateDemuxerConnectorResponse,
  };
  DemuxerConnectorStub.prototype.validator = validateDemuxerConnectorRequest;
  DemuxerConnectorProxy.prototype.validator = validateDemuxerConnectorResponse;
  exports.AudioStreamInfo = AudioStreamInfo;
  exports.VideoStreamInfo = VideoStreamInfo;
  exports.AudioStreamInitializationInfo = AudioStreamInitializationInfo;
  exports.VideoStreamInitializationInfo = VideoStreamInitializationInfo;
  exports.GetAudioBufferResponse = GetAudioBufferResponse;
  exports.GetVideoBufferResponse = GetVideoBufferResponse;
  exports.AudioBufferRequester = AudioBufferRequester;
  exports.AudioBufferRequesterPtr = AudioBufferRequesterPtr;
  exports.AudioBufferRequesterAssociatedPtr = AudioBufferRequesterAssociatedPtr;
  exports.VideoBufferRequester = VideoBufferRequester;
  exports.VideoBufferRequesterPtr = VideoBufferRequesterPtr;
  exports.VideoBufferRequesterAssociatedPtr = VideoBufferRequesterAssociatedPtr;
  exports.DemuxerConnector = DemuxerConnector;
  exports.DemuxerConnectorPtr = DemuxerConnectorPtr;
  exports.DemuxerConnectorAssociatedPtr = DemuxerConnectorAssociatedPtr;
})();