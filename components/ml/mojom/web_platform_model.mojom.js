// components/ml/mojom/web_platform_model.mojom.js is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2014 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

(function() {
  var mojomId = 'components/ml/mojom/web_platform_model.mojom';
  if (mojo.internal.isMojomLoaded(mojomId)) {
    console.warn('The following mojom is loaded multiple times: ' + mojomId);
    return;
  }
  mojo.internal.markMojomLoaded(mojomId);
  var bindings = mojo;
  var associatedBindings = mojo;
  var codec = mojo.internal;
  var validator = mojo.internal;

  var exports = mojo.internal.exposeNamespace('ml.modelLoader.mojom');
  var big_buffer$ =
      mojo.internal.exposeNamespace('mojoBase.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'mojo/public/mojom/base/big_buffer.mojom', '../../../mojo/public/mojom/base/big_buffer.mojom.js');
  }


  var ModelFormat = {};
  ModelFormat.kAuto = 0;
  ModelFormat.kTfLite = 1;
  ModelFormat.MIN_VALUE = 0;
  ModelFormat.MAX_VALUE = 1;
  ModelFormat.DEFAULT_VALUE = 0;

  ModelFormat.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
      return true;
    }
    return false;
  };

  ModelFormat.toKnownEnumValue = function(value) {
    if (this.isKnownEnumValue(value))
      return value;
    return this.DEFAULT_VALUE;
  };

  ModelFormat.validate = function(enumValue) {
    const isExtensible = true;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var DevicePreference = {};
  DevicePreference.kAuto = 0;
  DevicePreference.kCpu = 1;
  DevicePreference.kGpu = 2;
  DevicePreference.MIN_VALUE = 0;
  DevicePreference.MAX_VALUE = 2;
  DevicePreference.DEFAULT_VALUE = 0;

  DevicePreference.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    }
    return false;
  };

  DevicePreference.toKnownEnumValue = function(value) {
    if (this.isKnownEnumValue(value))
      return value;
    return this.DEFAULT_VALUE;
  };

  DevicePreference.validate = function(enumValue) {
    const isExtensible = true;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var DataType = {};
  DataType.kUnknown = 0;
  DataType.kInt64 = 1;
  DataType.kUint64 = 2;
  DataType.kFloat64 = 3;
  DataType.kInt32 = 4;
  DataType.kUint32 = 5;
  DataType.kFloat32 = 6;
  DataType.kInt16 = 7;
  DataType.kUint16 = 8;
  DataType.kFloat16 = 9;
  DataType.kInt8 = 10;
  DataType.kUint8 = 11;
  DataType.kBool = 12;
  DataType.MIN_VALUE = 0;
  DataType.MAX_VALUE = 12;
  DataType.DEFAULT_VALUE = 0;

  DataType.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    }
    return false;
  };

  DataType.toKnownEnumValue = function(value) {
    if (this.isKnownEnumValue(value))
      return value;
    return this.DEFAULT_VALUE;
  };

  DataType.validate = function(enumValue) {
    const isExtensible = true;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var LoadModelResult = {};
  LoadModelResult.kOk = 0;
  LoadModelResult.kUnknownError = 1;
  LoadModelResult.kInvalidModel = 2;
  LoadModelResult.kNotSupported = 3;
  LoadModelResult.MIN_VALUE = 0;
  LoadModelResult.MAX_VALUE = 3;

  LoadModelResult.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    }
    return false;
  };

  LoadModelResult.toKnownEnumValue = function(value) {
    return value;
  };

  LoadModelResult.validate = function(enumValue) {
    const isExtensible = true;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var CreateModelLoaderResult = {};
  CreateModelLoaderResult.kOk = 0;
  CreateModelLoaderResult.kUnknownError = 1;
  CreateModelLoaderResult.kNotSupported = 2;
  CreateModelLoaderResult.MIN_VALUE = 0;
  CreateModelLoaderResult.MAX_VALUE = 2;

  CreateModelLoaderResult.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    }
    return false;
  };

  CreateModelLoaderResult.toKnownEnumValue = function(value) {
    return value;
  };

  CreateModelLoaderResult.validate = function(enumValue) {
    const isExtensible = true;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var ComputeResult = {};
  ComputeResult.kOk = 0;
  ComputeResult.kUnknownError = 1;
  ComputeResult.kModelNotLoaded = 2;
  ComputeResult.kIncorrectNumberOfInputs = 3;
  ComputeResult.kMissingInput = 4;
  ComputeResult.kInvalidInputBufferSize = 5;
  ComputeResult.MIN_VALUE = 0;
  ComputeResult.MAX_VALUE = 5;

  ComputeResult.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    }
    return false;
  };

  ComputeResult.toKnownEnumValue = function(value) {
    return value;
  };

  ComputeResult.validate = function(enumValue) {
    const isExtensible = true;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };

  function CreateModelLoaderOptions(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  CreateModelLoaderOptions.prototype.initDefaults_ = function() {
    this.numThreads = 0;
    this.modelFormat = 0;
    this.devicePreference = 0;
  };
  CreateModelLoaderOptions.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  CreateModelLoaderOptions.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    // validate CreateModelLoaderOptions.modelFormat
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 4, ModelFormat);
    if (err !== validator.validationError.NONE)
        return err;


    // validate CreateModelLoaderOptions.devicePreference
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 8, DevicePreference);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  CreateModelLoaderOptions.encodedSize = codec.kStructHeaderSize + 16;

  CreateModelLoaderOptions.decode = function(decoder) {
    var packed;
    var val = new CreateModelLoaderOptions();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.numThreads =
        decoder.decodeStruct(codec.Uint32);
    val.modelFormat =
        decoder.decodeStruct(new codec.Enum(ModelFormat));
    val.devicePreference =
        decoder.decodeStruct(new codec.Enum(DevicePreference));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  CreateModelLoaderOptions.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(CreateModelLoaderOptions.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint32, val.numThreads);
    encoder.encodeStruct(codec.Int32, val.modelFormat);
    encoder.encodeStruct(codec.Int32, val.devicePreference);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function TensorInfo(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  TensorInfo.prototype.initDefaults_ = function() {
    this.byteSize = 0;
    this.dataType = 0;
    this.dimensions = null;
  };
  TensorInfo.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  TensorInfo.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    // validate TensorInfo.dataType
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 4, DataType);
    if (err !== validator.validationError.NONE)
        return err;


    // validate TensorInfo.dimensions
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 8, 4, codec.Uint32, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  TensorInfo.encodedSize = codec.kStructHeaderSize + 16;

  TensorInfo.decode = function(decoder) {
    var packed;
    var val = new TensorInfo();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.byteSize =
        decoder.decodeStruct(codec.Uint32);
    val.dataType =
        decoder.decodeStruct(new codec.Enum(DataType));
    val.dimensions =
        decoder.decodeArrayPointer(codec.Uint32);
    return val;
  };

  TensorInfo.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(TensorInfo.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint32, val.byteSize);
    encoder.encodeStruct(codec.Int32, val.dataType);
    encoder.encodeArrayPointer(codec.Uint32, val.dimensions);
  };
  function ModelInfo(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ModelInfo.prototype.initDefaults_ = function() {
    this.inputTensorInfo = null;
    this.outputTensorInfo = null;
  };
  ModelInfo.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ModelInfo.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ModelInfo.inputTensorInfo
    err = messageValidator.validateMapPointer(offset + codec.kStructHeaderSize + 0, false, codec.String, new codec.PointerTo(TensorInfo), false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ModelInfo.outputTensorInfo
    err = messageValidator.validateMapPointer(offset + codec.kStructHeaderSize + 8, false, codec.String, new codec.PointerTo(TensorInfo), false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ModelInfo.encodedSize = codec.kStructHeaderSize + 16;

  ModelInfo.decode = function(decoder) {
    var packed;
    var val = new ModelInfo();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.inputTensorInfo =
        decoder.decodeMapPointer(codec.String, new codec.PointerTo(TensorInfo));
    val.outputTensorInfo =
        decoder.decodeMapPointer(codec.String, new codec.PointerTo(TensorInfo));
    return val;
  };

  ModelInfo.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ModelInfo.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeMapPointer(codec.String, new codec.PointerTo(TensorInfo), val.inputTensorInfo);
    encoder.encodeMapPointer(codec.String, new codec.PointerTo(TensorInfo), val.outputTensorInfo);
  };
  function ModelLoader_Load_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ModelLoader_Load_Params.prototype.initDefaults_ = function() {
    this.modelContent = null;
  };
  ModelLoader_Load_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ModelLoader_Load_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ModelLoader_Load_Params.modelContent
    err = messageValidator.validateUnion(offset + codec.kStructHeaderSize + 0, big_buffer$.BigBuffer, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ModelLoader_Load_Params.encodedSize = codec.kStructHeaderSize + 16;

  ModelLoader_Load_Params.decode = function(decoder) {
    var packed;
    var val = new ModelLoader_Load_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.modelContent =
        decoder.decodeStruct(big_buffer$.BigBuffer);
    return val;
  };

  ModelLoader_Load_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ModelLoader_Load_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(big_buffer$.BigBuffer, val.modelContent);
  };
  function ModelLoader_Load_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ModelLoader_Load_ResponseParams.prototype.initDefaults_ = function() {
    this.result = 0;
    this.remote = new ModelPtr();
    this.modelInfo = null;
  };
  ModelLoader_Load_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ModelLoader_Load_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 32}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ModelLoader_Load_ResponseParams.result
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, LoadModelResult);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ModelLoader_Load_ResponseParams.remote
    err = messageValidator.validateInterface(offset + codec.kStructHeaderSize + 4, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ModelLoader_Load_ResponseParams.modelInfo
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, ModelInfo, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ModelLoader_Load_ResponseParams.encodedSize = codec.kStructHeaderSize + 24;

  ModelLoader_Load_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new ModelLoader_Load_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.result =
        decoder.decodeStruct(new codec.Enum(LoadModelResult));
    val.remote =
        decoder.decodeStruct(new codec.NullableInterface(ModelPtr));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.modelInfo =
        decoder.decodeStructPointer(ModelInfo);
    return val;
  };

  ModelLoader_Load_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ModelLoader_Load_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.result);
    encoder.encodeStruct(new codec.NullableInterface(ModelPtr), val.remote);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStructPointer(ModelInfo, val.modelInfo);
  };
  function Model_Compute_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Model_Compute_Params.prototype.initDefaults_ = function() {
    this.inputTensors = null;
  };
  Model_Compute_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Model_Compute_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Model_Compute_Params.inputTensors
    err = messageValidator.validateMapPointer(offset + codec.kStructHeaderSize + 0, false, codec.String, new codec.ArrayOf(codec.Uint8), false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Model_Compute_Params.encodedSize = codec.kStructHeaderSize + 8;

  Model_Compute_Params.decode = function(decoder) {
    var packed;
    var val = new Model_Compute_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.inputTensors =
        decoder.decodeMapPointer(codec.String, new codec.ArrayOf(codec.Uint8));
    return val;
  };

  Model_Compute_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Model_Compute_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeMapPointer(codec.String, new codec.ArrayOf(codec.Uint8), val.inputTensors);
  };
  function Model_Compute_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Model_Compute_ResponseParams.prototype.initDefaults_ = function() {
    this.result = 0;
    this.outputTensors = null;
  };
  Model_Compute_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Model_Compute_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Model_Compute_ResponseParams.result
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, ComputeResult);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Model_Compute_ResponseParams.outputTensors
    err = messageValidator.validateMapPointer(offset + codec.kStructHeaderSize + 8, true, codec.String, new codec.ArrayOf(codec.Uint8), false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Model_Compute_ResponseParams.encodedSize = codec.kStructHeaderSize + 16;

  Model_Compute_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new Model_Compute_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.result =
        decoder.decodeStruct(new codec.Enum(ComputeResult));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.outputTensors =
        decoder.decodeMapPointer(codec.String, new codec.ArrayOf(codec.Uint8));
    return val;
  };

  Model_Compute_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Model_Compute_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.result);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeMapPointer(codec.String, new codec.ArrayOf(codec.Uint8), val.outputTensors);
  };
  var kModelLoader_Load_Name = 0;

  function ModelLoaderPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(ModelLoader,
                                                   handleOrPtrInfo);
  }

  function ModelLoaderAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        ModelLoader, associatedInterfacePtrInfo);
  }

  ModelLoaderAssociatedPtr.prototype =
      Object.create(ModelLoaderPtr.prototype);
  ModelLoaderAssociatedPtr.prototype.constructor =
      ModelLoaderAssociatedPtr;

  function ModelLoaderProxy(receiver) {
    this.receiver_ = receiver;
  }
  ModelLoaderPtr.prototype.load = function() {
    return ModelLoaderProxy.prototype.load
        .apply(this.ptr.getProxy(), arguments);
  };

  ModelLoaderProxy.prototype.load = function(modelContent) {
    var params_ = new ModelLoader_Load_Params();
    params_.modelContent = modelContent;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kModelLoader_Load_Name,
          codec.align(ModelLoader_Load_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(ModelLoader_Load_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(ModelLoader_Load_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };

  function ModelLoaderStub(delegate) {
    this.delegate_ = delegate;
  }
  ModelLoaderStub.prototype.load = function(modelContent) {
    return this.delegate_ && this.delegate_.load && this.delegate_.load(modelContent);
  }

  ModelLoaderStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  ModelLoaderStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kModelLoader_Load_Name:
      var params = reader.decodeStruct(ModelLoader_Load_Params);
      this.load(params.modelContent).then(function(response) {
        var responseParams =
            new ModelLoader_Load_ResponseParams();
        responseParams.result = response.result;
        responseParams.remote = response.remote;
        responseParams.modelInfo = response.modelInfo;
        var builder = new codec.MessageV1Builder(
            kModelLoader_Load_Name,
            codec.align(ModelLoader_Load_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(ModelLoader_Load_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    default:
      return false;
    }
  };

  function validateModelLoaderRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kModelLoader_Load_Name:
        if (message.expectsResponse())
          paramsClass = ModelLoader_Load_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateModelLoaderResponse(messageValidator) {
   var message = messageValidator.message;
   var paramsClass = null;
   switch (message.getName()) {
      case kModelLoader_Load_Name:
        if (message.isResponse())
          paramsClass = ModelLoader_Load_ResponseParams;
        break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  var ModelLoader = {
    name: 'ml.model_loader.mojom.ModelLoader',
    kVersion: 0,
    ptrClass: ModelLoaderPtr,
    proxyClass: ModelLoaderProxy,
    stubClass: ModelLoaderStub,
    validateRequest: validateModelLoaderRequest,
    validateResponse: validateModelLoaderResponse,
  };
  ModelLoaderStub.prototype.validator = validateModelLoaderRequest;
  ModelLoaderProxy.prototype.validator = validateModelLoaderResponse;
  var kModel_Compute_Name = 0;

  function ModelPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(Model,
                                                   handleOrPtrInfo);
  }

  function ModelAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        Model, associatedInterfacePtrInfo);
  }

  ModelAssociatedPtr.prototype =
      Object.create(ModelPtr.prototype);
  ModelAssociatedPtr.prototype.constructor =
      ModelAssociatedPtr;

  function ModelProxy(receiver) {
    this.receiver_ = receiver;
  }
  ModelPtr.prototype.compute = function() {
    return ModelProxy.prototype.compute
        .apply(this.ptr.getProxy(), arguments);
  };

  ModelProxy.prototype.compute = function(inputTensors) {
    var params_ = new Model_Compute_Params();
    params_.inputTensors = inputTensors;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kModel_Compute_Name,
          codec.align(Model_Compute_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(Model_Compute_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(Model_Compute_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };

  function ModelStub(delegate) {
    this.delegate_ = delegate;
  }
  ModelStub.prototype.compute = function(inputTensors) {
    return this.delegate_ && this.delegate_.compute && this.delegate_.compute(inputTensors);
  }

  ModelStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  ModelStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kModel_Compute_Name:
      var params = reader.decodeStruct(Model_Compute_Params);
      this.compute(params.inputTensors).then(function(response) {
        var responseParams =
            new Model_Compute_ResponseParams();
        responseParams.result = response.result;
        responseParams.outputTensors = response.outputTensors;
        var builder = new codec.MessageV1Builder(
            kModel_Compute_Name,
            codec.align(Model_Compute_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(Model_Compute_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    default:
      return false;
    }
  };

  function validateModelRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kModel_Compute_Name:
        if (message.expectsResponse())
          paramsClass = Model_Compute_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateModelResponse(messageValidator) {
   var message = messageValidator.message;
   var paramsClass = null;
   switch (message.getName()) {
      case kModel_Compute_Name:
        if (message.isResponse())
          paramsClass = Model_Compute_ResponseParams;
        break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  var Model = {
    name: 'ml.model_loader.mojom.Model',
    kVersion: 0,
    ptrClass: ModelPtr,
    proxyClass: ModelProxy,
    stubClass: ModelStub,
    validateRequest: validateModelRequest,
    validateResponse: validateModelResponse,
  };
  ModelStub.prototype.validator = validateModelRequest;
  ModelProxy.prototype.validator = validateModelResponse;
  exports.ModelFormat = ModelFormat;
  exports.DevicePreference = DevicePreference;
  exports.DataType = DataType;
  exports.LoadModelResult = LoadModelResult;
  exports.CreateModelLoaderResult = CreateModelLoaderResult;
  exports.ComputeResult = ComputeResult;
  exports.CreateModelLoaderOptions = CreateModelLoaderOptions;
  exports.TensorInfo = TensorInfo;
  exports.ModelInfo = ModelInfo;
  exports.ModelLoader = ModelLoader;
  exports.ModelLoaderPtr = ModelLoaderPtr;
  exports.ModelLoaderAssociatedPtr = ModelLoaderAssociatedPtr;
  exports.Model = Model;
  exports.ModelPtr = ModelPtr;
  exports.ModelAssociatedPtr = ModelAssociatedPtr;
})();