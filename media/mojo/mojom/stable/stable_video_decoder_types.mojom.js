// media/mojo/mojom/stable/stable_video_decoder_types.mojom.js is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2014 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

(function() {
  var mojomId = 'media/mojo/mojom/stable/stable_video_decoder_types.mojom';
  if (mojo.internal.isMojomLoaded(mojomId)) {
    console.warn('The following mojom is loaded multiple times: ' + mojomId);
    return;
  }
  mojo.internal.markMojomLoaded(mojomId);
  var bindings = mojo;
  var associatedBindings = mojo;
  var codec = mojo.internal;
  var validator = mojo.internal;

  var exports = mojo.internal.exposeNamespace('media.stable.mojom');
  var encryption_pattern$ =
      mojo.internal.exposeNamespace('media.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'media/mojo/mojom/encryption_pattern.mojom', '../encryption_pattern.mojom.js');
  }
  var native_pixmap_handle$ =
      mojo.internal.exposeNamespace('media.stable.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'media/mojo/mojom/stable/native_pixmap_handle.mojom', 'native_pixmap_handle.mojom.js');
  }
  var time$ =
      mojo.internal.exposeNamespace('mojoBase.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'mojo/public/mojom/base/time.mojom', '../../../../mojo/public/mojom/base/time.mojom.js');
  }
  var values$ =
      mojo.internal.exposeNamespace('mojoBase.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'mojo/public/mojom/base/values.mojom', '../../../../mojo/public/mojom/base/values.mojom.js');
  }
  var geometry$ =
      mojo.internal.exposeNamespace('gfx.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'ui/gfx/geometry/mojom/geometry.mojom', '../../../../ui/gfx/geometry/mojom/geometry.mojom.js');
  }
  var buffer_types$ =
      mojo.internal.exposeNamespace('gfx.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'ui/gfx/mojom/buffer_types.mojom', '../../../../ui/gfx/mojom/buffer_types.mojom.js');
  }


  var VideoCodec = {};
  VideoCodec.kUnknown = 0;
  VideoCodec.kH264 = 1;
  VideoCodec.kVC1 = 2;
  VideoCodec.kMPEG2 = 3;
  VideoCodec.kMPEG4 = 4;
  VideoCodec.kTheora = 5;
  VideoCodec.kVP8 = 6;
  VideoCodec.kVP9 = 7;
  VideoCodec.kHEVC = 8;
  VideoCodec.kDolbyVision = 9;
  VideoCodec.kAV1 = 10;
  VideoCodec.MIN_VALUE = 0;
  VideoCodec.MAX_VALUE = 10;
  VideoCodec.DEFAULT_VALUE = 0;

  VideoCodec.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    }
    return false;
  };

  VideoCodec.toKnownEnumValue = function(value) {
    if (this.isKnownEnumValue(value))
      return value;
    return this.DEFAULT_VALUE;
  };

  VideoCodec.validate = function(enumValue) {
    const isExtensible = true;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var VideoCodecProfile = {};
  VideoCodecProfile.kVideoCodecProfileUnknown = -1;
  VideoCodecProfile.kH264ProfileMin = 0;
  VideoCodecProfile.kH264ProfileBaseline = 0;
  VideoCodecProfile.kH264ProfileMain = 1;
  VideoCodecProfile.kH264ProfileExtended = 2;
  VideoCodecProfile.kH264ProfileHigh = 3;
  VideoCodecProfile.kH264ProfileHigh10 = 4;
  VideoCodecProfile.kH264ProfileHigh422 = 5;
  VideoCodecProfile.kH264ProfileHigh444Predictive = 6;
  VideoCodecProfile.kH264ProfileScalableBaseline = 7;
  VideoCodecProfile.kH264ProfileScalableHigh = 8;
  VideoCodecProfile.kH264ProfileStereoHigh = 9;
  VideoCodecProfile.kH264ProfileMultiviewHigh = 10;
  VideoCodecProfile.kH264ProfileMax = 10;
  VideoCodecProfile.kVP8ProfileMin = 11;
  VideoCodecProfile.kVP8ProfileAny = 11;
  VideoCodecProfile.kVP8ProfileMax = 11;
  VideoCodecProfile.kVP9ProfileMin = 12;
  VideoCodecProfile.kVP9Profile0 = 12;
  VideoCodecProfile.kVP9Profile1 = 13;
  VideoCodecProfile.kVP9Profile2 = 14;
  VideoCodecProfile.kVP9Profile3 = 15;
  VideoCodecProfile.kVP9ProfileMax = 15;
  VideoCodecProfile.kHEVCProfileMin = 16;
  VideoCodecProfile.kHEVCProfileMain = 16;
  VideoCodecProfile.kHEVCProfileMain10 = 17;
  VideoCodecProfile.kHEVCProfileMainStillPicture = 18;
  VideoCodecProfile.kHEVCProfileMax = 18;
  VideoCodecProfile.kDolbyVisionProfile0 = 19;
  VideoCodecProfile.kDolbyVisionProfile4 = 20;
  VideoCodecProfile.kDolbyVisionProfile5 = 21;
  VideoCodecProfile.kDolbyVisionProfile7 = 22;
  VideoCodecProfile.kTheoraProfileMin = 23;
  VideoCodecProfile.kTheoraProfileAny = 23;
  VideoCodecProfile.kTheoraProfileMax = 23;
  VideoCodecProfile.kAV1ProfileMin = 24;
  VideoCodecProfile.kAV1ProfileMain = 24;
  VideoCodecProfile.kAV1ProfileHigh = 25;
  VideoCodecProfile.kAV1ProfilePro = 26;
  VideoCodecProfile.kAV1ProfileMax = 26;
  VideoCodecProfile.kDolbyVisionProfile8 = 27;
  VideoCodecProfile.kDolbyVisionProfile9 = 28;
  VideoCodecProfile.kHEVCProfileExtMin = 29;
  VideoCodecProfile.kHEVCProfileRext = 29;
  VideoCodecProfile.kHEVCProfileHighThroughput = 30;
  VideoCodecProfile.kHEVCProfileMultiviewMain = 31;
  VideoCodecProfile.kHEVCProfileScalableMain = 32;
  VideoCodecProfile.kHEVCProfile3dMain = 33;
  VideoCodecProfile.kHEVCProfileScreenExtended = 34;
  VideoCodecProfile.kHEVCProfileScalableRext = 35;
  VideoCodecProfile.kHEVCProfileHighThroughputScreenExtended = 36;
  VideoCodecProfile.kHEVCProfileExtMax = 36;
  VideoCodecProfile.kVVCProfileMin = 37;
  VideoCodecProfile.kVVCProfileMain10 = 37;
  VideoCodecProfile.kVVCProfileMain12 = 38;
  VideoCodecProfile.kVVCProfileMain12Intra = 39;
  VideoCodecProfile.kVVCProfileMultilayerMain10 = 40;
  VideoCodecProfile.kVVCProfileMain10444 = 41;
  VideoCodecProfile.kVVCProfileMain12444 = 42;
  VideoCodecProfile.kVVCProfileMain16444 = 43;
  VideoCodecProfile.kVVCProfileMain12444Intra = 44;
  VideoCodecProfile.kVVCProfileMain16444Intra = 45;
  VideoCodecProfile.kVVCProfileMultilayerMain10444 = 46;
  VideoCodecProfile.kVVCProfileMain10Still = 47;
  VideoCodecProfile.kVVCProfileMain12Still = 48;
  VideoCodecProfile.kVVCProfileMain10444Still = 49;
  VideoCodecProfile.kVVCProfileMain12444Still = 50;
  VideoCodecProfile.kVVCProfileMain16444Still = 51;
  VideoCodecProfile.kVVCProileMax = 51;
  VideoCodecProfile.MIN_VALUE = -1;
  VideoCodecProfile.MAX_VALUE = 51;
  VideoCodecProfile.DEFAULT_VALUE = -1;

  VideoCodecProfile.isKnownEnumValue = function(value) {
    switch (value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
      return true;
    }
    return false;
  };

  VideoCodecProfile.toKnownEnumValue = function(value) {
    if (this.isKnownEnumValue(value))
      return value;
    return this.DEFAULT_VALUE;
  };

  VideoCodecProfile.validate = function(enumValue) {
    const isExtensible = true;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var EncryptionScheme = {};
  EncryptionScheme.kUnencrypted = 0;
  EncryptionScheme.kCenc = 1;
  EncryptionScheme.kCbcs = 2;
  EncryptionScheme.MIN_VALUE = 0;
  EncryptionScheme.MAX_VALUE = 2;
  EncryptionScheme.DEFAULT_VALUE = 0;

  EncryptionScheme.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    }
    return false;
  };

  EncryptionScheme.toKnownEnumValue = function(value) {
    if (this.isKnownEnumValue(value))
      return value;
    return this.DEFAULT_VALUE;
  };

  EncryptionScheme.validate = function(enumValue) {
    const isExtensible = true;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var StatusCode = {};
  StatusCode.kOk_DEPRECATED = 0;
  StatusCode.kAborted = 1;
  StatusCode.kError = 2;
  StatusCode.MIN_VALUE = 0;
  StatusCode.MAX_VALUE = 2;
  StatusCode.DEFAULT_VALUE = 2;

  StatusCode.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    }
    return false;
  };

  StatusCode.toKnownEnumValue = function(value) {
    if (this.isKnownEnumValue(value))
      return value;
    return this.DEFAULT_VALUE;
  };

  StatusCode.validate = function(enumValue) {
    const isExtensible = true;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var VideoDecoderType = {};
  VideoDecoderType.kUnknown = 0;
  VideoDecoderType.kVaapi = 1;
  VideoDecoderType.kVda = 2;
  VideoDecoderType.kV4L2 = 3;
  VideoDecoderType.kTesting = 4;
  VideoDecoderType.MIN_VALUE = 0;
  VideoDecoderType.MAX_VALUE = 4;
  VideoDecoderType.DEFAULT_VALUE = 0;

  VideoDecoderType.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    }
    return false;
  };

  VideoDecoderType.toKnownEnumValue = function(value) {
    if (this.isKnownEnumValue(value))
      return value;
    return this.DEFAULT_VALUE;
  };

  VideoDecoderType.validate = function(enumValue) {
    const isExtensible = true;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var ColorSpacePrimaryID = {};
  ColorSpacePrimaryID.kInvalid = 0;
  ColorSpacePrimaryID.kBT709 = 1;
  ColorSpacePrimaryID.kBT470M = 2;
  ColorSpacePrimaryID.kBT470BG = 3;
  ColorSpacePrimaryID.kSMPTE170M = 4;
  ColorSpacePrimaryID.kSMPTE240M = 5;
  ColorSpacePrimaryID.kFilm = 6;
  ColorSpacePrimaryID.kBT2020 = 7;
  ColorSpacePrimaryID.kSMPTEST428_1 = 8;
  ColorSpacePrimaryID.kSMPTEST431_2 = 9;
  ColorSpacePrimaryID.kSMPTEST432_1 = 10;
  ColorSpacePrimaryID.kXYZ_D50 = 11;
  ColorSpacePrimaryID.kAdobeRGB = 12;
  ColorSpacePrimaryID.kAppleGenericRGB = 13;
  ColorSpacePrimaryID.kWideGamutColorSpin = 14;
  ColorSpacePrimaryID.kCustom = 15;
  ColorSpacePrimaryID.MIN_VALUE = 0;
  ColorSpacePrimaryID.MAX_VALUE = 15;
  ColorSpacePrimaryID.DEFAULT_VALUE = 0;

  ColorSpacePrimaryID.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
      return true;
    }
    return false;
  };

  ColorSpacePrimaryID.toKnownEnumValue = function(value) {
    if (this.isKnownEnumValue(value))
      return value;
    return this.DEFAULT_VALUE;
  };

  ColorSpacePrimaryID.validate = function(enumValue) {
    const isExtensible = true;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var ColorSpaceTransferID = {};
  ColorSpaceTransferID.kInvalid = 0;
  ColorSpaceTransferID.kBT709 = 1;
  ColorSpaceTransferID.kBT709Apple = 2;
  ColorSpaceTransferID.kGamma18 = 3;
  ColorSpaceTransferID.kGamma22 = 4;
  ColorSpaceTransferID.kGamma24 = 5;
  ColorSpaceTransferID.kGamma28 = 6;
  ColorSpaceTransferID.kSMPTE170M = 7;
  ColorSpaceTransferID.kSMPTE240M = 8;
  ColorSpaceTransferID.kLinear = 9;
  ColorSpaceTransferID.kLog = 10;
  ColorSpaceTransferID.kLogSqrt = 11;
  ColorSpaceTransferID.kIEC61966_2_4 = 12;
  ColorSpaceTransferID.kBT1361_ECG = 13;
  ColorSpaceTransferID.kIEC61966_2_1 = 14;
  ColorSpaceTransferID.kBT2020_10 = 15;
  ColorSpaceTransferID.kBT2020_12 = 16;
  ColorSpaceTransferID.kSMPTEST2084 = 17;
  ColorSpaceTransferID.kSMPTEST428_1 = 18;
  ColorSpaceTransferID.kARIB_STD_B67 = 19;
  ColorSpaceTransferID.kIEC61966_2_1_HDR = 20;
  ColorSpaceTransferID.kLinearHDR = 21;
  ColorSpaceTransferID.kCustom = 22;
  ColorSpaceTransferID.kCustomHDR = 23;
  ColorSpaceTransferID.kPiecewiseHDR = 24;
  ColorSpaceTransferID.kScrgbLinear80Nits = 25;
  ColorSpaceTransferID.MIN_VALUE = 0;
  ColorSpaceTransferID.MAX_VALUE = 25;
  ColorSpaceTransferID.DEFAULT_VALUE = 0;

  ColorSpaceTransferID.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
      return true;
    }
    return false;
  };

  ColorSpaceTransferID.toKnownEnumValue = function(value) {
    if (this.isKnownEnumValue(value))
      return value;
    return this.DEFAULT_VALUE;
  };

  ColorSpaceTransferID.validate = function(enumValue) {
    const isExtensible = true;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var ColorSpaceMatrixID = {};
  ColorSpaceMatrixID.kInvalid = 0;
  ColorSpaceMatrixID.kRGB = 1;
  ColorSpaceMatrixID.kBT709 = 2;
  ColorSpaceMatrixID.kFCC = 3;
  ColorSpaceMatrixID.kBT470BG = 4;
  ColorSpaceMatrixID.kSMPTE170M = 5;
  ColorSpaceMatrixID.kSMPTE240M = 6;
  ColorSpaceMatrixID.kYCOCG = 7;
  ColorSpaceMatrixID.kBT2020_NCL = 8;
  ColorSpaceMatrixID.kBT2020_CL = 9;
  ColorSpaceMatrixID.kYDZDX = 10;
  ColorSpaceMatrixID.kGBR = 11;
  ColorSpaceMatrixID.MIN_VALUE = 0;
  ColorSpaceMatrixID.MAX_VALUE = 11;
  ColorSpaceMatrixID.DEFAULT_VALUE = 0;

  ColorSpaceMatrixID.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return true;
    }
    return false;
  };

  ColorSpaceMatrixID.toKnownEnumValue = function(value) {
    if (this.isKnownEnumValue(value))
      return value;
    return this.DEFAULT_VALUE;
  };

  ColorSpaceMatrixID.validate = function(enumValue) {
    const isExtensible = true;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var ColorSpaceRangeID = {};
  ColorSpaceRangeID.kInvalid = 0;
  ColorSpaceRangeID.kLimited = 1;
  ColorSpaceRangeID.kFull = 2;
  ColorSpaceRangeID.kDerived = 3;
  ColorSpaceRangeID.MIN_VALUE = 0;
  ColorSpaceRangeID.MAX_VALUE = 3;
  ColorSpaceRangeID.DEFAULT_VALUE = 0;

  ColorSpaceRangeID.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    }
    return false;
  };

  ColorSpaceRangeID.toKnownEnumValue = function(value) {
    if (this.isKnownEnumValue(value))
      return value;
    return this.DEFAULT_VALUE;
  };

  ColorSpaceRangeID.validate = function(enumValue) {
    const isExtensible = true;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var VideoPixelFormat = {};
  VideoPixelFormat.kPixelFormatUnknown = 0;
  VideoPixelFormat.kPixelFormatI420 = 1;
  VideoPixelFormat.kPixelFormatYV12 = 2;
  VideoPixelFormat.kPixelFormatI422 = 3;
  VideoPixelFormat.kPixelFormatI420A = 4;
  VideoPixelFormat.kPixelFormatI444 = 5;
  VideoPixelFormat.kPixelFormatNV12 = 6;
  VideoPixelFormat.kPixelFormatNV21 = 7;
  VideoPixelFormat.kPixelFormatUYVY = 8;
  VideoPixelFormat.kPixelFormatYUY2 = 9;
  VideoPixelFormat.kPixelFormatARGB = 10;
  VideoPixelFormat.kPixelFormatXRGB = 11;
  VideoPixelFormat.kPixelFormatRGB24 = 12;
  VideoPixelFormat.kPixelFormatMJPEG = 14;
  VideoPixelFormat.kPixelFormatYUV420P9 = 16;
  VideoPixelFormat.kPixelFormatYUV420P10 = 17;
  VideoPixelFormat.kPixelFormatYUV422P9 = 18;
  VideoPixelFormat.kPixelFormatYUV422P10 = 19;
  VideoPixelFormat.kPixelFormatYUV444P9 = 20;
  VideoPixelFormat.kPixelFormatYUV444P10 = 21;
  VideoPixelFormat.kPixelFormatYUV420P12 = 22;
  VideoPixelFormat.kPixelFormatYUV422P12 = 23;
  VideoPixelFormat.kPixelFormatYUV444P12 = 24;
  VideoPixelFormat.kPixelFormatY16 = 26;
  VideoPixelFormat.kPixelFormatABGR = 27;
  VideoPixelFormat.kPixelFormatXBGR = 28;
  VideoPixelFormat.kPixelFormatP016LE = 29;
  VideoPixelFormat.kPixelFormatXR30 = 30;
  VideoPixelFormat.kPixelFormatXB30 = 31;
  VideoPixelFormat.kPixelFormatBGRA = 32;
  VideoPixelFormat.kPixelFormatRGBAF16 = 33;
  VideoPixelFormat.kPixelFormatI422A = 34;
  VideoPixelFormat.kPixelFormatI444A = 35;
  VideoPixelFormat.kPixelFormatYUV420AP10 = 36;
  VideoPixelFormat.kPixelFormatYUV422AP10 = 37;
  VideoPixelFormat.kPixelFormatYUV444AP10 = 38;
  VideoPixelFormat.kPixelFormatNV12A = 39;
  VideoPixelFormat.MIN_VALUE = 0;
  VideoPixelFormat.MAX_VALUE = 39;
  VideoPixelFormat.DEFAULT_VALUE = 0;

  VideoPixelFormat.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 14:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
      return true;
    }
    return false;
  };

  VideoPixelFormat.toKnownEnumValue = function(value) {
    if (this.isKnownEnumValue(value))
      return value;
    return this.DEFAULT_VALUE;
  };

  VideoPixelFormat.validate = function(enumValue) {
    const isExtensible = true;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var WaitingReason = {};
  WaitingReason.kNoCdm = 0;
  WaitingReason.kNoDecryptionKey = 1;
  WaitingReason.kDecoderStateLost = 2;
  WaitingReason.kSecureSurfaceLost = 3;
  WaitingReason.MIN_VALUE = 0;
  WaitingReason.MAX_VALUE = 3;
  WaitingReason.DEFAULT_VALUE = 0;

  WaitingReason.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    }
    return false;
  };

  WaitingReason.toKnownEnumValue = function(value) {
    if (this.isKnownEnumValue(value))
      return value;
    return this.DEFAULT_VALUE;
  };

  WaitingReason.validate = function(enumValue) {
    const isExtensible = true;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var DecryptStatus = {};
  DecryptStatus.kSuccess = 0;
  DecryptStatus.kNoKey = 1;
  DecryptStatus.kFailure = 2;
  DecryptStatus.MIN_VALUE = 0;
  DecryptStatus.MAX_VALUE = 2;
  DecryptStatus.DEFAULT_VALUE = 2;

  DecryptStatus.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    }
    return false;
  };

  DecryptStatus.toKnownEnumValue = function(value) {
    if (this.isKnownEnumValue(value))
      return value;
    return this.DEFAULT_VALUE;
  };

  DecryptStatus.validate = function(enumValue) {
    const isExtensible = true;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var CdmContextEvent = {};
  CdmContextEvent.kHasAdditionalUsableKey = 0;
  CdmContextEvent.kHardwareContextReset = 1;
  CdmContextEvent.MIN_VALUE = 0;
  CdmContextEvent.MAX_VALUE = 1;
  CdmContextEvent.DEFAULT_VALUE = 0;

  CdmContextEvent.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
      return true;
    }
    return false;
  };

  CdmContextEvent.toKnownEnumValue = function(value) {
    if (this.isKnownEnumValue(value))
      return value;
    return this.DEFAULT_VALUE;
  };

  CdmContextEvent.validate = function(enumValue) {
    const isExtensible = true;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };

  function SubsampleEntry(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SubsampleEntry.prototype.initDefaults_ = function() {
    this.clearBytes = 0;
    this.cypherBytes = 0;
  };
  SubsampleEntry.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SubsampleEntry.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    return validator.validationError.NONE;
  };

  SubsampleEntry.encodedSize = codec.kStructHeaderSize + 8;

  SubsampleEntry.decode = function(decoder) {
    var packed;
    var val = new SubsampleEntry();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.clearBytes =
        decoder.decodeStruct(codec.Uint32);
    val.cypherBytes =
        decoder.decodeStruct(codec.Uint32);
    return val;
  };

  SubsampleEntry.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SubsampleEntry.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint32, val.clearBytes);
    encoder.encodeStruct(codec.Uint32, val.cypherBytes);
  };
  function DecryptConfig(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  DecryptConfig.prototype.initDefaults_ = function() {
    this.encryptionScheme = 0;
    this.keyId = null;
    this.iv = null;
    this.subsamples = null;
    this.encryptionPattern = null;
  };
  DecryptConfig.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  DecryptConfig.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 48}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate DecryptConfig.encryptionScheme
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, EncryptionScheme);
    if (err !== validator.validationError.NONE)
        return err;


    // validate DecryptConfig.keyId
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 8, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate DecryptConfig.iv
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 16, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate DecryptConfig.subsamples
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 24, 8, new codec.PointerTo(SubsampleEntry), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate DecryptConfig.encryptionPattern
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 32, encryption_pattern$.EncryptionPattern, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  DecryptConfig.encodedSize = codec.kStructHeaderSize + 40;

  DecryptConfig.decode = function(decoder) {
    var packed;
    var val = new DecryptConfig();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.encryptionScheme =
        decoder.decodeStruct(new codec.Enum(EncryptionScheme));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.keyId =
        decoder.decodeStruct(codec.String);
    val.iv =
        decoder.decodeStruct(codec.String);
    val.subsamples =
        decoder.decodeArrayPointer(new codec.PointerTo(SubsampleEntry));
    val.encryptionPattern =
        decoder.decodeStructPointer(encryption_pattern$.EncryptionPattern);
    return val;
  };

  DecryptConfig.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(DecryptConfig.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.encryptionScheme);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.String, val.keyId);
    encoder.encodeStruct(codec.String, val.iv);
    encoder.encodeArrayPointer(new codec.PointerTo(SubsampleEntry), val.subsamples);
    encoder.encodeStructPointer(encryption_pattern$.EncryptionPattern, val.encryptionPattern);
  };
  function ColorVolumeMetadata(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ColorVolumeMetadata.prototype.initDefaults_ = function() {
    this.primaryR = null;
    this.primaryG = null;
    this.primaryB = null;
    this.whitePoint = null;
    this.luminanceMax = 0;
    this.luminanceMin = 0;
  };
  ColorVolumeMetadata.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ColorVolumeMetadata.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 48}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ColorVolumeMetadata.primaryR
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, geometry$.PointF, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ColorVolumeMetadata.primaryG
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, geometry$.PointF, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ColorVolumeMetadata.primaryB
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, geometry$.PointF, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ColorVolumeMetadata.whitePoint
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 24, geometry$.PointF, false);
    if (err !== validator.validationError.NONE)
        return err;



    return validator.validationError.NONE;
  };

  ColorVolumeMetadata.encodedSize = codec.kStructHeaderSize + 40;

  ColorVolumeMetadata.decode = function(decoder) {
    var packed;
    var val = new ColorVolumeMetadata();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.primaryR =
        decoder.decodeStructPointer(geometry$.PointF);
    val.primaryG =
        decoder.decodeStructPointer(geometry$.PointF);
    val.primaryB =
        decoder.decodeStructPointer(geometry$.PointF);
    val.whitePoint =
        decoder.decodeStructPointer(geometry$.PointF);
    val.luminanceMax =
        decoder.decodeStruct(codec.Float);
    val.luminanceMin =
        decoder.decodeStruct(codec.Float);
    return val;
  };

  ColorVolumeMetadata.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ColorVolumeMetadata.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(geometry$.PointF, val.primaryR);
    encoder.encodeStructPointer(geometry$.PointF, val.primaryG);
    encoder.encodeStructPointer(geometry$.PointF, val.primaryB);
    encoder.encodeStructPointer(geometry$.PointF, val.whitePoint);
    encoder.encodeStruct(codec.Float, val.luminanceMax);
    encoder.encodeStruct(codec.Float, val.luminanceMin);
  };
  function HDRMetadata(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  HDRMetadata.prototype.initDefaults_ = function() {
    this.colorVolumeMetadata = null;
    this.maxContentLightLevel = 0;
    this.maxFrameAverageLightLevel = 0;
  };
  HDRMetadata.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  HDRMetadata.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate HDRMetadata.colorVolumeMetadata
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, ColorVolumeMetadata, false);
    if (err !== validator.validationError.NONE)
        return err;



    return validator.validationError.NONE;
  };

  HDRMetadata.encodedSize = codec.kStructHeaderSize + 16;

  HDRMetadata.decode = function(decoder) {
    var packed;
    var val = new HDRMetadata();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.colorVolumeMetadata =
        decoder.decodeStructPointer(ColorVolumeMetadata);
    val.maxContentLightLevel =
        decoder.decodeStruct(codec.Uint32);
    val.maxFrameAverageLightLevel =
        decoder.decodeStruct(codec.Uint32);
    return val;
  };

  HDRMetadata.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(HDRMetadata.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(ColorVolumeMetadata, val.colorVolumeMetadata);
    encoder.encodeStruct(codec.Uint32, val.maxContentLightLevel);
    encoder.encodeStruct(codec.Uint32, val.maxFrameAverageLightLevel);
  };
  function VideoDecoderConfig(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  VideoDecoderConfig.prototype.initDefaults_ = function() {
    this.codec = 0;
    this.profile = 0;
    this.level = 0;
    this.hasAlpha = false;
    this.codedSize = null;
    this.visibleRect = null;
    this.naturalSize = null;
    this.extraData = null;
    this.encryptionScheme = 0;
    this.colorSpaceInfo = null;
    this.hdrMetadata = null;
  };
  VideoDecoderConfig.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  VideoDecoderConfig.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 80}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoDecoderConfig.codec
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, VideoCodec);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoDecoderConfig.profile
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 4, VideoCodecProfile);
    if (err !== validator.validationError.NONE)
        return err;




    // validate VideoDecoderConfig.codedSize
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, geometry$.Size, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoDecoderConfig.visibleRect
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 24, geometry$.Rect, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoDecoderConfig.naturalSize
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 32, geometry$.Size, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoDecoderConfig.extraData
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 40, 1, codec.Uint8, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoDecoderConfig.encryptionScheme
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 48, EncryptionScheme);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoDecoderConfig.colorSpaceInfo
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 56, ColorSpace, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoDecoderConfig.hdrMetadata
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 64, HDRMetadata, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  VideoDecoderConfig.encodedSize = codec.kStructHeaderSize + 72;

  VideoDecoderConfig.decode = function(decoder) {
    var packed;
    var val = new VideoDecoderConfig();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.codec =
        decoder.decodeStruct(new codec.Enum(VideoCodec));
    val.profile =
        decoder.decodeStruct(new codec.Enum(VideoCodecProfile));
    val.level =
        decoder.decodeStruct(codec.Uint32);
    packed = decoder.readUint8();
    val.hasAlpha = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.codedSize =
        decoder.decodeStructPointer(geometry$.Size);
    val.visibleRect =
        decoder.decodeStructPointer(geometry$.Rect);
    val.naturalSize =
        decoder.decodeStructPointer(geometry$.Size);
    val.extraData =
        decoder.decodeArrayPointer(codec.Uint8);
    val.encryptionScheme =
        decoder.decodeStruct(new codec.Enum(EncryptionScheme));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.colorSpaceInfo =
        decoder.decodeStructPointer(ColorSpace);
    val.hdrMetadata =
        decoder.decodeStructPointer(HDRMetadata);
    return val;
  };

  VideoDecoderConfig.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(VideoDecoderConfig.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.codec);
    encoder.encodeStruct(codec.Int32, val.profile);
    encoder.encodeStruct(codec.Uint32, val.level);
    packed = 0;
    packed |= (val.hasAlpha & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStructPointer(geometry$.Size, val.codedSize);
    encoder.encodeStructPointer(geometry$.Rect, val.visibleRect);
    encoder.encodeStructPointer(geometry$.Size, val.naturalSize);
    encoder.encodeArrayPointer(codec.Uint8, val.extraData);
    encoder.encodeStruct(codec.Int32, val.encryptionScheme);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStructPointer(ColorSpace, val.colorSpaceInfo);
    encoder.encodeStructPointer(HDRMetadata, val.hdrMetadata);
  };
  function SupportedVideoDecoderConfig(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SupportedVideoDecoderConfig.prototype.initDefaults_ = function() {
    this.profileMin = 0;
    this.profileMax = 0;
    this.codedSizeMin = null;
    this.codedSizeMax = null;
    this.allowEncrypted = false;
    this.requireEncrypted = false;
  };
  SupportedVideoDecoderConfig.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SupportedVideoDecoderConfig.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 40}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate SupportedVideoDecoderConfig.profileMin
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, VideoCodecProfile);
    if (err !== validator.validationError.NONE)
        return err;


    // validate SupportedVideoDecoderConfig.profileMax
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 4, VideoCodecProfile);
    if (err !== validator.validationError.NONE)
        return err;


    // validate SupportedVideoDecoderConfig.codedSizeMin
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, geometry$.Size, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate SupportedVideoDecoderConfig.codedSizeMax
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, geometry$.Size, false);
    if (err !== validator.validationError.NONE)
        return err;



    return validator.validationError.NONE;
  };

  SupportedVideoDecoderConfig.encodedSize = codec.kStructHeaderSize + 32;

  SupportedVideoDecoderConfig.decode = function(decoder) {
    var packed;
    var val = new SupportedVideoDecoderConfig();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.profileMin =
        decoder.decodeStruct(new codec.Enum(VideoCodecProfile));
    val.profileMax =
        decoder.decodeStruct(new codec.Enum(VideoCodecProfile));
    val.codedSizeMin =
        decoder.decodeStructPointer(geometry$.Size);
    val.codedSizeMax =
        decoder.decodeStructPointer(geometry$.Size);
    packed = decoder.readUint8();
    val.allowEncrypted = (packed >> 0) & 1 ? true : false;
    val.requireEncrypted = (packed >> 1) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  SupportedVideoDecoderConfig.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SupportedVideoDecoderConfig.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.profileMin);
    encoder.encodeStruct(codec.Int32, val.profileMax);
    encoder.encodeStructPointer(geometry$.Size, val.codedSizeMin);
    encoder.encodeStructPointer(geometry$.Size, val.codedSizeMax);
    packed = 0;
    packed |= (val.allowEncrypted & 1) << 0
    packed |= (val.requireEncrypted & 1) << 1
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function StatusData(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  StatusData.prototype.initDefaults_ = function() {
    this.group = null;
    this.code = 0;
    this.message = null;
    this.frames = null;
    this.cause = null;
    this.data = null;
  };
  StatusData.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  StatusData.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 64}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate StatusData.group
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 0, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate StatusData.code
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 8, StatusCode);
    if (err !== validator.validationError.NONE)
        return err;


    // validate StatusData.message
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 16, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate StatusData.frames
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 24, 16, values$.Value, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate StatusData.cause
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 32, StatusData, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate StatusData.data
    err = messageValidator.validateUnion(offset + codec.kStructHeaderSize + 40, values$.Value, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  StatusData.encodedSize = codec.kStructHeaderSize + 56;

  StatusData.decode = function(decoder) {
    var packed;
    var val = new StatusData();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.group =
        decoder.decodeStruct(codec.String);
    val.code =
        decoder.decodeStruct(new codec.Enum(StatusCode));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.message =
        decoder.decodeStruct(codec.String);
    val.frames =
        decoder.decodeArrayPointer(values$.Value);
    val.cause =
        decoder.decodeStructPointer(StatusData);
    val.data =
        decoder.decodeStruct(values$.Value);
    return val;
  };

  StatusData.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(StatusData.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.String, val.group);
    encoder.encodeStruct(codec.Int32, val.code);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.String, val.message);
    encoder.encodeArrayPointer(values$.Value, val.frames);
    encoder.encodeStructPointer(StatusData, val.cause);
    encoder.encodeStruct(values$.Value, val.data);
  };
  function Status(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Status.prototype.initDefaults_ = function() {
    this.internal = null;
  };
  Status.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Status.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Status.internal
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, StatusData, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Status.encodedSize = codec.kStructHeaderSize + 8;

  Status.decode = function(decoder) {
    var packed;
    var val = new Status();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.internal =
        decoder.decodeStructPointer(StatusData);
    return val;
  };

  Status.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Status.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(StatusData, val.internal);
  };
  function DecoderBufferSideData(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  DecoderBufferSideData.prototype.initDefaults_ = function() {
    this.spatialLayers = null;
    this.alphaData = null;
    this.secureHandle = 0;
  };
  DecoderBufferSideData.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  DecoderBufferSideData.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 32}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate DecoderBufferSideData.spatialLayers
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 0, 4, codec.Uint32, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate DecoderBufferSideData.alphaData
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 8, 1, codec.Uint8, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  DecoderBufferSideData.encodedSize = codec.kStructHeaderSize + 24;

  DecoderBufferSideData.decode = function(decoder) {
    var packed;
    var val = new DecoderBufferSideData();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.spatialLayers =
        decoder.decodeArrayPointer(codec.Uint32);
    val.alphaData =
        decoder.decodeArrayPointer(codec.Uint8);
    val.secureHandle =
        decoder.decodeStruct(codec.Uint64);
    return val;
  };

  DecoderBufferSideData.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(DecoderBufferSideData.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeArrayPointer(codec.Uint32, val.spatialLayers);
    encoder.encodeArrayPointer(codec.Uint8, val.alphaData);
    encoder.encodeStruct(codec.Uint64, val.secureHandle);
  };
  function DecoderBuffer(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  DecoderBuffer.prototype.initDefaults_ = function() {
    this.timestamp = null;
    this.duration = null;
    this.isEndOfStream = false;
    this.isKeyFrame = false;
    this.dataSize = 0;
    this.rawSideData = null;
    this.decryptConfig = null;
    this.frontDiscard = null;
    this.backDiscard = null;
    this.sideData = null;
  };
  DecoderBuffer.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  DecoderBuffer.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 64},
      {version: 1, numBytes: 72}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate DecoderBuffer.timestamp
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, time$.TimeDelta, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate DecoderBuffer.duration
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, time$.TimeDelta, false);
    if (err !== validator.validationError.NONE)
        return err;





    // validate DecoderBuffer.rawSideData
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 24, 1, codec.Uint8, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate DecoderBuffer.decryptConfig
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 32, DecryptConfig, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate DecoderBuffer.frontDiscard
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 40, time$.TimeDelta, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate DecoderBuffer.backDiscard
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 48, time$.TimeDelta, false);
    if (err !== validator.validationError.NONE)
        return err;



    // version check DecoderBuffer.sideData
    if (!messageValidator.isFieldInStructVersion(offset, 1))
      return validator.validationError.NONE;
    // validate DecoderBuffer.sideData
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 56, DecoderBufferSideData, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  DecoderBuffer.encodedSize = codec.kStructHeaderSize + 64;

  DecoderBuffer.decode = function(decoder) {
    var packed;
    var val = new DecoderBuffer();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.timestamp =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.duration =
        decoder.decodeStructPointer(time$.TimeDelta);
    packed = decoder.readUint8();
    val.isEndOfStream = (packed >> 0) & 1 ? true : false;
    val.isKeyFrame = (packed >> 1) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.dataSize =
        decoder.decodeStruct(codec.Uint32);
    val.rawSideData =
        decoder.decodeArrayPointer(codec.Uint8);
    val.decryptConfig =
        decoder.decodeStructPointer(DecryptConfig);
    val.frontDiscard =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.backDiscard =
        decoder.decodeStructPointer(time$.TimeDelta);
    if (version >= 1) {
      val.sideData =
          decoder.decodeStructPointer(DecoderBufferSideData);
    } else {
      val.sideData = null;
    }
    return val;
  };

  DecoderBuffer.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(DecoderBuffer.encodedSize);
    encoder.writeUint32(1);
    encoder.encodeStructPointer(time$.TimeDelta, val.timestamp);
    encoder.encodeStructPointer(time$.TimeDelta, val.duration);
    packed = 0;
    packed |= (val.isEndOfStream & 1) << 0
    packed |= (val.isKeyFrame & 1) << 1
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.Uint32, val.dataSize);
    encoder.encodeArrayPointer(codec.Uint8, val.rawSideData);
    encoder.encodeStructPointer(DecryptConfig, val.decryptConfig);
    encoder.encodeStructPointer(time$.TimeDelta, val.frontDiscard);
    encoder.encodeStructPointer(time$.TimeDelta, val.backDiscard);
    encoder.encodeStructPointer(DecoderBufferSideData, val.sideData);
  };
  function ColorSpace(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ColorSpace.prototype.initDefaults_ = function() {
    this.primaries = 0;
    this.transfer = 0;
    this.matrix = 0;
    this.range = 0;
    this.customPrimaryMatrix = null;
    this.transferParams = null;
  };
  ColorSpace.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ColorSpace.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 40}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ColorSpace.primaries
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, ColorSpacePrimaryID);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ColorSpace.transfer
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 4, ColorSpaceTransferID);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ColorSpace.matrix
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 8, ColorSpaceMatrixID);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ColorSpace.range
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 12, ColorSpaceRangeID);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ColorSpace.customPrimaryMatrix
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 16, 4, codec.Float, false, [9], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ColorSpace.transferParams
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 24, 4, codec.Float, false, [7], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ColorSpace.encodedSize = codec.kStructHeaderSize + 32;

  ColorSpace.decode = function(decoder) {
    var packed;
    var val = new ColorSpace();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.primaries =
        decoder.decodeStruct(new codec.Enum(ColorSpacePrimaryID));
    val.transfer =
        decoder.decodeStruct(new codec.Enum(ColorSpaceTransferID));
    val.matrix =
        decoder.decodeStruct(new codec.Enum(ColorSpaceMatrixID));
    val.range =
        decoder.decodeStruct(new codec.Enum(ColorSpaceRangeID));
    val.customPrimaryMatrix =
        decoder.decodeArrayPointer(codec.Float);
    val.transferParams =
        decoder.decodeArrayPointer(codec.Float);
    return val;
  };

  ColorSpace.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ColorSpace.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.primaries);
    encoder.encodeStruct(codec.Int32, val.transfer);
    encoder.encodeStruct(codec.Int32, val.matrix);
    encoder.encodeStruct(codec.Int32, val.range);
    encoder.encodeArrayPointer(codec.Float, val.customPrimaryMatrix);
    encoder.encodeArrayPointer(codec.Float, val.transferParams);
  };
  function NativeGpuMemoryBufferHandle(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  NativeGpuMemoryBufferHandle.prototype.initDefaults_ = function() {
    this.id = null;
    this.platformHandle = null;
  };
  NativeGpuMemoryBufferHandle.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  NativeGpuMemoryBufferHandle.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate NativeGpuMemoryBufferHandle.id
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, buffer_types$.GpuMemoryBufferId, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate NativeGpuMemoryBufferHandle.platformHandle
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, native_pixmap_handle$.NativePixmapHandle, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  NativeGpuMemoryBufferHandle.encodedSize = codec.kStructHeaderSize + 16;

  NativeGpuMemoryBufferHandle.decode = function(decoder) {
    var packed;
    var val = new NativeGpuMemoryBufferHandle();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.id =
        decoder.decodeStructPointer(buffer_types$.GpuMemoryBufferId);
    val.platformHandle =
        decoder.decodeStructPointer(native_pixmap_handle$.NativePixmapHandle);
    return val;
  };

  NativeGpuMemoryBufferHandle.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(NativeGpuMemoryBufferHandle.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(buffer_types$.GpuMemoryBufferId, val.id);
    encoder.encodeStructPointer(native_pixmap_handle$.NativePixmapHandle, val.platformHandle);
  };
  function VideoFrameMetadata(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  VideoFrameMetadata.prototype.initDefaults_ = function() {
    this.protectedVideo = false;
    this.hwProtected = false;
  };
  VideoFrameMetadata.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  VideoFrameMetadata.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    return validator.validationError.NONE;
  };

  VideoFrameMetadata.encodedSize = codec.kStructHeaderSize + 8;

  VideoFrameMetadata.decode = function(decoder) {
    var packed;
    var val = new VideoFrameMetadata();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    packed = decoder.readUint8();
    val.protectedVideo = (packed >> 0) & 1 ? true : false;
    val.hwProtected = (packed >> 1) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  VideoFrameMetadata.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(VideoFrameMetadata.encodedSize);
    encoder.writeUint32(0);
    packed = 0;
    packed |= (val.protectedVideo & 1) << 0
    packed |= (val.hwProtected & 1) << 1
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function VideoFrame(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  VideoFrame.prototype.initDefaults_ = function() {
    this.format = 0;
    this.codedSize = null;
    this.visibleRect = null;
    this.naturalSize = null;
    this.timestamp = null;
    this.gpuMemoryBufferHandle = null;
    this.metadata = null;
    this.colorSpace = null;
    this.hdrMetadata = null;
  };
  VideoFrame.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  VideoFrame.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 80}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoFrame.format
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, VideoPixelFormat);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoFrame.codedSize
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, geometry$.Size, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoFrame.visibleRect
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, geometry$.Rect, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoFrame.naturalSize
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 24, geometry$.Size, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoFrame.timestamp
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 32, time$.TimeDelta, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoFrame.gpuMemoryBufferHandle
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 40, NativeGpuMemoryBufferHandle, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoFrame.metadata
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 48, VideoFrameMetadata, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoFrame.colorSpace
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 56, ColorSpace, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VideoFrame.hdrMetadata
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 64, HDRMetadata, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  VideoFrame.encodedSize = codec.kStructHeaderSize + 72;

  VideoFrame.decode = function(decoder) {
    var packed;
    var val = new VideoFrame();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.format =
        decoder.decodeStruct(new codec.Enum(VideoPixelFormat));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.codedSize =
        decoder.decodeStructPointer(geometry$.Size);
    val.visibleRect =
        decoder.decodeStructPointer(geometry$.Rect);
    val.naturalSize =
        decoder.decodeStructPointer(geometry$.Size);
    val.timestamp =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.gpuMemoryBufferHandle =
        decoder.decodeStructPointer(NativeGpuMemoryBufferHandle);
    val.metadata =
        decoder.decodeStructPointer(VideoFrameMetadata);
    val.colorSpace =
        decoder.decodeStructPointer(ColorSpace);
    val.hdrMetadata =
        decoder.decodeStructPointer(HDRMetadata);
    return val;
  };

  VideoFrame.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(VideoFrame.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.format);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStructPointer(geometry$.Size, val.codedSize);
    encoder.encodeStructPointer(geometry$.Rect, val.visibleRect);
    encoder.encodeStructPointer(geometry$.Size, val.naturalSize);
    encoder.encodeStructPointer(time$.TimeDelta, val.timestamp);
    encoder.encodeStructPointer(NativeGpuMemoryBufferHandle, val.gpuMemoryBufferHandle);
    encoder.encodeStructPointer(VideoFrameMetadata, val.metadata);
    encoder.encodeStructPointer(ColorSpace, val.colorSpace);
    encoder.encodeStructPointer(HDRMetadata, val.hdrMetadata);
  };
  function MediaLogRecord(values) {
    this.initDefaults_();
    this.initFields_(values);
  }

  MediaLogRecord.Type = {};
  MediaLogRecord.Type.kMessage = 0;
  MediaLogRecord.Type.kMediaPropertyChange = 1;
  MediaLogRecord.Type.kMediaEventTriggered = 2;
  MediaLogRecord.Type.kMediaStatus = 3;
  MediaLogRecord.Type.MIN_VALUE = 0;
  MediaLogRecord.Type.MAX_VALUE = 3;
  MediaLogRecord.Type.DEFAULT_VALUE = 0;

  MediaLogRecord.Type.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    }
    return false;
  };

  MediaLogRecord.Type.toKnownEnumValue = function(value) {
    if (this.isKnownEnumValue(value))
      return value;
    return this.DEFAULT_VALUE;
  };

  MediaLogRecord.Type.validate = function(enumValue) {
    const isExtensible = true;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };

  MediaLogRecord.prototype.initDefaults_ = function() {
    this.id = 0;
    this.type = 0;
    this.params = null;
    this.time = null;
  };
  MediaLogRecord.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  MediaLogRecord.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 32}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    // validate MediaLogRecord.type
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 4, MediaLogRecord.Type);
    if (err !== validator.validationError.NONE)
        return err;


    // validate MediaLogRecord.params
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, values$.DictionaryValue, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate MediaLogRecord.time
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, time$.TimeTicks, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  MediaLogRecord.encodedSize = codec.kStructHeaderSize + 24;

  MediaLogRecord.decode = function(decoder) {
    var packed;
    var val = new MediaLogRecord();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.id =
        decoder.decodeStruct(codec.Int32);
    val.type =
        decoder.decodeStruct(new codec.Enum(MediaLogRecord.Type));
    val.params =
        decoder.decodeStructPointer(values$.DictionaryValue);
    val.time =
        decoder.decodeStructPointer(time$.TimeTicks);
    return val;
  };

  MediaLogRecord.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(MediaLogRecord.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.id);
    encoder.encodeStruct(codec.Int32, val.type);
    encoder.encodeStructPointer(values$.DictionaryValue, val.params);
    encoder.encodeStructPointer(time$.TimeTicks, val.time);
  };
  exports.VideoCodec = VideoCodec;
  exports.VideoCodecProfile = VideoCodecProfile;
  exports.EncryptionScheme = EncryptionScheme;
  exports.StatusCode = StatusCode;
  exports.VideoDecoderType = VideoDecoderType;
  exports.ColorSpacePrimaryID = ColorSpacePrimaryID;
  exports.ColorSpaceTransferID = ColorSpaceTransferID;
  exports.ColorSpaceMatrixID = ColorSpaceMatrixID;
  exports.ColorSpaceRangeID = ColorSpaceRangeID;
  exports.VideoPixelFormat = VideoPixelFormat;
  exports.WaitingReason = WaitingReason;
  exports.DecryptStatus = DecryptStatus;
  exports.CdmContextEvent = CdmContextEvent;
  exports.SubsampleEntry = SubsampleEntry;
  exports.DecryptConfig = DecryptConfig;
  exports.ColorVolumeMetadata = ColorVolumeMetadata;
  exports.HDRMetadata = HDRMetadata;
  exports.VideoDecoderConfig = VideoDecoderConfig;
  exports.SupportedVideoDecoderConfig = SupportedVideoDecoderConfig;
  exports.StatusData = StatusData;
  exports.Status = Status;
  exports.DecoderBufferSideData = DecoderBufferSideData;
  exports.DecoderBuffer = DecoderBuffer;
  exports.ColorSpace = ColorSpace;
  exports.NativeGpuMemoryBufferHandle = NativeGpuMemoryBufferHandle;
  exports.VideoFrameMetadata = VideoFrameMetadata;
  exports.VideoFrame = VideoFrame;
  exports.MediaLogRecord = MediaLogRecord;
})();