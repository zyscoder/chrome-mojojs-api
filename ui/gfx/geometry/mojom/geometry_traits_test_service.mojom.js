// ui/gfx/geometry/mojom/geometry_traits_test_service.mojom.js is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2014 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

(function() {
  var mojomId = 'ui/gfx/geometry/mojom/geometry_traits_test_service.mojom';
  if (mojo.internal.isMojomLoaded(mojomId)) {
    console.warn('The following mojom is loaded multiple times: ' + mojomId);
    return;
  }
  mojo.internal.markMojomLoaded(mojomId);
  var bindings = mojo;
  var associatedBindings = mojo;
  var codec = mojo.internal;
  var validator = mojo.internal;

  var exports = mojo.internal.exposeNamespace('gfx.mojom');
  var geometry$ =
      mojo.internal.exposeNamespace('gfx.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'ui/gfx/geometry/mojom/geometry.mojom', 'geometry.mojom.js');
  }



  function GeometryTraitsTestService_EchoPoint_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GeometryTraitsTestService_EchoPoint_Params.prototype.initDefaults_ = function() {
    this.p = null;
  };
  GeometryTraitsTestService_EchoPoint_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GeometryTraitsTestService_EchoPoint_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GeometryTraitsTestService_EchoPoint_Params.p
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, geometry$.Point, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GeometryTraitsTestService_EchoPoint_Params.encodedSize = codec.kStructHeaderSize + 8;

  GeometryTraitsTestService_EchoPoint_Params.decode = function(decoder) {
    var packed;
    var val = new GeometryTraitsTestService_EchoPoint_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.p =
        decoder.decodeStructPointer(geometry$.Point);
    return val;
  };

  GeometryTraitsTestService_EchoPoint_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GeometryTraitsTestService_EchoPoint_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(geometry$.Point, val.p);
  };
  function GeometryTraitsTestService_EchoPoint_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GeometryTraitsTestService_EchoPoint_ResponseParams.prototype.initDefaults_ = function() {
    this.pass = null;
  };
  GeometryTraitsTestService_EchoPoint_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GeometryTraitsTestService_EchoPoint_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GeometryTraitsTestService_EchoPoint_ResponseParams.pass
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, geometry$.Point, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GeometryTraitsTestService_EchoPoint_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  GeometryTraitsTestService_EchoPoint_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new GeometryTraitsTestService_EchoPoint_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.pass =
        decoder.decodeStructPointer(geometry$.Point);
    return val;
  };

  GeometryTraitsTestService_EchoPoint_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GeometryTraitsTestService_EchoPoint_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(geometry$.Point, val.pass);
  };
  function GeometryTraitsTestService_EchoPointF_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GeometryTraitsTestService_EchoPointF_Params.prototype.initDefaults_ = function() {
    this.p = null;
  };
  GeometryTraitsTestService_EchoPointF_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GeometryTraitsTestService_EchoPointF_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GeometryTraitsTestService_EchoPointF_Params.p
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, geometry$.PointF, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GeometryTraitsTestService_EchoPointF_Params.encodedSize = codec.kStructHeaderSize + 8;

  GeometryTraitsTestService_EchoPointF_Params.decode = function(decoder) {
    var packed;
    var val = new GeometryTraitsTestService_EchoPointF_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.p =
        decoder.decodeStructPointer(geometry$.PointF);
    return val;
  };

  GeometryTraitsTestService_EchoPointF_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GeometryTraitsTestService_EchoPointF_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(geometry$.PointF, val.p);
  };
  function GeometryTraitsTestService_EchoPointF_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GeometryTraitsTestService_EchoPointF_ResponseParams.prototype.initDefaults_ = function() {
    this.pass = null;
  };
  GeometryTraitsTestService_EchoPointF_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GeometryTraitsTestService_EchoPointF_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GeometryTraitsTestService_EchoPointF_ResponseParams.pass
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, geometry$.PointF, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GeometryTraitsTestService_EchoPointF_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  GeometryTraitsTestService_EchoPointF_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new GeometryTraitsTestService_EchoPointF_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.pass =
        decoder.decodeStructPointer(geometry$.PointF);
    return val;
  };

  GeometryTraitsTestService_EchoPointF_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GeometryTraitsTestService_EchoPointF_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(geometry$.PointF, val.pass);
  };
  function GeometryTraitsTestService_EchoPoint3F_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GeometryTraitsTestService_EchoPoint3F_Params.prototype.initDefaults_ = function() {
    this.p = null;
  };
  GeometryTraitsTestService_EchoPoint3F_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GeometryTraitsTestService_EchoPoint3F_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GeometryTraitsTestService_EchoPoint3F_Params.p
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, geometry$.Point3F, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GeometryTraitsTestService_EchoPoint3F_Params.encodedSize = codec.kStructHeaderSize + 8;

  GeometryTraitsTestService_EchoPoint3F_Params.decode = function(decoder) {
    var packed;
    var val = new GeometryTraitsTestService_EchoPoint3F_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.p =
        decoder.decodeStructPointer(geometry$.Point3F);
    return val;
  };

  GeometryTraitsTestService_EchoPoint3F_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GeometryTraitsTestService_EchoPoint3F_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(geometry$.Point3F, val.p);
  };
  function GeometryTraitsTestService_EchoPoint3F_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GeometryTraitsTestService_EchoPoint3F_ResponseParams.prototype.initDefaults_ = function() {
    this.pass = null;
  };
  GeometryTraitsTestService_EchoPoint3F_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GeometryTraitsTestService_EchoPoint3F_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GeometryTraitsTestService_EchoPoint3F_ResponseParams.pass
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, geometry$.Point3F, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GeometryTraitsTestService_EchoPoint3F_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  GeometryTraitsTestService_EchoPoint3F_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new GeometryTraitsTestService_EchoPoint3F_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.pass =
        decoder.decodeStructPointer(geometry$.Point3F);
    return val;
  };

  GeometryTraitsTestService_EchoPoint3F_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GeometryTraitsTestService_EchoPoint3F_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(geometry$.Point3F, val.pass);
  };
  function GeometryTraitsTestService_EchoSize_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GeometryTraitsTestService_EchoSize_Params.prototype.initDefaults_ = function() {
    this.s = null;
  };
  GeometryTraitsTestService_EchoSize_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GeometryTraitsTestService_EchoSize_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GeometryTraitsTestService_EchoSize_Params.s
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, geometry$.Size, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GeometryTraitsTestService_EchoSize_Params.encodedSize = codec.kStructHeaderSize + 8;

  GeometryTraitsTestService_EchoSize_Params.decode = function(decoder) {
    var packed;
    var val = new GeometryTraitsTestService_EchoSize_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.s =
        decoder.decodeStructPointer(geometry$.Size);
    return val;
  };

  GeometryTraitsTestService_EchoSize_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GeometryTraitsTestService_EchoSize_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(geometry$.Size, val.s);
  };
  function GeometryTraitsTestService_EchoSize_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GeometryTraitsTestService_EchoSize_ResponseParams.prototype.initDefaults_ = function() {
    this.pass = null;
  };
  GeometryTraitsTestService_EchoSize_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GeometryTraitsTestService_EchoSize_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GeometryTraitsTestService_EchoSize_ResponseParams.pass
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, geometry$.Size, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GeometryTraitsTestService_EchoSize_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  GeometryTraitsTestService_EchoSize_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new GeometryTraitsTestService_EchoSize_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.pass =
        decoder.decodeStructPointer(geometry$.Size);
    return val;
  };

  GeometryTraitsTestService_EchoSize_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GeometryTraitsTestService_EchoSize_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(geometry$.Size, val.pass);
  };
  function GeometryTraitsTestService_EchoSizeF_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GeometryTraitsTestService_EchoSizeF_Params.prototype.initDefaults_ = function() {
    this.s = null;
  };
  GeometryTraitsTestService_EchoSizeF_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GeometryTraitsTestService_EchoSizeF_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GeometryTraitsTestService_EchoSizeF_Params.s
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, geometry$.SizeF, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GeometryTraitsTestService_EchoSizeF_Params.encodedSize = codec.kStructHeaderSize + 8;

  GeometryTraitsTestService_EchoSizeF_Params.decode = function(decoder) {
    var packed;
    var val = new GeometryTraitsTestService_EchoSizeF_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.s =
        decoder.decodeStructPointer(geometry$.SizeF);
    return val;
  };

  GeometryTraitsTestService_EchoSizeF_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GeometryTraitsTestService_EchoSizeF_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(geometry$.SizeF, val.s);
  };
  function GeometryTraitsTestService_EchoSizeF_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GeometryTraitsTestService_EchoSizeF_ResponseParams.prototype.initDefaults_ = function() {
    this.pass = null;
  };
  GeometryTraitsTestService_EchoSizeF_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GeometryTraitsTestService_EchoSizeF_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GeometryTraitsTestService_EchoSizeF_ResponseParams.pass
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, geometry$.SizeF, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GeometryTraitsTestService_EchoSizeF_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  GeometryTraitsTestService_EchoSizeF_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new GeometryTraitsTestService_EchoSizeF_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.pass =
        decoder.decodeStructPointer(geometry$.SizeF);
    return val;
  };

  GeometryTraitsTestService_EchoSizeF_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GeometryTraitsTestService_EchoSizeF_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(geometry$.SizeF, val.pass);
  };
  function GeometryTraitsTestService_EchoRect_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GeometryTraitsTestService_EchoRect_Params.prototype.initDefaults_ = function() {
    this.r = null;
  };
  GeometryTraitsTestService_EchoRect_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GeometryTraitsTestService_EchoRect_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GeometryTraitsTestService_EchoRect_Params.r
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, geometry$.Rect, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GeometryTraitsTestService_EchoRect_Params.encodedSize = codec.kStructHeaderSize + 8;

  GeometryTraitsTestService_EchoRect_Params.decode = function(decoder) {
    var packed;
    var val = new GeometryTraitsTestService_EchoRect_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.r =
        decoder.decodeStructPointer(geometry$.Rect);
    return val;
  };

  GeometryTraitsTestService_EchoRect_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GeometryTraitsTestService_EchoRect_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(geometry$.Rect, val.r);
  };
  function GeometryTraitsTestService_EchoRect_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GeometryTraitsTestService_EchoRect_ResponseParams.prototype.initDefaults_ = function() {
    this.pass = null;
  };
  GeometryTraitsTestService_EchoRect_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GeometryTraitsTestService_EchoRect_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GeometryTraitsTestService_EchoRect_ResponseParams.pass
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, geometry$.Rect, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GeometryTraitsTestService_EchoRect_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  GeometryTraitsTestService_EchoRect_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new GeometryTraitsTestService_EchoRect_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.pass =
        decoder.decodeStructPointer(geometry$.Rect);
    return val;
  };

  GeometryTraitsTestService_EchoRect_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GeometryTraitsTestService_EchoRect_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(geometry$.Rect, val.pass);
  };
  function GeometryTraitsTestService_EchoRectF_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GeometryTraitsTestService_EchoRectF_Params.prototype.initDefaults_ = function() {
    this.r = null;
  };
  GeometryTraitsTestService_EchoRectF_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GeometryTraitsTestService_EchoRectF_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GeometryTraitsTestService_EchoRectF_Params.r
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, geometry$.RectF, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GeometryTraitsTestService_EchoRectF_Params.encodedSize = codec.kStructHeaderSize + 8;

  GeometryTraitsTestService_EchoRectF_Params.decode = function(decoder) {
    var packed;
    var val = new GeometryTraitsTestService_EchoRectF_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.r =
        decoder.decodeStructPointer(geometry$.RectF);
    return val;
  };

  GeometryTraitsTestService_EchoRectF_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GeometryTraitsTestService_EchoRectF_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(geometry$.RectF, val.r);
  };
  function GeometryTraitsTestService_EchoRectF_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GeometryTraitsTestService_EchoRectF_ResponseParams.prototype.initDefaults_ = function() {
    this.pass = null;
  };
  GeometryTraitsTestService_EchoRectF_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GeometryTraitsTestService_EchoRectF_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GeometryTraitsTestService_EchoRectF_ResponseParams.pass
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, geometry$.RectF, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GeometryTraitsTestService_EchoRectF_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  GeometryTraitsTestService_EchoRectF_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new GeometryTraitsTestService_EchoRectF_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.pass =
        decoder.decodeStructPointer(geometry$.RectF);
    return val;
  };

  GeometryTraitsTestService_EchoRectF_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GeometryTraitsTestService_EchoRectF_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(geometry$.RectF, val.pass);
  };
  function GeometryTraitsTestService_EchoInsets_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GeometryTraitsTestService_EchoInsets_Params.prototype.initDefaults_ = function() {
    this.i = null;
  };
  GeometryTraitsTestService_EchoInsets_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GeometryTraitsTestService_EchoInsets_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GeometryTraitsTestService_EchoInsets_Params.i
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, geometry$.Insets, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GeometryTraitsTestService_EchoInsets_Params.encodedSize = codec.kStructHeaderSize + 8;

  GeometryTraitsTestService_EchoInsets_Params.decode = function(decoder) {
    var packed;
    var val = new GeometryTraitsTestService_EchoInsets_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.i =
        decoder.decodeStructPointer(geometry$.Insets);
    return val;
  };

  GeometryTraitsTestService_EchoInsets_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GeometryTraitsTestService_EchoInsets_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(geometry$.Insets, val.i);
  };
  function GeometryTraitsTestService_EchoInsets_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GeometryTraitsTestService_EchoInsets_ResponseParams.prototype.initDefaults_ = function() {
    this.pass = null;
  };
  GeometryTraitsTestService_EchoInsets_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GeometryTraitsTestService_EchoInsets_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GeometryTraitsTestService_EchoInsets_ResponseParams.pass
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, geometry$.Insets, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GeometryTraitsTestService_EchoInsets_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  GeometryTraitsTestService_EchoInsets_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new GeometryTraitsTestService_EchoInsets_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.pass =
        decoder.decodeStructPointer(geometry$.Insets);
    return val;
  };

  GeometryTraitsTestService_EchoInsets_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GeometryTraitsTestService_EchoInsets_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(geometry$.Insets, val.pass);
  };
  function GeometryTraitsTestService_EchoInsetsF_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GeometryTraitsTestService_EchoInsetsF_Params.prototype.initDefaults_ = function() {
    this.i = null;
  };
  GeometryTraitsTestService_EchoInsetsF_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GeometryTraitsTestService_EchoInsetsF_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GeometryTraitsTestService_EchoInsetsF_Params.i
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, geometry$.InsetsF, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GeometryTraitsTestService_EchoInsetsF_Params.encodedSize = codec.kStructHeaderSize + 8;

  GeometryTraitsTestService_EchoInsetsF_Params.decode = function(decoder) {
    var packed;
    var val = new GeometryTraitsTestService_EchoInsetsF_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.i =
        decoder.decodeStructPointer(geometry$.InsetsF);
    return val;
  };

  GeometryTraitsTestService_EchoInsetsF_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GeometryTraitsTestService_EchoInsetsF_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(geometry$.InsetsF, val.i);
  };
  function GeometryTraitsTestService_EchoInsetsF_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GeometryTraitsTestService_EchoInsetsF_ResponseParams.prototype.initDefaults_ = function() {
    this.pass = null;
  };
  GeometryTraitsTestService_EchoInsetsF_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GeometryTraitsTestService_EchoInsetsF_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GeometryTraitsTestService_EchoInsetsF_ResponseParams.pass
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, geometry$.InsetsF, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GeometryTraitsTestService_EchoInsetsF_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  GeometryTraitsTestService_EchoInsetsF_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new GeometryTraitsTestService_EchoInsetsF_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.pass =
        decoder.decodeStructPointer(geometry$.InsetsF);
    return val;
  };

  GeometryTraitsTestService_EchoInsetsF_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GeometryTraitsTestService_EchoInsetsF_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(geometry$.InsetsF, val.pass);
  };
  function GeometryTraitsTestService_EchoVector2d_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GeometryTraitsTestService_EchoVector2d_Params.prototype.initDefaults_ = function() {
    this.v = null;
  };
  GeometryTraitsTestService_EchoVector2d_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GeometryTraitsTestService_EchoVector2d_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GeometryTraitsTestService_EchoVector2d_Params.v
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, geometry$.Vector2d, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GeometryTraitsTestService_EchoVector2d_Params.encodedSize = codec.kStructHeaderSize + 8;

  GeometryTraitsTestService_EchoVector2d_Params.decode = function(decoder) {
    var packed;
    var val = new GeometryTraitsTestService_EchoVector2d_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.v =
        decoder.decodeStructPointer(geometry$.Vector2d);
    return val;
  };

  GeometryTraitsTestService_EchoVector2d_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GeometryTraitsTestService_EchoVector2d_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(geometry$.Vector2d, val.v);
  };
  function GeometryTraitsTestService_EchoVector2d_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GeometryTraitsTestService_EchoVector2d_ResponseParams.prototype.initDefaults_ = function() {
    this.pass = null;
  };
  GeometryTraitsTestService_EchoVector2d_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GeometryTraitsTestService_EchoVector2d_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GeometryTraitsTestService_EchoVector2d_ResponseParams.pass
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, geometry$.Vector2d, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GeometryTraitsTestService_EchoVector2d_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  GeometryTraitsTestService_EchoVector2d_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new GeometryTraitsTestService_EchoVector2d_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.pass =
        decoder.decodeStructPointer(geometry$.Vector2d);
    return val;
  };

  GeometryTraitsTestService_EchoVector2d_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GeometryTraitsTestService_EchoVector2d_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(geometry$.Vector2d, val.pass);
  };
  function GeometryTraitsTestService_EchoVector2dF_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GeometryTraitsTestService_EchoVector2dF_Params.prototype.initDefaults_ = function() {
    this.v = null;
  };
  GeometryTraitsTestService_EchoVector2dF_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GeometryTraitsTestService_EchoVector2dF_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GeometryTraitsTestService_EchoVector2dF_Params.v
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, geometry$.Vector2dF, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GeometryTraitsTestService_EchoVector2dF_Params.encodedSize = codec.kStructHeaderSize + 8;

  GeometryTraitsTestService_EchoVector2dF_Params.decode = function(decoder) {
    var packed;
    var val = new GeometryTraitsTestService_EchoVector2dF_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.v =
        decoder.decodeStructPointer(geometry$.Vector2dF);
    return val;
  };

  GeometryTraitsTestService_EchoVector2dF_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GeometryTraitsTestService_EchoVector2dF_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(geometry$.Vector2dF, val.v);
  };
  function GeometryTraitsTestService_EchoVector2dF_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GeometryTraitsTestService_EchoVector2dF_ResponseParams.prototype.initDefaults_ = function() {
    this.pass = null;
  };
  GeometryTraitsTestService_EchoVector2dF_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GeometryTraitsTestService_EchoVector2dF_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GeometryTraitsTestService_EchoVector2dF_ResponseParams.pass
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, geometry$.Vector2dF, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GeometryTraitsTestService_EchoVector2dF_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  GeometryTraitsTestService_EchoVector2dF_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new GeometryTraitsTestService_EchoVector2dF_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.pass =
        decoder.decodeStructPointer(geometry$.Vector2dF);
    return val;
  };

  GeometryTraitsTestService_EchoVector2dF_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GeometryTraitsTestService_EchoVector2dF_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(geometry$.Vector2dF, val.pass);
  };
  function GeometryTraitsTestService_EchoVector3dF_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GeometryTraitsTestService_EchoVector3dF_Params.prototype.initDefaults_ = function() {
    this.v = null;
  };
  GeometryTraitsTestService_EchoVector3dF_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GeometryTraitsTestService_EchoVector3dF_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GeometryTraitsTestService_EchoVector3dF_Params.v
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, geometry$.Vector3dF, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GeometryTraitsTestService_EchoVector3dF_Params.encodedSize = codec.kStructHeaderSize + 8;

  GeometryTraitsTestService_EchoVector3dF_Params.decode = function(decoder) {
    var packed;
    var val = new GeometryTraitsTestService_EchoVector3dF_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.v =
        decoder.decodeStructPointer(geometry$.Vector3dF);
    return val;
  };

  GeometryTraitsTestService_EchoVector3dF_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GeometryTraitsTestService_EchoVector3dF_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(geometry$.Vector3dF, val.v);
  };
  function GeometryTraitsTestService_EchoVector3dF_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GeometryTraitsTestService_EchoVector3dF_ResponseParams.prototype.initDefaults_ = function() {
    this.pass = null;
  };
  GeometryTraitsTestService_EchoVector3dF_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GeometryTraitsTestService_EchoVector3dF_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GeometryTraitsTestService_EchoVector3dF_ResponseParams.pass
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, geometry$.Vector3dF, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GeometryTraitsTestService_EchoVector3dF_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  GeometryTraitsTestService_EchoVector3dF_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new GeometryTraitsTestService_EchoVector3dF_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.pass =
        decoder.decodeStructPointer(geometry$.Vector3dF);
    return val;
  };

  GeometryTraitsTestService_EchoVector3dF_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GeometryTraitsTestService_EchoVector3dF_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(geometry$.Vector3dF, val.pass);
  };
  function GeometryTraitsTestService_EchoQuaternion_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GeometryTraitsTestService_EchoQuaternion_Params.prototype.initDefaults_ = function() {
    this.q = null;
  };
  GeometryTraitsTestService_EchoQuaternion_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GeometryTraitsTestService_EchoQuaternion_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GeometryTraitsTestService_EchoQuaternion_Params.q
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, geometry$.Quaternion, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GeometryTraitsTestService_EchoQuaternion_Params.encodedSize = codec.kStructHeaderSize + 8;

  GeometryTraitsTestService_EchoQuaternion_Params.decode = function(decoder) {
    var packed;
    var val = new GeometryTraitsTestService_EchoQuaternion_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.q =
        decoder.decodeStructPointer(geometry$.Quaternion);
    return val;
  };

  GeometryTraitsTestService_EchoQuaternion_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GeometryTraitsTestService_EchoQuaternion_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(geometry$.Quaternion, val.q);
  };
  function GeometryTraitsTestService_EchoQuaternion_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GeometryTraitsTestService_EchoQuaternion_ResponseParams.prototype.initDefaults_ = function() {
    this.pass = null;
  };
  GeometryTraitsTestService_EchoQuaternion_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GeometryTraitsTestService_EchoQuaternion_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GeometryTraitsTestService_EchoQuaternion_ResponseParams.pass
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, geometry$.Quaternion, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GeometryTraitsTestService_EchoQuaternion_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  GeometryTraitsTestService_EchoQuaternion_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new GeometryTraitsTestService_EchoQuaternion_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.pass =
        decoder.decodeStructPointer(geometry$.Quaternion);
    return val;
  };

  GeometryTraitsTestService_EchoQuaternion_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GeometryTraitsTestService_EchoQuaternion_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(geometry$.Quaternion, val.pass);
  };
  function GeometryTraitsTestService_EchoQuadF_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GeometryTraitsTestService_EchoQuadF_Params.prototype.initDefaults_ = function() {
    this.q = null;
  };
  GeometryTraitsTestService_EchoQuadF_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GeometryTraitsTestService_EchoQuadF_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GeometryTraitsTestService_EchoQuadF_Params.q
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, geometry$.QuadF, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GeometryTraitsTestService_EchoQuadF_Params.encodedSize = codec.kStructHeaderSize + 8;

  GeometryTraitsTestService_EchoQuadF_Params.decode = function(decoder) {
    var packed;
    var val = new GeometryTraitsTestService_EchoQuadF_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.q =
        decoder.decodeStructPointer(geometry$.QuadF);
    return val;
  };

  GeometryTraitsTestService_EchoQuadF_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GeometryTraitsTestService_EchoQuadF_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(geometry$.QuadF, val.q);
  };
  function GeometryTraitsTestService_EchoQuadF_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GeometryTraitsTestService_EchoQuadF_ResponseParams.prototype.initDefaults_ = function() {
    this.pass = null;
  };
  GeometryTraitsTestService_EchoQuadF_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GeometryTraitsTestService_EchoQuadF_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GeometryTraitsTestService_EchoQuadF_ResponseParams.pass
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, geometry$.QuadF, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GeometryTraitsTestService_EchoQuadF_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  GeometryTraitsTestService_EchoQuadF_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new GeometryTraitsTestService_EchoQuadF_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.pass =
        decoder.decodeStructPointer(geometry$.QuadF);
    return val;
  };

  GeometryTraitsTestService_EchoQuadF_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GeometryTraitsTestService_EchoQuadF_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(geometry$.QuadF, val.pass);
  };
  var kGeometryTraitsTestService_EchoPoint_Name = 710343865;
  var kGeometryTraitsTestService_EchoPointF_Name = 639297574;
  var kGeometryTraitsTestService_EchoPoint3F_Name = 1119132962;
  var kGeometryTraitsTestService_EchoSize_Name = 28448714;
  var kGeometryTraitsTestService_EchoSizeF_Name = 1601374651;
  var kGeometryTraitsTestService_EchoRect_Name = 1149834215;
  var kGeometryTraitsTestService_EchoRectF_Name = 1409174573;
  var kGeometryTraitsTestService_EchoInsets_Name = 998805737;
  var kGeometryTraitsTestService_EchoInsetsF_Name = 1739777057;
  var kGeometryTraitsTestService_EchoVector2d_Name = 161198193;
  var kGeometryTraitsTestService_EchoVector2dF_Name = 1474484262;
  var kGeometryTraitsTestService_EchoVector3dF_Name = 922953846;
  var kGeometryTraitsTestService_EchoQuaternion_Name = 928495430;
  var kGeometryTraitsTestService_EchoQuadF_Name = 1858959773;

  function GeometryTraitsTestServicePtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(GeometryTraitsTestService,
                                                   handleOrPtrInfo);
  }

  function GeometryTraitsTestServiceAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        GeometryTraitsTestService, associatedInterfacePtrInfo);
  }

  GeometryTraitsTestServiceAssociatedPtr.prototype =
      Object.create(GeometryTraitsTestServicePtr.prototype);
  GeometryTraitsTestServiceAssociatedPtr.prototype.constructor =
      GeometryTraitsTestServiceAssociatedPtr;

  function GeometryTraitsTestServiceProxy(receiver) {
    this.receiver_ = receiver;
  }
  GeometryTraitsTestServicePtr.prototype.echoPoint = function() {
    return GeometryTraitsTestServiceProxy.prototype.echoPoint
        .apply(this.ptr.getProxy(), arguments);
  };

  GeometryTraitsTestServiceProxy.prototype.echoPoint = function(p) {
    var params_ = new GeometryTraitsTestService_EchoPoint_Params();
    params_.p = p;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kGeometryTraitsTestService_EchoPoint_Name,
          codec.align(GeometryTraitsTestService_EchoPoint_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(GeometryTraitsTestService_EchoPoint_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(GeometryTraitsTestService_EchoPoint_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  GeometryTraitsTestServicePtr.prototype.echoPointF = function() {
    return GeometryTraitsTestServiceProxy.prototype.echoPointF
        .apply(this.ptr.getProxy(), arguments);
  };

  GeometryTraitsTestServiceProxy.prototype.echoPointF = function(p) {
    var params_ = new GeometryTraitsTestService_EchoPointF_Params();
    params_.p = p;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kGeometryTraitsTestService_EchoPointF_Name,
          codec.align(GeometryTraitsTestService_EchoPointF_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(GeometryTraitsTestService_EchoPointF_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(GeometryTraitsTestService_EchoPointF_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  GeometryTraitsTestServicePtr.prototype.echoPoint3F = function() {
    return GeometryTraitsTestServiceProxy.prototype.echoPoint3F
        .apply(this.ptr.getProxy(), arguments);
  };

  GeometryTraitsTestServiceProxy.prototype.echoPoint3F = function(p) {
    var params_ = new GeometryTraitsTestService_EchoPoint3F_Params();
    params_.p = p;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kGeometryTraitsTestService_EchoPoint3F_Name,
          codec.align(GeometryTraitsTestService_EchoPoint3F_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(GeometryTraitsTestService_EchoPoint3F_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(GeometryTraitsTestService_EchoPoint3F_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  GeometryTraitsTestServicePtr.prototype.echoSize = function() {
    return GeometryTraitsTestServiceProxy.prototype.echoSize
        .apply(this.ptr.getProxy(), arguments);
  };

  GeometryTraitsTestServiceProxy.prototype.echoSize = function(s) {
    var params_ = new GeometryTraitsTestService_EchoSize_Params();
    params_.s = s;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kGeometryTraitsTestService_EchoSize_Name,
          codec.align(GeometryTraitsTestService_EchoSize_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(GeometryTraitsTestService_EchoSize_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(GeometryTraitsTestService_EchoSize_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  GeometryTraitsTestServicePtr.prototype.echoSizeF = function() {
    return GeometryTraitsTestServiceProxy.prototype.echoSizeF
        .apply(this.ptr.getProxy(), arguments);
  };

  GeometryTraitsTestServiceProxy.prototype.echoSizeF = function(s) {
    var params_ = new GeometryTraitsTestService_EchoSizeF_Params();
    params_.s = s;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kGeometryTraitsTestService_EchoSizeF_Name,
          codec.align(GeometryTraitsTestService_EchoSizeF_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(GeometryTraitsTestService_EchoSizeF_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(GeometryTraitsTestService_EchoSizeF_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  GeometryTraitsTestServicePtr.prototype.echoRect = function() {
    return GeometryTraitsTestServiceProxy.prototype.echoRect
        .apply(this.ptr.getProxy(), arguments);
  };

  GeometryTraitsTestServiceProxy.prototype.echoRect = function(r) {
    var params_ = new GeometryTraitsTestService_EchoRect_Params();
    params_.r = r;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kGeometryTraitsTestService_EchoRect_Name,
          codec.align(GeometryTraitsTestService_EchoRect_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(GeometryTraitsTestService_EchoRect_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(GeometryTraitsTestService_EchoRect_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  GeometryTraitsTestServicePtr.prototype.echoRectF = function() {
    return GeometryTraitsTestServiceProxy.prototype.echoRectF
        .apply(this.ptr.getProxy(), arguments);
  };

  GeometryTraitsTestServiceProxy.prototype.echoRectF = function(r) {
    var params_ = new GeometryTraitsTestService_EchoRectF_Params();
    params_.r = r;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kGeometryTraitsTestService_EchoRectF_Name,
          codec.align(GeometryTraitsTestService_EchoRectF_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(GeometryTraitsTestService_EchoRectF_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(GeometryTraitsTestService_EchoRectF_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  GeometryTraitsTestServicePtr.prototype.echoInsets = function() {
    return GeometryTraitsTestServiceProxy.prototype.echoInsets
        .apply(this.ptr.getProxy(), arguments);
  };

  GeometryTraitsTestServiceProxy.prototype.echoInsets = function(i) {
    var params_ = new GeometryTraitsTestService_EchoInsets_Params();
    params_.i = i;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kGeometryTraitsTestService_EchoInsets_Name,
          codec.align(GeometryTraitsTestService_EchoInsets_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(GeometryTraitsTestService_EchoInsets_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(GeometryTraitsTestService_EchoInsets_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  GeometryTraitsTestServicePtr.prototype.echoInsetsF = function() {
    return GeometryTraitsTestServiceProxy.prototype.echoInsetsF
        .apply(this.ptr.getProxy(), arguments);
  };

  GeometryTraitsTestServiceProxy.prototype.echoInsetsF = function(i) {
    var params_ = new GeometryTraitsTestService_EchoInsetsF_Params();
    params_.i = i;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kGeometryTraitsTestService_EchoInsetsF_Name,
          codec.align(GeometryTraitsTestService_EchoInsetsF_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(GeometryTraitsTestService_EchoInsetsF_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(GeometryTraitsTestService_EchoInsetsF_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  GeometryTraitsTestServicePtr.prototype.echoVector2d = function() {
    return GeometryTraitsTestServiceProxy.prototype.echoVector2d
        .apply(this.ptr.getProxy(), arguments);
  };

  GeometryTraitsTestServiceProxy.prototype.echoVector2d = function(v) {
    var params_ = new GeometryTraitsTestService_EchoVector2d_Params();
    params_.v = v;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kGeometryTraitsTestService_EchoVector2d_Name,
          codec.align(GeometryTraitsTestService_EchoVector2d_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(GeometryTraitsTestService_EchoVector2d_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(GeometryTraitsTestService_EchoVector2d_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  GeometryTraitsTestServicePtr.prototype.echoVector2dF = function() {
    return GeometryTraitsTestServiceProxy.prototype.echoVector2dF
        .apply(this.ptr.getProxy(), arguments);
  };

  GeometryTraitsTestServiceProxy.prototype.echoVector2dF = function(v) {
    var params_ = new GeometryTraitsTestService_EchoVector2dF_Params();
    params_.v = v;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kGeometryTraitsTestService_EchoVector2dF_Name,
          codec.align(GeometryTraitsTestService_EchoVector2dF_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(GeometryTraitsTestService_EchoVector2dF_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(GeometryTraitsTestService_EchoVector2dF_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  GeometryTraitsTestServicePtr.prototype.echoVector3dF = function() {
    return GeometryTraitsTestServiceProxy.prototype.echoVector3dF
        .apply(this.ptr.getProxy(), arguments);
  };

  GeometryTraitsTestServiceProxy.prototype.echoVector3dF = function(v) {
    var params_ = new GeometryTraitsTestService_EchoVector3dF_Params();
    params_.v = v;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kGeometryTraitsTestService_EchoVector3dF_Name,
          codec.align(GeometryTraitsTestService_EchoVector3dF_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(GeometryTraitsTestService_EchoVector3dF_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(GeometryTraitsTestService_EchoVector3dF_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  GeometryTraitsTestServicePtr.prototype.echoQuaternion = function() {
    return GeometryTraitsTestServiceProxy.prototype.echoQuaternion
        .apply(this.ptr.getProxy(), arguments);
  };

  GeometryTraitsTestServiceProxy.prototype.echoQuaternion = function(q) {
    var params_ = new GeometryTraitsTestService_EchoQuaternion_Params();
    params_.q = q;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kGeometryTraitsTestService_EchoQuaternion_Name,
          codec.align(GeometryTraitsTestService_EchoQuaternion_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(GeometryTraitsTestService_EchoQuaternion_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(GeometryTraitsTestService_EchoQuaternion_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  GeometryTraitsTestServicePtr.prototype.echoQuadF = function() {
    return GeometryTraitsTestServiceProxy.prototype.echoQuadF
        .apply(this.ptr.getProxy(), arguments);
  };

  GeometryTraitsTestServiceProxy.prototype.echoQuadF = function(q) {
    var params_ = new GeometryTraitsTestService_EchoQuadF_Params();
    params_.q = q;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kGeometryTraitsTestService_EchoQuadF_Name,
          codec.align(GeometryTraitsTestService_EchoQuadF_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(GeometryTraitsTestService_EchoQuadF_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(GeometryTraitsTestService_EchoQuadF_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };

  function GeometryTraitsTestServiceStub(delegate) {
    this.delegate_ = delegate;
  }
  GeometryTraitsTestServiceStub.prototype.echoPoint = function(p) {
    return this.delegate_ && this.delegate_.echoPoint && this.delegate_.echoPoint(p);
  }
  GeometryTraitsTestServiceStub.prototype.echoPointF = function(p) {
    return this.delegate_ && this.delegate_.echoPointF && this.delegate_.echoPointF(p);
  }
  GeometryTraitsTestServiceStub.prototype.echoPoint3F = function(p) {
    return this.delegate_ && this.delegate_.echoPoint3F && this.delegate_.echoPoint3F(p);
  }
  GeometryTraitsTestServiceStub.prototype.echoSize = function(s) {
    return this.delegate_ && this.delegate_.echoSize && this.delegate_.echoSize(s);
  }
  GeometryTraitsTestServiceStub.prototype.echoSizeF = function(s) {
    return this.delegate_ && this.delegate_.echoSizeF && this.delegate_.echoSizeF(s);
  }
  GeometryTraitsTestServiceStub.prototype.echoRect = function(r) {
    return this.delegate_ && this.delegate_.echoRect && this.delegate_.echoRect(r);
  }
  GeometryTraitsTestServiceStub.prototype.echoRectF = function(r) {
    return this.delegate_ && this.delegate_.echoRectF && this.delegate_.echoRectF(r);
  }
  GeometryTraitsTestServiceStub.prototype.echoInsets = function(i) {
    return this.delegate_ && this.delegate_.echoInsets && this.delegate_.echoInsets(i);
  }
  GeometryTraitsTestServiceStub.prototype.echoInsetsF = function(i) {
    return this.delegate_ && this.delegate_.echoInsetsF && this.delegate_.echoInsetsF(i);
  }
  GeometryTraitsTestServiceStub.prototype.echoVector2d = function(v) {
    return this.delegate_ && this.delegate_.echoVector2d && this.delegate_.echoVector2d(v);
  }
  GeometryTraitsTestServiceStub.prototype.echoVector2dF = function(v) {
    return this.delegate_ && this.delegate_.echoVector2dF && this.delegate_.echoVector2dF(v);
  }
  GeometryTraitsTestServiceStub.prototype.echoVector3dF = function(v) {
    return this.delegate_ && this.delegate_.echoVector3dF && this.delegate_.echoVector3dF(v);
  }
  GeometryTraitsTestServiceStub.prototype.echoQuaternion = function(q) {
    return this.delegate_ && this.delegate_.echoQuaternion && this.delegate_.echoQuaternion(q);
  }
  GeometryTraitsTestServiceStub.prototype.echoQuadF = function(q) {
    return this.delegate_ && this.delegate_.echoQuadF && this.delegate_.echoQuadF(q);
  }

  GeometryTraitsTestServiceStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  GeometryTraitsTestServiceStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kGeometryTraitsTestService_EchoPoint_Name:
      var params = reader.decodeStruct(GeometryTraitsTestService_EchoPoint_Params);
      this.echoPoint(params.p).then(function(response) {
        var responseParams =
            new GeometryTraitsTestService_EchoPoint_ResponseParams();
        responseParams.pass = response.pass;
        var builder = new codec.MessageV1Builder(
            kGeometryTraitsTestService_EchoPoint_Name,
            codec.align(GeometryTraitsTestService_EchoPoint_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(GeometryTraitsTestService_EchoPoint_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kGeometryTraitsTestService_EchoPointF_Name:
      var params = reader.decodeStruct(GeometryTraitsTestService_EchoPointF_Params);
      this.echoPointF(params.p).then(function(response) {
        var responseParams =
            new GeometryTraitsTestService_EchoPointF_ResponseParams();
        responseParams.pass = response.pass;
        var builder = new codec.MessageV1Builder(
            kGeometryTraitsTestService_EchoPointF_Name,
            codec.align(GeometryTraitsTestService_EchoPointF_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(GeometryTraitsTestService_EchoPointF_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kGeometryTraitsTestService_EchoPoint3F_Name:
      var params = reader.decodeStruct(GeometryTraitsTestService_EchoPoint3F_Params);
      this.echoPoint3F(params.p).then(function(response) {
        var responseParams =
            new GeometryTraitsTestService_EchoPoint3F_ResponseParams();
        responseParams.pass = response.pass;
        var builder = new codec.MessageV1Builder(
            kGeometryTraitsTestService_EchoPoint3F_Name,
            codec.align(GeometryTraitsTestService_EchoPoint3F_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(GeometryTraitsTestService_EchoPoint3F_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kGeometryTraitsTestService_EchoSize_Name:
      var params = reader.decodeStruct(GeometryTraitsTestService_EchoSize_Params);
      this.echoSize(params.s).then(function(response) {
        var responseParams =
            new GeometryTraitsTestService_EchoSize_ResponseParams();
        responseParams.pass = response.pass;
        var builder = new codec.MessageV1Builder(
            kGeometryTraitsTestService_EchoSize_Name,
            codec.align(GeometryTraitsTestService_EchoSize_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(GeometryTraitsTestService_EchoSize_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kGeometryTraitsTestService_EchoSizeF_Name:
      var params = reader.decodeStruct(GeometryTraitsTestService_EchoSizeF_Params);
      this.echoSizeF(params.s).then(function(response) {
        var responseParams =
            new GeometryTraitsTestService_EchoSizeF_ResponseParams();
        responseParams.pass = response.pass;
        var builder = new codec.MessageV1Builder(
            kGeometryTraitsTestService_EchoSizeF_Name,
            codec.align(GeometryTraitsTestService_EchoSizeF_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(GeometryTraitsTestService_EchoSizeF_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kGeometryTraitsTestService_EchoRect_Name:
      var params = reader.decodeStruct(GeometryTraitsTestService_EchoRect_Params);
      this.echoRect(params.r).then(function(response) {
        var responseParams =
            new GeometryTraitsTestService_EchoRect_ResponseParams();
        responseParams.pass = response.pass;
        var builder = new codec.MessageV1Builder(
            kGeometryTraitsTestService_EchoRect_Name,
            codec.align(GeometryTraitsTestService_EchoRect_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(GeometryTraitsTestService_EchoRect_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kGeometryTraitsTestService_EchoRectF_Name:
      var params = reader.decodeStruct(GeometryTraitsTestService_EchoRectF_Params);
      this.echoRectF(params.r).then(function(response) {
        var responseParams =
            new GeometryTraitsTestService_EchoRectF_ResponseParams();
        responseParams.pass = response.pass;
        var builder = new codec.MessageV1Builder(
            kGeometryTraitsTestService_EchoRectF_Name,
            codec.align(GeometryTraitsTestService_EchoRectF_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(GeometryTraitsTestService_EchoRectF_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kGeometryTraitsTestService_EchoInsets_Name:
      var params = reader.decodeStruct(GeometryTraitsTestService_EchoInsets_Params);
      this.echoInsets(params.i).then(function(response) {
        var responseParams =
            new GeometryTraitsTestService_EchoInsets_ResponseParams();
        responseParams.pass = response.pass;
        var builder = new codec.MessageV1Builder(
            kGeometryTraitsTestService_EchoInsets_Name,
            codec.align(GeometryTraitsTestService_EchoInsets_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(GeometryTraitsTestService_EchoInsets_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kGeometryTraitsTestService_EchoInsetsF_Name:
      var params = reader.decodeStruct(GeometryTraitsTestService_EchoInsetsF_Params);
      this.echoInsetsF(params.i).then(function(response) {
        var responseParams =
            new GeometryTraitsTestService_EchoInsetsF_ResponseParams();
        responseParams.pass = response.pass;
        var builder = new codec.MessageV1Builder(
            kGeometryTraitsTestService_EchoInsetsF_Name,
            codec.align(GeometryTraitsTestService_EchoInsetsF_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(GeometryTraitsTestService_EchoInsetsF_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kGeometryTraitsTestService_EchoVector2d_Name:
      var params = reader.decodeStruct(GeometryTraitsTestService_EchoVector2d_Params);
      this.echoVector2d(params.v).then(function(response) {
        var responseParams =
            new GeometryTraitsTestService_EchoVector2d_ResponseParams();
        responseParams.pass = response.pass;
        var builder = new codec.MessageV1Builder(
            kGeometryTraitsTestService_EchoVector2d_Name,
            codec.align(GeometryTraitsTestService_EchoVector2d_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(GeometryTraitsTestService_EchoVector2d_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kGeometryTraitsTestService_EchoVector2dF_Name:
      var params = reader.decodeStruct(GeometryTraitsTestService_EchoVector2dF_Params);
      this.echoVector2dF(params.v).then(function(response) {
        var responseParams =
            new GeometryTraitsTestService_EchoVector2dF_ResponseParams();
        responseParams.pass = response.pass;
        var builder = new codec.MessageV1Builder(
            kGeometryTraitsTestService_EchoVector2dF_Name,
            codec.align(GeometryTraitsTestService_EchoVector2dF_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(GeometryTraitsTestService_EchoVector2dF_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kGeometryTraitsTestService_EchoVector3dF_Name:
      var params = reader.decodeStruct(GeometryTraitsTestService_EchoVector3dF_Params);
      this.echoVector3dF(params.v).then(function(response) {
        var responseParams =
            new GeometryTraitsTestService_EchoVector3dF_ResponseParams();
        responseParams.pass = response.pass;
        var builder = new codec.MessageV1Builder(
            kGeometryTraitsTestService_EchoVector3dF_Name,
            codec.align(GeometryTraitsTestService_EchoVector3dF_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(GeometryTraitsTestService_EchoVector3dF_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kGeometryTraitsTestService_EchoQuaternion_Name:
      var params = reader.decodeStruct(GeometryTraitsTestService_EchoQuaternion_Params);
      this.echoQuaternion(params.q).then(function(response) {
        var responseParams =
            new GeometryTraitsTestService_EchoQuaternion_ResponseParams();
        responseParams.pass = response.pass;
        var builder = new codec.MessageV1Builder(
            kGeometryTraitsTestService_EchoQuaternion_Name,
            codec.align(GeometryTraitsTestService_EchoQuaternion_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(GeometryTraitsTestService_EchoQuaternion_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kGeometryTraitsTestService_EchoQuadF_Name:
      var params = reader.decodeStruct(GeometryTraitsTestService_EchoQuadF_Params);
      this.echoQuadF(params.q).then(function(response) {
        var responseParams =
            new GeometryTraitsTestService_EchoQuadF_ResponseParams();
        responseParams.pass = response.pass;
        var builder = new codec.MessageV1Builder(
            kGeometryTraitsTestService_EchoQuadF_Name,
            codec.align(GeometryTraitsTestService_EchoQuadF_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(GeometryTraitsTestService_EchoQuadF_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    default:
      return false;
    }
  };

  function validateGeometryTraitsTestServiceRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kGeometryTraitsTestService_EchoPoint_Name:
        if (message.expectsResponse())
          paramsClass = GeometryTraitsTestService_EchoPoint_Params;
      break;
      case kGeometryTraitsTestService_EchoPointF_Name:
        if (message.expectsResponse())
          paramsClass = GeometryTraitsTestService_EchoPointF_Params;
      break;
      case kGeometryTraitsTestService_EchoPoint3F_Name:
        if (message.expectsResponse())
          paramsClass = GeometryTraitsTestService_EchoPoint3F_Params;
      break;
      case kGeometryTraitsTestService_EchoSize_Name:
        if (message.expectsResponse())
          paramsClass = GeometryTraitsTestService_EchoSize_Params;
      break;
      case kGeometryTraitsTestService_EchoSizeF_Name:
        if (message.expectsResponse())
          paramsClass = GeometryTraitsTestService_EchoSizeF_Params;
      break;
      case kGeometryTraitsTestService_EchoRect_Name:
        if (message.expectsResponse())
          paramsClass = GeometryTraitsTestService_EchoRect_Params;
      break;
      case kGeometryTraitsTestService_EchoRectF_Name:
        if (message.expectsResponse())
          paramsClass = GeometryTraitsTestService_EchoRectF_Params;
      break;
      case kGeometryTraitsTestService_EchoInsets_Name:
        if (message.expectsResponse())
          paramsClass = GeometryTraitsTestService_EchoInsets_Params;
      break;
      case kGeometryTraitsTestService_EchoInsetsF_Name:
        if (message.expectsResponse())
          paramsClass = GeometryTraitsTestService_EchoInsetsF_Params;
      break;
      case kGeometryTraitsTestService_EchoVector2d_Name:
        if (message.expectsResponse())
          paramsClass = GeometryTraitsTestService_EchoVector2d_Params;
      break;
      case kGeometryTraitsTestService_EchoVector2dF_Name:
        if (message.expectsResponse())
          paramsClass = GeometryTraitsTestService_EchoVector2dF_Params;
      break;
      case kGeometryTraitsTestService_EchoVector3dF_Name:
        if (message.expectsResponse())
          paramsClass = GeometryTraitsTestService_EchoVector3dF_Params;
      break;
      case kGeometryTraitsTestService_EchoQuaternion_Name:
        if (message.expectsResponse())
          paramsClass = GeometryTraitsTestService_EchoQuaternion_Params;
      break;
      case kGeometryTraitsTestService_EchoQuadF_Name:
        if (message.expectsResponse())
          paramsClass = GeometryTraitsTestService_EchoQuadF_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateGeometryTraitsTestServiceResponse(messageValidator) {
   var message = messageValidator.message;
   var paramsClass = null;
   switch (message.getName()) {
      case kGeometryTraitsTestService_EchoPoint_Name:
        if (message.isResponse())
          paramsClass = GeometryTraitsTestService_EchoPoint_ResponseParams;
        break;
      case kGeometryTraitsTestService_EchoPointF_Name:
        if (message.isResponse())
          paramsClass = GeometryTraitsTestService_EchoPointF_ResponseParams;
        break;
      case kGeometryTraitsTestService_EchoPoint3F_Name:
        if (message.isResponse())
          paramsClass = GeometryTraitsTestService_EchoPoint3F_ResponseParams;
        break;
      case kGeometryTraitsTestService_EchoSize_Name:
        if (message.isResponse())
          paramsClass = GeometryTraitsTestService_EchoSize_ResponseParams;
        break;
      case kGeometryTraitsTestService_EchoSizeF_Name:
        if (message.isResponse())
          paramsClass = GeometryTraitsTestService_EchoSizeF_ResponseParams;
        break;
      case kGeometryTraitsTestService_EchoRect_Name:
        if (message.isResponse())
          paramsClass = GeometryTraitsTestService_EchoRect_ResponseParams;
        break;
      case kGeometryTraitsTestService_EchoRectF_Name:
        if (message.isResponse())
          paramsClass = GeometryTraitsTestService_EchoRectF_ResponseParams;
        break;
      case kGeometryTraitsTestService_EchoInsets_Name:
        if (message.isResponse())
          paramsClass = GeometryTraitsTestService_EchoInsets_ResponseParams;
        break;
      case kGeometryTraitsTestService_EchoInsetsF_Name:
        if (message.isResponse())
          paramsClass = GeometryTraitsTestService_EchoInsetsF_ResponseParams;
        break;
      case kGeometryTraitsTestService_EchoVector2d_Name:
        if (message.isResponse())
          paramsClass = GeometryTraitsTestService_EchoVector2d_ResponseParams;
        break;
      case kGeometryTraitsTestService_EchoVector2dF_Name:
        if (message.isResponse())
          paramsClass = GeometryTraitsTestService_EchoVector2dF_ResponseParams;
        break;
      case kGeometryTraitsTestService_EchoVector3dF_Name:
        if (message.isResponse())
          paramsClass = GeometryTraitsTestService_EchoVector3dF_ResponseParams;
        break;
      case kGeometryTraitsTestService_EchoQuaternion_Name:
        if (message.isResponse())
          paramsClass = GeometryTraitsTestService_EchoQuaternion_ResponseParams;
        break;
      case kGeometryTraitsTestService_EchoQuadF_Name:
        if (message.isResponse())
          paramsClass = GeometryTraitsTestService_EchoQuadF_ResponseParams;
        break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  var GeometryTraitsTestService = {
    name: 'gfx.mojom.GeometryTraitsTestService',
    kVersion: 0,
    ptrClass: GeometryTraitsTestServicePtr,
    proxyClass: GeometryTraitsTestServiceProxy,
    stubClass: GeometryTraitsTestServiceStub,
    validateRequest: validateGeometryTraitsTestServiceRequest,
    validateResponse: validateGeometryTraitsTestServiceResponse,
  };
  GeometryTraitsTestServiceStub.prototype.validator = validateGeometryTraitsTestServiceRequest;
  GeometryTraitsTestServiceProxy.prototype.validator = validateGeometryTraitsTestServiceResponse;
  exports.GeometryTraitsTestService = GeometryTraitsTestService;
  exports.GeometryTraitsTestServicePtr = GeometryTraitsTestServicePtr;
  exports.GeometryTraitsTestServiceAssociatedPtr = GeometryTraitsTestServiceAssociatedPtr;
})();