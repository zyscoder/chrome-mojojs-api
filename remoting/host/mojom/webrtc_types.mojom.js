// remoting/host/mojom/webrtc_types.mojom.js is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2014 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

(function() {
  var mojomId = 'remoting/host/mojom/webrtc_types.mojom';
  if (mojo.internal.isMojomLoaded(mojomId)) {
    console.warn('The following mojom is loaded multiple times: ' + mojomId);
    return;
  }
  mojo.internal.markMojomLoaded(mojomId);
  var bindings = mojo;
  var associatedBindings = mojo;
  var codec = mojo.internal;
  var validator = mojo.internal;

  var exports = mojo.internal.exposeNamespace('remoting.mojom');


  var DesktopCaptureResult = {};
  DesktopCaptureResult.kSuccess = 0;
  DesktopCaptureResult.kErrorTemporary = 1;
  DesktopCaptureResult.kErrorPermanent = 2;
  DesktopCaptureResult.MIN_VALUE = 0;
  DesktopCaptureResult.MAX_VALUE = 2;

  DesktopCaptureResult.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    }
    return false;
  };

  DesktopCaptureResult.toKnownEnumValue = function(value) {
    return value;
  };

  DesktopCaptureResult.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };

  function DesktopCaptureOptions(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  DesktopCaptureOptions.prototype.initDefaults_ = function() {
    this.useUpdateNotifications = false;
    this.detectUpdatedRegion = false;
  };
  DesktopCaptureOptions.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  DesktopCaptureOptions.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    return validator.validationError.NONE;
  };

  DesktopCaptureOptions.encodedSize = codec.kStructHeaderSize + 8;

  DesktopCaptureOptions.decode = function(decoder) {
    var packed;
    var val = new DesktopCaptureOptions();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    packed = decoder.readUint8();
    val.useUpdateNotifications = (packed >> 0) & 1 ? true : false;
    val.detectUpdatedRegion = (packed >> 1) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  DesktopCaptureOptions.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(DesktopCaptureOptions.encodedSize);
    encoder.writeUint32(0);
    packed = 0;
    packed |= (val.useUpdateNotifications & 1) << 0
    packed |= (val.detectUpdatedRegion & 1) << 1
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function DesktopFrame(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  DesktopFrame.prototype.initDefaults_ = function() {
    this.sharedBufferId = 0;
    this.stride = 0;
    this.size = null;
    this.dirtyRegion = null;
    this.captureTimeMs = 0;
    this.dpi = null;
    this.capturerId = 0;
  };
  DesktopFrame.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  DesktopFrame.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 56}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;




    // validate DesktopFrame.size
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, DesktopSize, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate DesktopFrame.dirtyRegion
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 16, 8, new codec.PointerTo(DesktopRect), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;



    // validate DesktopFrame.dpi
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 32, DesktopVector, false);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  DesktopFrame.encodedSize = codec.kStructHeaderSize + 48;

  DesktopFrame.decode = function(decoder) {
    var packed;
    var val = new DesktopFrame();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.sharedBufferId =
        decoder.decodeStruct(codec.Int32);
    val.stride =
        decoder.decodeStruct(codec.Int32);
    val.size =
        decoder.decodeStructPointer(DesktopSize);
    val.dirtyRegion =
        decoder.decodeArrayPointer(new codec.PointerTo(DesktopRect));
    val.captureTimeMs =
        decoder.decodeStruct(codec.Int64);
    val.dpi =
        decoder.decodeStructPointer(DesktopVector);
    val.capturerId =
        decoder.decodeStruct(codec.Uint32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  DesktopFrame.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(DesktopFrame.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.sharedBufferId);
    encoder.encodeStruct(codec.Int32, val.stride);
    encoder.encodeStructPointer(DesktopSize, val.size);
    encoder.encodeArrayPointer(new codec.PointerTo(DesktopRect), val.dirtyRegion);
    encoder.encodeStruct(codec.Int64, val.captureTimeMs);
    encoder.encodeStructPointer(DesktopVector, val.dpi);
    encoder.encodeStruct(codec.Uint32, val.capturerId);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function DesktopRect(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  DesktopRect.prototype.initDefaults_ = function() {
    this.left = 0;
    this.top = 0;
    this.right = 0;
    this.bottom = 0;
  };
  DesktopRect.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  DesktopRect.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;





    return validator.validationError.NONE;
  };

  DesktopRect.encodedSize = codec.kStructHeaderSize + 16;

  DesktopRect.decode = function(decoder) {
    var packed;
    var val = new DesktopRect();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.left =
        decoder.decodeStruct(codec.Int32);
    val.top =
        decoder.decodeStruct(codec.Int32);
    val.right =
        decoder.decodeStruct(codec.Int32);
    val.bottom =
        decoder.decodeStruct(codec.Int32);
    return val;
  };

  DesktopRect.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(DesktopRect.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.left);
    encoder.encodeStruct(codec.Int32, val.top);
    encoder.encodeStruct(codec.Int32, val.right);
    encoder.encodeStruct(codec.Int32, val.bottom);
  };
  function DesktopSize(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  DesktopSize.prototype.initDefaults_ = function() {
    this.width = 0;
    this.height = 0;
  };
  DesktopSize.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  DesktopSize.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    return validator.validationError.NONE;
  };

  DesktopSize.encodedSize = codec.kStructHeaderSize + 8;

  DesktopSize.decode = function(decoder) {
    var packed;
    var val = new DesktopSize();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.width =
        decoder.decodeStruct(codec.Int32);
    val.height =
        decoder.decodeStruct(codec.Int32);
    return val;
  };

  DesktopSize.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(DesktopSize.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.width);
    encoder.encodeStruct(codec.Int32, val.height);
  };
  function DesktopVector(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  DesktopVector.prototype.initDefaults_ = function() {
    this.x = 0;
    this.y = 0;
  };
  DesktopVector.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  DesktopVector.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    return validator.validationError.NONE;
  };

  DesktopVector.encodedSize = codec.kStructHeaderSize + 8;

  DesktopVector.decode = function(decoder) {
    var packed;
    var val = new DesktopVector();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.x =
        decoder.decodeStruct(codec.Int32);
    val.y =
        decoder.decodeStruct(codec.Int32);
    return val;
  };

  DesktopVector.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(DesktopVector.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.x);
    encoder.encodeStruct(codec.Int32, val.y);
  };
  function MouseCursor(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  MouseCursor.prototype.initDefaults_ = function() {
    this.imageSize = null;
    this.imageData = null;
    this.hotspot = null;
  };
  MouseCursor.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  MouseCursor.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 32}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate MouseCursor.imageSize
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, DesktopSize, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate MouseCursor.imageData
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 8, 1, codec.Uint8, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate MouseCursor.hotspot
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, DesktopVector, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  MouseCursor.encodedSize = codec.kStructHeaderSize + 24;

  MouseCursor.decode = function(decoder) {
    var packed;
    var val = new MouseCursor();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.imageSize =
        decoder.decodeStructPointer(DesktopSize);
    val.imageData =
        decoder.decodeArrayPointer(codec.Uint8);
    val.hotspot =
        decoder.decodeStructPointer(DesktopVector);
    return val;
  };

  MouseCursor.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(MouseCursor.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(DesktopSize, val.imageSize);
    encoder.encodeArrayPointer(codec.Uint8, val.imageData);
    encoder.encodeStructPointer(DesktopVector, val.hotspot);
  };
  exports.DesktopCaptureResult = DesktopCaptureResult;
  exports.DesktopCaptureOptions = DesktopCaptureOptions;
  exports.DesktopFrame = DesktopFrame;
  exports.DesktopRect = DesktopRect;
  exports.DesktopSize = DesktopSize;
  exports.DesktopVector = DesktopVector;
  exports.MouseCursor = MouseCursor;
})();