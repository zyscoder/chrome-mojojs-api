// device/vr/public/mojom/vr_service.mojom.js is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2014 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

(function() {
  var mojomId = 'device/vr/public/mojom/vr_service.mojom';
  if (mojo.internal.isMojomLoaded(mojomId)) {
    console.warn('The following mojom is loaded multiple times: ' + mojomId);
    return;
  }
  mojo.internal.markMojomLoaded(mojomId);
  var bindings = mojo;
  var associatedBindings = mojo;
  var codec = mojo.internal;
  var validator = mojo.internal;

  var exports = mojo.internal.exposeNamespace('device.mojom');
  var gamepad$ =
      mojo.internal.exposeNamespace('device.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'device/gamepad/public/mojom/gamepad.mojom', '../../../gamepad/public/mojom/gamepad.mojom.js');
  }
  var xr_session$ =
      mojo.internal.exposeNamespace('device.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'device/vr/public/mojom/xr_session.mojom', 'xr_session.mojom.js');
  }
  var big_buffer$ =
      mojo.internal.exposeNamespace('mojoBase.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'mojo/public/mojom/base/big_buffer.mojom', '../../../../mojo/public/mojom/base/big_buffer.mojom.js');
  }
  var time$ =
      mojo.internal.exposeNamespace('mojoBase.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'mojo/public/mojom/base/time.mojom', '../../../../mojo/public/mojom/base/time.mojom.js');
  }
  var mailbox_holder$ =
      mojo.internal.exposeNamespace('gpu.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'gpu/ipc/common/mailbox_holder.mojom', '../../../../gpu/ipc/common/mailbox_holder.mojom.js');
  }
  var sync_token$ =
      mojo.internal.exposeNamespace('gpu.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'gpu/ipc/common/sync_token.mojom', '../../../../gpu/ipc/common/sync_token.mojom.js');
  }
  var display$ =
      mojo.internal.exposeNamespace('display.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'ui/display/mojom/display.mojom', '../../../../ui/display/mojom/display.mojom.js');
  }
  var geometry$ =
      mojo.internal.exposeNamespace('gfx.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'ui/gfx/geometry/mojom/geometry.mojom', '../../../../ui/gfx/geometry/mojom/geometry.mojom.js');
  }
  var gpu_fence_handle$ =
      mojo.internal.exposeNamespace('gfx.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'ui/gfx/mojom/gpu_fence_handle.mojom', '../../../../ui/gfx/mojom/gpu_fence_handle.mojom.js');
  }
  var transform$ =
      mojo.internal.exposeNamespace('gfx.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'ui/gfx/mojom/transform.mojom', '../../../../ui/gfx/mojom/transform.mojom.js');
  }


  var XRHandedness = {};
  XRHandedness.NONE = 0;
  XRHandedness.LEFT = 1;
  XRHandedness.RIGHT = 2;
  XRHandedness.MIN_VALUE = 0;
  XRHandedness.MAX_VALUE = 2;

  XRHandedness.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    }
    return false;
  };

  XRHandedness.toKnownEnumValue = function(value) {
    return value;
  };

  XRHandedness.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var XRTargetRayMode = {};
  XRTargetRayMode.GAZING = 1;
  XRTargetRayMode.POINTING = 2;
  XRTargetRayMode.TAPPING = 3;
  XRTargetRayMode.MIN_VALUE = 1;
  XRTargetRayMode.MAX_VALUE = 3;

  XRTargetRayMode.isKnownEnumValue = function(value) {
    switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    }
    return false;
  };

  XRTargetRayMode.toKnownEnumValue = function(value) {
    return value;
  };

  XRTargetRayMode.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var XRSessionFeatureRequestStatus = {};
  XRSessionFeatureRequestStatus.kNotRequested = 0;
  XRSessionFeatureRequestStatus.kRequired = 1;
  XRSessionFeatureRequestStatus.kOptionalAccepted = 2;
  XRSessionFeatureRequestStatus.kOptionalRejected = 3;
  XRSessionFeatureRequestStatus.MIN_VALUE = 0;
  XRSessionFeatureRequestStatus.MAX_VALUE = 3;

  XRSessionFeatureRequestStatus.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    }
    return false;
  };

  XRSessionFeatureRequestStatus.toKnownEnumValue = function(value) {
    return value;
  };

  XRSessionFeatureRequestStatus.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var XREnvironmentBlendMode = {};
  XREnvironmentBlendMode.kOpaque = 1;
  XREnvironmentBlendMode.kAlphaBlend = 2;
  XREnvironmentBlendMode.kAdditive = 3;
  XREnvironmentBlendMode.MIN_VALUE = 1;
  XREnvironmentBlendMode.MAX_VALUE = 3;

  XREnvironmentBlendMode.isKnownEnumValue = function(value) {
    switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    }
    return false;
  };

  XREnvironmentBlendMode.toKnownEnumValue = function(value) {
    return value;
  };

  XREnvironmentBlendMode.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var XRInteractionMode = {};
  XRInteractionMode.kScreenSpace = 1;
  XRInteractionMode.kWorldSpace = 2;
  XRInteractionMode.MIN_VALUE = 1;
  XRInteractionMode.MAX_VALUE = 2;

  XRInteractionMode.isKnownEnumValue = function(value) {
    switch (value) {
    case 1:
    case 2:
      return true;
    }
    return false;
  };

  XRInteractionMode.toKnownEnumValue = function(value) {
    return value;
  };

  XRInteractionMode.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var XRHandJoint = {};
  XRHandJoint.kWrist = 0;
  XRHandJoint.kThumbMetacarpal = 1;
  XRHandJoint.kThumbPhalanxProximal = 2;
  XRHandJoint.kThumbPhalanxDistal = 3;
  XRHandJoint.kThumbTip = 4;
  XRHandJoint.kIndexFingerMetacarpal = 5;
  XRHandJoint.kIndexFingerPhalanxProximal = 6;
  XRHandJoint.kIndexFingerPhalanxIntermediate = 7;
  XRHandJoint.kIndexFingerPhalanxDistal = 8;
  XRHandJoint.kIndexFingerTip = 9;
  XRHandJoint.kMiddleFingerMetacarpal = 10;
  XRHandJoint.kMiddleFingerPhalanxProximal = 11;
  XRHandJoint.kMiddleFingerPhalanxIntermediate = 12;
  XRHandJoint.kMiddleFingerPhalanxDistal = 13;
  XRHandJoint.kMiddleFingerTip = 14;
  XRHandJoint.kRingFingerMetacarpal = 15;
  XRHandJoint.kRingFingerPhalanxProximal = 16;
  XRHandJoint.kRingFingerPhalanxIntermediate = 17;
  XRHandJoint.kRingFingerPhalanxDistal = 18;
  XRHandJoint.kRingFingerTip = 19;
  XRHandJoint.kPinkyFingerMetacarpal = 20;
  XRHandJoint.kPinkyFingerPhalanxProximal = 21;
  XRHandJoint.kPinkyFingerPhalanxIntermediate = 22;
  XRHandJoint.kPinkyFingerPhalanxDistal = 23;
  XRHandJoint.kPinkyFingerTip = 24;
  XRHandJoint.MIN_VALUE = 0;
  XRHandJoint.MAX_VALUE = 24;

  XRHandJoint.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
      return true;
    }
    return false;
  };

  XRHandJoint.toKnownEnumValue = function(value) {
    return value;
  };

  XRHandJoint.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var XREye = {};
  XREye.kNone = 0;
  XREye.kLeft = 1;
  XREye.kRight = 2;
  XREye.MIN_VALUE = 0;
  XREye.MAX_VALUE = 2;

  XREye.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    }
    return false;
  };

  XREye.toKnownEnumValue = function(value) {
    return value;
  };

  XREye.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var XRPresentationTransportMethod = {};
  XRPresentationTransportMethod.NONE = 0;
  XRPresentationTransportMethod.SUBMIT_AS_TEXTURE_HANDLE = 1;
  XRPresentationTransportMethod.SUBMIT_AS_MAILBOX_HOLDER = 2;
  XRPresentationTransportMethod.DRAW_INTO_TEXTURE_MAILBOX = 3;
  XRPresentationTransportMethod.MIN_VALUE = 0;
  XRPresentationTransportMethod.MAX_VALUE = 3;

  XRPresentationTransportMethod.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    }
    return false;
  };

  XRPresentationTransportMethod.toKnownEnumValue = function(value) {
    return value;
  };

  XRPresentationTransportMethod.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var XRReferenceSpaceType = {};
  XRReferenceSpaceType.kViewer = 0;
  XRReferenceSpaceType.kLocal = 1;
  XRReferenceSpaceType.kLocalFloor = 2;
  XRReferenceSpaceType.kBoundedFloor = 3;
  XRReferenceSpaceType.kUnbounded = 4;
  XRReferenceSpaceType.MIN_VALUE = 0;
  XRReferenceSpaceType.MAX_VALUE = 4;

  XRReferenceSpaceType.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    }
    return false;
  };

  XRReferenceSpaceType.toKnownEnumValue = function(value) {
    return value;
  };

  XRReferenceSpaceType.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var XRInputSourceSpaceType = {};
  XRInputSourceSpaceType.kTargetRay = 0;
  XRInputSourceSpaceType.kGrip = 1;
  XRInputSourceSpaceType.MIN_VALUE = 0;
  XRInputSourceSpaceType.MAX_VALUE = 1;

  XRInputSourceSpaceType.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
      return true;
    }
    return false;
  };

  XRInputSourceSpaceType.toKnownEnumValue = function(value) {
    return value;
  };

  XRInputSourceSpaceType.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var XRPlaneOrientation = {};
  XRPlaneOrientation.UNKNOWN = 0;
  XRPlaneOrientation.HORIZONTAL = 1;
  XRPlaneOrientation.VERTICAL = 2;
  XRPlaneOrientation.MIN_VALUE = 0;
  XRPlaneOrientation.MAX_VALUE = 2;

  XRPlaneOrientation.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    }
    return false;
  };

  XRPlaneOrientation.toKnownEnumValue = function(value) {
    return value;
  };

  XRPlaneOrientation.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var XrCompatibleResult = {};
  XrCompatibleResult.kAlreadyCompatible = 0;
  XrCompatibleResult.kNoDeviceAvailable = 1;
  XrCompatibleResult.kWebXrFeaturePolicyBlocked = 2;
  XrCompatibleResult.kCompatibleAfterRestart = 3;
  XrCompatibleResult.kNotCompatibleAfterRestart = 4;
  XrCompatibleResult.MIN_VALUE = 0;
  XrCompatibleResult.MAX_VALUE = 4;

  XrCompatibleResult.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    }
    return false;
  };

  XrCompatibleResult.toKnownEnumValue = function(value) {
    return value;
  };

  XrCompatibleResult.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var CreateAnchorResult = {};
  CreateAnchorResult.SUCCESS = 0;
  CreateAnchorResult.FAILURE = 1;
  CreateAnchorResult.MIN_VALUE = 0;
  CreateAnchorResult.MAX_VALUE = 1;

  CreateAnchorResult.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
      return true;
    }
    return false;
  };

  CreateAnchorResult.toKnownEnumValue = function(value) {
    return value;
  };

  CreateAnchorResult.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var SubscribeToHitTestResult = {};
  SubscribeToHitTestResult.SUCCESS = 0;
  SubscribeToHitTestResult.FAILURE_GENERIC = 1;
  SubscribeToHitTestResult.MIN_VALUE = 0;
  SubscribeToHitTestResult.MAX_VALUE = 1;

  SubscribeToHitTestResult.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
      return true;
    }
    return false;
  };

  SubscribeToHitTestResult.toKnownEnumValue = function(value) {
    return value;
  };

  SubscribeToHitTestResult.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var EntityTypeForHitTest = {};
  EntityTypeForHitTest.POINT = 1;
  EntityTypeForHitTest.PLANE = 2;
  EntityTypeForHitTest.MIN_VALUE = 1;
  EntityTypeForHitTest.MAX_VALUE = 2;

  EntityTypeForHitTest.isKnownEnumValue = function(value) {
    switch (value) {
    case 1:
    case 2:
      return true;
    }
    return false;
  };

  EntityTypeForHitTest.toKnownEnumValue = function(value) {
    return value;
  };

  EntityTypeForHitTest.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var XRVisibilityState = {};
  XRVisibilityState.VISIBLE = 1;
  XRVisibilityState.VISIBLE_BLURRED = 2;
  XRVisibilityState.HIDDEN = 3;
  XRVisibilityState.MIN_VALUE = 1;
  XRVisibilityState.MAX_VALUE = 3;

  XRVisibilityState.isKnownEnumValue = function(value) {
    switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    }
    return false;
  };

  XRVisibilityState.toKnownEnumValue = function(value) {
    return value;
  };

  XRVisibilityState.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };

  function XRDepthConfig(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRDepthConfig.prototype.initDefaults_ = function() {
    this.depthUsage = 0;
    this.depthDataFormat = 0;
  };
  XRDepthConfig.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRDepthConfig.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRDepthConfig.depthUsage
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, xr_session$.XRDepthUsage);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRDepthConfig.depthDataFormat
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 4, xr_session$.XRDepthDataFormat);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRDepthConfig.encodedSize = codec.kStructHeaderSize + 8;

  XRDepthConfig.decode = function(decoder) {
    var packed;
    var val = new XRDepthConfig();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.depthUsage =
        decoder.decodeStruct(new codec.Enum(xr_session$.XRDepthUsage));
    val.depthDataFormat =
        decoder.decodeStruct(new codec.Enum(xr_session$.XRDepthDataFormat));
    return val;
  };

  XRDepthConfig.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRDepthConfig.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.depthUsage);
    encoder.encodeStruct(codec.Int32, val.depthDataFormat);
  };
  function XRSessionDeviceConfig(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRSessionDeviceConfig.prototype.initDefaults_ = function() {
    this.defaultFramebufferScale = 1.0;
    this.supportsViewportScaling = false;
    this.enableAntiAliasing = true;
    this.views = null;
    this.depthConfiguration = null;
  };
  XRSessionDeviceConfig.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRSessionDeviceConfig.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 32}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    // validate XRSessionDeviceConfig.views
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 8, 8, new codec.PointerTo(XRView), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;




    // validate XRSessionDeviceConfig.depthConfiguration
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, XRDepthConfig, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRSessionDeviceConfig.encodedSize = codec.kStructHeaderSize + 24;

  XRSessionDeviceConfig.decode = function(decoder) {
    var packed;
    var val = new XRSessionDeviceConfig();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.defaultFramebufferScale =
        decoder.decodeStruct(codec.Float);
    packed = decoder.readUint8();
    val.supportsViewportScaling = (packed >> 0) & 1 ? true : false;
    val.enableAntiAliasing = (packed >> 1) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.views =
        decoder.decodeArrayPointer(new codec.PointerTo(XRView));
    val.depthConfiguration =
        decoder.decodeStructPointer(XRDepthConfig);
    return val;
  };

  XRSessionDeviceConfig.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRSessionDeviceConfig.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Float, val.defaultFramebufferScale);
    packed = 0;
    packed |= (val.supportsViewportScaling & 1) << 0
    packed |= (val.enableAntiAliasing & 1) << 1
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeArrayPointer(new codec.PointerTo(XRView), val.views);
    encoder.encodeStructPointer(XRDepthConfig, val.depthConfiguration);
  };
  function XRSession(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRSession.prototype.initDefaults_ = function() {
    this.dataProvider = new XRFrameDataProviderPtr();
    this.clientReceiver = new bindings.InterfaceRequest();
    this.enviromentBlendMode = 0;
    this.submitFrameSink = null;
    this.enabledFeatures = null;
    this.deviceConfig = null;
    this.interactionMode = 0;
  };
  XRSession.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRSession.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 56}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRSession.dataProvider
    err = messageValidator.validateInterface(offset + codec.kStructHeaderSize + 0, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRSession.clientReceiver
    err = messageValidator.validateInterfaceRequest(offset + codec.kStructHeaderSize + 8, true)
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRSession.submitFrameSink
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, XRPresentationConnection, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRSession.enabledFeatures
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 24, 4, new codec.Enum(xr_session$.XRSessionFeature), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRSession.deviceConfig
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 32, XRSessionDeviceConfig, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRSession.enviromentBlendMode
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 12, XREnvironmentBlendMode);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRSession.interactionMode
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 40, XRInteractionMode);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRSession.encodedSize = codec.kStructHeaderSize + 48;

  XRSession.decode = function(decoder) {
    var packed;
    var val = new XRSession();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.dataProvider =
        decoder.decodeStruct(new codec.Interface(XRFrameDataProviderPtr));
    val.clientReceiver =
        decoder.decodeStruct(codec.NullableInterfaceRequest);
    val.enviromentBlendMode =
        decoder.decodeStruct(new codec.Enum(XREnvironmentBlendMode));
    val.submitFrameSink =
        decoder.decodeStructPointer(XRPresentationConnection);
    val.enabledFeatures =
        decoder.decodeArrayPointer(new codec.Enum(xr_session$.XRSessionFeature));
    val.deviceConfig =
        decoder.decodeStructPointer(XRSessionDeviceConfig);
    val.interactionMode =
        decoder.decodeStruct(new codec.Enum(XRInteractionMode));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  XRSession.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRSession.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(new codec.Interface(XRFrameDataProviderPtr), val.dataProvider);
    encoder.encodeStruct(codec.NullableInterfaceRequest, val.clientReceiver);
    encoder.encodeStruct(codec.Int32, val.enviromentBlendMode);
    encoder.encodeStructPointer(XRPresentationConnection, val.submitFrameSink);
    encoder.encodeArrayPointer(new codec.Enum(xr_session$.XRSessionFeature), val.enabledFeatures);
    encoder.encodeStructPointer(XRSessionDeviceConfig, val.deviceConfig);
    encoder.encodeStruct(codec.Int32, val.interactionMode);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function XRPresentationConnection(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRPresentationConnection.prototype.initDefaults_ = function() {
    this.provider = new XRPresentationProviderPtr();
    this.clientReceiver = new bindings.InterfaceRequest();
    this.transportOptions = null;
  };
  XRPresentationConnection.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRPresentationConnection.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 32}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRPresentationConnection.provider
    err = messageValidator.validateInterface(offset + codec.kStructHeaderSize + 0, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRPresentationConnection.clientReceiver
    err = messageValidator.validateInterfaceRequest(offset + codec.kStructHeaderSize + 8, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRPresentationConnection.transportOptions
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, XRPresentationTransportOptions, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRPresentationConnection.encodedSize = codec.kStructHeaderSize + 24;

  XRPresentationConnection.decode = function(decoder) {
    var packed;
    var val = new XRPresentationConnection();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.provider =
        decoder.decodeStruct(new codec.Interface(XRPresentationProviderPtr));
    val.clientReceiver =
        decoder.decodeStruct(codec.InterfaceRequest);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.transportOptions =
        decoder.decodeStructPointer(XRPresentationTransportOptions);
    return val;
  };

  XRPresentationConnection.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRPresentationConnection.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(new codec.Interface(XRPresentationProviderPtr), val.provider);
    encoder.encodeStruct(codec.InterfaceRequest, val.clientReceiver);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStructPointer(XRPresentationTransportOptions, val.transportOptions);
  };
  function XRInputSourceDescription(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRInputSourceDescription.prototype.initDefaults_ = function() {
    this.targetRayMode = 0;
    this.handedness = 0;
    this.inputFromPointer = null;
    this.profiles = null;
  };
  XRInputSourceDescription.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRInputSourceDescription.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 32}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRInputSourceDescription.targetRayMode
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, XRTargetRayMode);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRInputSourceDescription.handedness
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 4, XRHandedness);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRInputSourceDescription.inputFromPointer
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, transform$.Transform, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRInputSourceDescription.profiles
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 16, 8, codec.String, false, [0, 0], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRInputSourceDescription.encodedSize = codec.kStructHeaderSize + 24;

  XRInputSourceDescription.decode = function(decoder) {
    var packed;
    var val = new XRInputSourceDescription();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.targetRayMode =
        decoder.decodeStruct(new codec.Enum(XRTargetRayMode));
    val.handedness =
        decoder.decodeStruct(new codec.Enum(XRHandedness));
    val.inputFromPointer =
        decoder.decodeStructPointer(transform$.Transform);
    val.profiles =
        decoder.decodeArrayPointer(codec.String);
    return val;
  };

  XRInputSourceDescription.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRInputSourceDescription.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.targetRayMode);
    encoder.encodeStruct(codec.Int32, val.handedness);
    encoder.encodeStructPointer(transform$.Transform, val.inputFromPointer);
    encoder.encodeArrayPointer(codec.String, val.profiles);
  };
  function XRHandJointData(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRHandJointData.prototype.initDefaults_ = function() {
    this.joint = 0;
    this.radius = 0;
    this.mojoFromJoint = null;
  };
  XRHandJointData.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRHandJointData.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRHandJointData.joint
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, XRHandJoint);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRHandJointData.mojoFromJoint
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, transform$.Transform, true);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  XRHandJointData.encodedSize = codec.kStructHeaderSize + 16;

  XRHandJointData.decode = function(decoder) {
    var packed;
    var val = new XRHandJointData();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.joint =
        decoder.decodeStruct(new codec.Enum(XRHandJoint));
    val.radius =
        decoder.decodeStruct(codec.Float);
    val.mojoFromJoint =
        decoder.decodeStructPointer(transform$.Transform);
    return val;
  };

  XRHandJointData.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRHandJointData.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.joint);
    encoder.encodeStruct(codec.Float, val.radius);
    encoder.encodeStructPointer(transform$.Transform, val.mojoFromJoint);
  };
  function XRHandTrackingData(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRHandTrackingData.prototype.initDefaults_ = function() {
    this.handJointData = null;
  };
  XRHandTrackingData.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRHandTrackingData.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRHandTrackingData.handJointData
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 0, 8, new codec.PointerTo(XRHandJointData), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRHandTrackingData.encodedSize = codec.kStructHeaderSize + 8;

  XRHandTrackingData.decode = function(decoder) {
    var packed;
    var val = new XRHandTrackingData();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.handJointData =
        decoder.decodeArrayPointer(new codec.PointerTo(XRHandJointData));
    return val;
  };

  XRHandTrackingData.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRHandTrackingData.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeArrayPointer(new codec.PointerTo(XRHandJointData), val.handJointData);
  };
  function XRInputSourceState(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRInputSourceState.prototype.initDefaults_ = function() {
    this.sourceId = 0;
    this.emulatedPosition = false;
    this.isAuxiliary = false;
    this.primaryInputPressed = false;
    this.primaryInputClicked = false;
    this.primarySqueezePressed = false;
    this.primarySqueezeClicked = false;
    this.description = null;
    this.mojoFromInput = null;
    this.gamepad = null;
    this.overlayPointerPosition = null;
    this.handTrackingData = null;
  };
  XRInputSourceState.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRInputSourceState.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 56}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    // validate XRInputSourceState.description
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, XRInputSourceDescription, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRInputSourceState.mojoFromInput
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, transform$.Transform, true);
    if (err !== validator.validationError.NONE)
        return err;








    // validate XRInputSourceState.gamepad
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 24, gamepad$.Gamepad, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRInputSourceState.overlayPointerPosition
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 32, geometry$.PointF, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRInputSourceState.handTrackingData
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 40, XRHandTrackingData, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRInputSourceState.encodedSize = codec.kStructHeaderSize + 48;

  XRInputSourceState.decode = function(decoder) {
    var packed;
    var val = new XRInputSourceState();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.sourceId =
        decoder.decodeStruct(codec.Uint32);
    packed = decoder.readUint8();
    val.emulatedPosition = (packed >> 0) & 1 ? true : false;
    val.isAuxiliary = (packed >> 1) & 1 ? true : false;
    val.primaryInputPressed = (packed >> 2) & 1 ? true : false;
    val.primaryInputClicked = (packed >> 3) & 1 ? true : false;
    val.primarySqueezePressed = (packed >> 4) & 1 ? true : false;
    val.primarySqueezeClicked = (packed >> 5) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.description =
        decoder.decodeStructPointer(XRInputSourceDescription);
    val.mojoFromInput =
        decoder.decodeStructPointer(transform$.Transform);
    val.gamepad =
        decoder.decodeStructPointer(gamepad$.Gamepad);
    val.overlayPointerPosition =
        decoder.decodeStructPointer(geometry$.PointF);
    val.handTrackingData =
        decoder.decodeStructPointer(XRHandTrackingData);
    return val;
  };

  XRInputSourceState.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRInputSourceState.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint32, val.sourceId);
    packed = 0;
    packed |= (val.emulatedPosition & 1) << 0
    packed |= (val.isAuxiliary & 1) << 1
    packed |= (val.primaryInputPressed & 1) << 2
    packed |= (val.primaryInputClicked & 1) << 3
    packed |= (val.primarySqueezePressed & 1) << 4
    packed |= (val.primarySqueezeClicked & 1) << 5
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStructPointer(XRInputSourceDescription, val.description);
    encoder.encodeStructPointer(transform$.Transform, val.mojoFromInput);
    encoder.encodeStructPointer(gamepad$.Gamepad, val.gamepad);
    encoder.encodeStructPointer(geometry$.PointF, val.overlayPointerPosition);
    encoder.encodeStructPointer(XRHandTrackingData, val.handTrackingData);
  };
  function VRFieldOfView(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  VRFieldOfView.prototype.initDefaults_ = function() {
    this.upDegrees = 0;
    this.downDegrees = 0;
    this.leftDegrees = 0;
    this.rightDegrees = 0;
  };
  VRFieldOfView.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  VRFieldOfView.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;





    return validator.validationError.NONE;
  };

  VRFieldOfView.encodedSize = codec.kStructHeaderSize + 16;

  VRFieldOfView.decode = function(decoder) {
    var packed;
    var val = new VRFieldOfView();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.upDegrees =
        decoder.decodeStruct(codec.Float);
    val.downDegrees =
        decoder.decodeStruct(codec.Float);
    val.leftDegrees =
        decoder.decodeStruct(codec.Float);
    val.rightDegrees =
        decoder.decodeStruct(codec.Float);
    return val;
  };

  VRFieldOfView.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(VRFieldOfView.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Float, val.upDegrees);
    encoder.encodeStruct(codec.Float, val.downDegrees);
    encoder.encodeStruct(codec.Float, val.leftDegrees);
    encoder.encodeStruct(codec.Float, val.rightDegrees);
  };
  function VRPose(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  VRPose.prototype.initDefaults_ = function() {
    this.orientation = null;
    this.position = null;
    this.emulatedPosition = false;
  };
  VRPose.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  VRPose.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 32}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VRPose.orientation
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, geometry$.Quaternion, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VRPose.position
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, geometry$.Point3F, true);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  VRPose.encodedSize = codec.kStructHeaderSize + 24;

  VRPose.decode = function(decoder) {
    var packed;
    var val = new VRPose();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.orientation =
        decoder.decodeStructPointer(geometry$.Quaternion);
    val.position =
        decoder.decodeStructPointer(geometry$.Point3F);
    packed = decoder.readUint8();
    val.emulatedPosition = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  VRPose.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(VRPose.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(geometry$.Quaternion, val.orientation);
    encoder.encodeStructPointer(geometry$.Point3F, val.position);
    packed = 0;
    packed |= (val.emulatedPosition & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function Pose(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Pose.prototype.initDefaults_ = function() {
    this.orientation = null;
    this.position = null;
  };
  Pose.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Pose.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Pose.orientation
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, geometry$.Quaternion, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Pose.position
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, geometry$.Point3F, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  Pose.encodedSize = codec.kStructHeaderSize + 16;

  Pose.decode = function(decoder) {
    var packed;
    var val = new Pose();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.orientation =
        decoder.decodeStructPointer(geometry$.Quaternion);
    val.position =
        decoder.decodeStructPointer(geometry$.Point3F);
    return val;
  };

  Pose.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Pose.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(geometry$.Quaternion, val.orientation);
    encoder.encodeStructPointer(geometry$.Point3F, val.position);
  };
  function XRRay(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRRay.prototype.initDefaults_ = function() {
    this.origin = null;
    this.direction = null;
  };
  XRRay.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRRay.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRRay.origin
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, geometry$.Point3F, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRRay.direction
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, geometry$.Vector3dF, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRRay.encodedSize = codec.kStructHeaderSize + 16;

  XRRay.decode = function(decoder) {
    var packed;
    var val = new XRRay();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.origin =
        decoder.decodeStructPointer(geometry$.Point3F);
    val.direction =
        decoder.decodeStructPointer(geometry$.Vector3dF);
    return val;
  };

  XRRay.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRRay.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(geometry$.Point3F, val.origin);
    encoder.encodeStructPointer(geometry$.Vector3dF, val.direction);
  };
  function XRHitResult(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRHitResult.prototype.initDefaults_ = function() {
    this.mojoFromResult = null;
    this.planeId = 0;
  };
  XRHitResult.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRHitResult.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRHitResult.mojoFromResult
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, Pose, false);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  XRHitResult.encodedSize = codec.kStructHeaderSize + 16;

  XRHitResult.decode = function(decoder) {
    var packed;
    var val = new XRHitResult();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.mojoFromResult =
        decoder.decodeStructPointer(Pose);
    val.planeId =
        decoder.decodeStruct(codec.Uint64);
    return val;
  };

  XRHitResult.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRHitResult.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(Pose, val.mojoFromResult);
    encoder.encodeStruct(codec.Uint64, val.planeId);
  };
  function XRView(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRView.prototype.initDefaults_ = function() {
    this.eye = 0;
    this.isFirstPersonObserver = false;
    this.fieldOfView = null;
    this.mojoFromView = null;
    this.viewport = null;
  };
  XRView.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRView.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 40}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRView.eye
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, XREye);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRView.fieldOfView
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, VRFieldOfView, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRView.mojoFromView
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, transform$.Transform, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRView.viewport
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 24, geometry$.Rect, false);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  XRView.encodedSize = codec.kStructHeaderSize + 32;

  XRView.decode = function(decoder) {
    var packed;
    var val = new XRView();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.eye =
        decoder.decodeStruct(new codec.Enum(XREye));
    packed = decoder.readUint8();
    val.isFirstPersonObserver = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.fieldOfView =
        decoder.decodeStructPointer(VRFieldOfView);
    val.mojoFromView =
        decoder.decodeStructPointer(transform$.Transform);
    val.viewport =
        decoder.decodeStructPointer(geometry$.Rect);
    return val;
  };

  XRView.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRView.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.eye);
    packed = 0;
    packed |= (val.isFirstPersonObserver & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStructPointer(VRFieldOfView, val.fieldOfView);
    encoder.encodeStructPointer(transform$.Transform, val.mojoFromView);
    encoder.encodeStructPointer(geometry$.Rect, val.viewport);
  };
  function VRStageParameters(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  VRStageParameters.prototype.initDefaults_ = function() {
    this.mojoFromFloor = null;
    this.bounds = null;
  };
  VRStageParameters.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  VRStageParameters.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VRStageParameters.mojoFromFloor
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, transform$.Transform, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VRStageParameters.bounds
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 8, 8, new codec.PointerTo(geometry$.Point3F), true, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  VRStageParameters.encodedSize = codec.kStructHeaderSize + 16;

  VRStageParameters.decode = function(decoder) {
    var packed;
    var val = new VRStageParameters();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.mojoFromFloor =
        decoder.decodeStructPointer(transform$.Transform);
    val.bounds =
        decoder.decodeArrayPointer(new codec.PointerTo(geometry$.Point3F));
    return val;
  };

  VRStageParameters.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(VRStageParameters.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(transform$.Transform, val.mojoFromFloor);
    encoder.encodeArrayPointer(new codec.PointerTo(geometry$.Point3F), val.bounds);
  };
  function XRPresentationTransportOptions(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRPresentationTransportOptions.prototype.initDefaults_ = function() {
    this.transportMethod = 0;
    this.waitForTransferNotification = false;
    this.waitForRenderNotification = false;
    this.waitForGpuFence = false;
  };
  XRPresentationTransportOptions.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRPresentationTransportOptions.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRPresentationTransportOptions.transportMethod
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, XRPresentationTransportMethod);
    if (err !== validator.validationError.NONE)
        return err;




    return validator.validationError.NONE;
  };

  XRPresentationTransportOptions.encodedSize = codec.kStructHeaderSize + 8;

  XRPresentationTransportOptions.decode = function(decoder) {
    var packed;
    var val = new XRPresentationTransportOptions();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.transportMethod =
        decoder.decodeStruct(new codec.Enum(XRPresentationTransportMethod));
    packed = decoder.readUint8();
    val.waitForTransferNotification = (packed >> 0) & 1 ? true : false;
    val.waitForRenderNotification = (packed >> 1) & 1 ? true : false;
    val.waitForGpuFence = (packed >> 2) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  XRPresentationTransportOptions.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRPresentationTransportOptions.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.transportMethod);
    packed = 0;
    packed |= (val.waitForTransferNotification & 1) << 0
    packed |= (val.waitForRenderNotification & 1) << 1
    packed |= (val.waitForGpuFence & 1) << 2
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function XRInputSourceSpaceInfo(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRInputSourceSpaceInfo.prototype.initDefaults_ = function() {
    this.inputSourceId = 0;
    this.inputSourceSpaceType = 0;
  };
  XRInputSourceSpaceInfo.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRInputSourceSpaceInfo.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    // validate XRInputSourceSpaceInfo.inputSourceSpaceType
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 4, XRInputSourceSpaceType);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRInputSourceSpaceInfo.encodedSize = codec.kStructHeaderSize + 8;

  XRInputSourceSpaceInfo.decode = function(decoder) {
    var packed;
    var val = new XRInputSourceSpaceInfo();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.inputSourceId =
        decoder.decodeStruct(codec.Uint32);
    val.inputSourceSpaceType =
        decoder.decodeStruct(new codec.Enum(XRInputSourceSpaceType));
    return val;
  };

  XRInputSourceSpaceInfo.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRInputSourceSpaceInfo.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint32, val.inputSourceId);
    encoder.encodeStruct(codec.Int32, val.inputSourceSpaceType);
  };
  function XRHandJointSpaceInfo(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRHandJointSpaceInfo.prototype.initDefaults_ = function() {
    this.handedness = 0;
    this.joint = 0;
  };
  XRHandJointSpaceInfo.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRHandJointSpaceInfo.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRHandJointSpaceInfo.handedness
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, XRHandedness);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRHandJointSpaceInfo.joint
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 4, XRHandJoint);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRHandJointSpaceInfo.encodedSize = codec.kStructHeaderSize + 8;

  XRHandJointSpaceInfo.decode = function(decoder) {
    var packed;
    var val = new XRHandJointSpaceInfo();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.handedness =
        decoder.decodeStruct(new codec.Enum(XRHandedness));
    val.joint =
        decoder.decodeStruct(new codec.Enum(XRHandJoint));
    return val;
  };

  XRHandJointSpaceInfo.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRHandJointSpaceInfo.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.handedness);
    encoder.encodeStruct(codec.Int32, val.joint);
  };
  function XRPlanePointData(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRPlanePointData.prototype.initDefaults_ = function() {
    this.x = 0;
    this.z = 0;
  };
  XRPlanePointData.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRPlanePointData.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    return validator.validationError.NONE;
  };

  XRPlanePointData.encodedSize = codec.kStructHeaderSize + 8;

  XRPlanePointData.decode = function(decoder) {
    var packed;
    var val = new XRPlanePointData();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.x =
        decoder.decodeStruct(codec.Float);
    val.z =
        decoder.decodeStruct(codec.Float);
    return val;
  };

  XRPlanePointData.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRPlanePointData.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Float, val.x);
    encoder.encodeStruct(codec.Float, val.z);
  };
  function XRPlaneData(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRPlaneData.prototype.initDefaults_ = function() {
    this.id = 0;
    this.orientation = 0;
    this.mojoFromPlane = null;
    this.polygon = null;
  };
  XRPlaneData.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRPlaneData.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 40}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    // validate XRPlaneData.orientation
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 8, XRPlaneOrientation);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRPlaneData.mojoFromPlane
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, Pose, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRPlaneData.polygon
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 24, 8, new codec.PointerTo(XRPlanePointData), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRPlaneData.encodedSize = codec.kStructHeaderSize + 32;

  XRPlaneData.decode = function(decoder) {
    var packed;
    var val = new XRPlaneData();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.id =
        decoder.decodeStruct(codec.Uint64);
    val.orientation =
        decoder.decodeStruct(new codec.Enum(XRPlaneOrientation));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.mojoFromPlane =
        decoder.decodeStructPointer(Pose);
    val.polygon =
        decoder.decodeArrayPointer(new codec.PointerTo(XRPlanePointData));
    return val;
  };

  XRPlaneData.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRPlaneData.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint64, val.id);
    encoder.encodeStruct(codec.Int32, val.orientation);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStructPointer(Pose, val.mojoFromPlane);
    encoder.encodeArrayPointer(new codec.PointerTo(XRPlanePointData), val.polygon);
  };
  function XRPlaneDetectionData(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRPlaneDetectionData.prototype.initDefaults_ = function() {
    this.allPlanesIds = null;
    this.updatedPlanesData = null;
  };
  XRPlaneDetectionData.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRPlaneDetectionData.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRPlaneDetectionData.allPlanesIds
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 0, 8, codec.Uint64, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRPlaneDetectionData.updatedPlanesData
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 8, 8, new codec.PointerTo(XRPlaneData), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRPlaneDetectionData.encodedSize = codec.kStructHeaderSize + 16;

  XRPlaneDetectionData.decode = function(decoder) {
    var packed;
    var val = new XRPlaneDetectionData();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.allPlanesIds =
        decoder.decodeArrayPointer(codec.Uint64);
    val.updatedPlanesData =
        decoder.decodeArrayPointer(new codec.PointerTo(XRPlaneData));
    return val;
  };

  XRPlaneDetectionData.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRPlaneDetectionData.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeArrayPointer(codec.Uint64, val.allPlanesIds);
    encoder.encodeArrayPointer(new codec.PointerTo(XRPlaneData), val.updatedPlanesData);
  };
  function XRAnchorData(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRAnchorData.prototype.initDefaults_ = function() {
    this.id = 0;
    this.mojoFromAnchor = null;
  };
  XRAnchorData.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRAnchorData.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    // validate XRAnchorData.mojoFromAnchor
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, Pose, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRAnchorData.encodedSize = codec.kStructHeaderSize + 16;

  XRAnchorData.decode = function(decoder) {
    var packed;
    var val = new XRAnchorData();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.id =
        decoder.decodeStruct(codec.Uint64);
    val.mojoFromAnchor =
        decoder.decodeStructPointer(Pose);
    return val;
  };

  XRAnchorData.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRAnchorData.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint64, val.id);
    encoder.encodeStructPointer(Pose, val.mojoFromAnchor);
  };
  function XRAnchorsData(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRAnchorsData.prototype.initDefaults_ = function() {
    this.allAnchorsIds = null;
    this.updatedAnchorsData = null;
  };
  XRAnchorsData.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRAnchorsData.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRAnchorsData.allAnchorsIds
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 0, 8, codec.Uint64, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRAnchorsData.updatedAnchorsData
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 8, 8, new codec.PointerTo(XRAnchorData), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRAnchorsData.encodedSize = codec.kStructHeaderSize + 16;

  XRAnchorsData.decode = function(decoder) {
    var packed;
    var val = new XRAnchorsData();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.allAnchorsIds =
        decoder.decodeArrayPointer(codec.Uint64);
    val.updatedAnchorsData =
        decoder.decodeArrayPointer(new codec.PointerTo(XRAnchorData));
    return val;
  };

  XRAnchorsData.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRAnchorsData.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeArrayPointer(codec.Uint64, val.allAnchorsIds);
    encoder.encodeArrayPointer(new codec.PointerTo(XRAnchorData), val.updatedAnchorsData);
  };
  function XRHitTestSubscriptionResultData(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRHitTestSubscriptionResultData.prototype.initDefaults_ = function() {
    this.subscriptionId = 0;
    this.hitTestResults = null;
  };
  XRHitTestSubscriptionResultData.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRHitTestSubscriptionResultData.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    // validate XRHitTestSubscriptionResultData.hitTestResults
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 8, 8, new codec.PointerTo(XRHitResult), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRHitTestSubscriptionResultData.encodedSize = codec.kStructHeaderSize + 16;

  XRHitTestSubscriptionResultData.decode = function(decoder) {
    var packed;
    var val = new XRHitTestSubscriptionResultData();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.subscriptionId =
        decoder.decodeStruct(codec.Uint64);
    val.hitTestResults =
        decoder.decodeArrayPointer(new codec.PointerTo(XRHitResult));
    return val;
  };

  XRHitTestSubscriptionResultData.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRHitTestSubscriptionResultData.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint64, val.subscriptionId);
    encoder.encodeArrayPointer(new codec.PointerTo(XRHitResult), val.hitTestResults);
  };
  function XRHitTestTransientInputSubscriptionResultData(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRHitTestTransientInputSubscriptionResultData.prototype.initDefaults_ = function() {
    this.subscriptionId = 0;
    this.inputSourceIdToHitTestResults = null;
  };
  XRHitTestTransientInputSubscriptionResultData.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRHitTestTransientInputSubscriptionResultData.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    // validate XRHitTestTransientInputSubscriptionResultData.inputSourceIdToHitTestResults
    err = messageValidator.validateMapPointer(offset + codec.kStructHeaderSize + 8, false, codec.Uint32, new codec.ArrayOf(new codec.PointerTo(XRHitResult)), false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRHitTestTransientInputSubscriptionResultData.encodedSize = codec.kStructHeaderSize + 16;

  XRHitTestTransientInputSubscriptionResultData.decode = function(decoder) {
    var packed;
    var val = new XRHitTestTransientInputSubscriptionResultData();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.subscriptionId =
        decoder.decodeStruct(codec.Uint64);
    val.inputSourceIdToHitTestResults =
        decoder.decodeMapPointer(codec.Uint32, new codec.ArrayOf(new codec.PointerTo(XRHitResult)));
    return val;
  };

  XRHitTestTransientInputSubscriptionResultData.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRHitTestTransientInputSubscriptionResultData.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint64, val.subscriptionId);
    encoder.encodeMapPointer(codec.Uint32, new codec.ArrayOf(new codec.PointerTo(XRHitResult)), val.inputSourceIdToHitTestResults);
  };
  function XRHitTestSubscriptionResultsData(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRHitTestSubscriptionResultsData.prototype.initDefaults_ = function() {
    this.results = null;
    this.transientInputResults = null;
  };
  XRHitTestSubscriptionResultsData.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRHitTestSubscriptionResultsData.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRHitTestSubscriptionResultsData.results
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 0, 8, new codec.PointerTo(XRHitTestSubscriptionResultData), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRHitTestSubscriptionResultsData.transientInputResults
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 8, 8, new codec.PointerTo(XRHitTestTransientInputSubscriptionResultData), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRHitTestSubscriptionResultsData.encodedSize = codec.kStructHeaderSize + 16;

  XRHitTestSubscriptionResultsData.decode = function(decoder) {
    var packed;
    var val = new XRHitTestSubscriptionResultsData();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.results =
        decoder.decodeArrayPointer(new codec.PointerTo(XRHitTestSubscriptionResultData));
    val.transientInputResults =
        decoder.decodeArrayPointer(new codec.PointerTo(XRHitTestTransientInputSubscriptionResultData));
    return val;
  };

  XRHitTestSubscriptionResultsData.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRHitTestSubscriptionResultsData.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeArrayPointer(new codec.PointerTo(XRHitTestSubscriptionResultData), val.results);
    encoder.encodeArrayPointer(new codec.PointerTo(XRHitTestTransientInputSubscriptionResultData), val.transientInputResults);
  };
  function RgbTupleF32(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  RgbTupleF32.prototype.initDefaults_ = function() {
    this.red = 0;
    this.green = 0;
    this.blue = 0;
  };
  RgbTupleF32.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  RgbTupleF32.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;




    return validator.validationError.NONE;
  };

  RgbTupleF32.encodedSize = codec.kStructHeaderSize + 16;

  RgbTupleF32.decode = function(decoder) {
    var packed;
    var val = new RgbTupleF32();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.red =
        decoder.decodeStruct(codec.Float);
    val.green =
        decoder.decodeStruct(codec.Float);
    val.blue =
        decoder.decodeStruct(codec.Float);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  RgbTupleF32.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(RgbTupleF32.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Float, val.red);
    encoder.encodeStruct(codec.Float, val.green);
    encoder.encodeStruct(codec.Float, val.blue);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function XRSphericalHarmonics(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRSphericalHarmonics.prototype.initDefaults_ = function() {
    this.coefficients = null;
  };
  XRSphericalHarmonics.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRSphericalHarmonics.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRSphericalHarmonics.coefficients
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 0, 8, new codec.PointerTo(RgbTupleF32), false, [9], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRSphericalHarmonics.encodedSize = codec.kStructHeaderSize + 8;

  XRSphericalHarmonics.decode = function(decoder) {
    var packed;
    var val = new XRSphericalHarmonics();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.coefficients =
        decoder.decodeArrayPointer(new codec.PointerTo(RgbTupleF32));
    return val;
  };

  XRSphericalHarmonics.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRSphericalHarmonics.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeArrayPointer(new codec.PointerTo(RgbTupleF32), val.coefficients);
  };
  function RgbaTupleF16(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  RgbaTupleF16.prototype.initDefaults_ = function() {
    this.red = 0;
    this.green = 0;
    this.blue = 0;
    this.alpha = 0;
  };
  RgbaTupleF16.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  RgbaTupleF16.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;





    return validator.validationError.NONE;
  };

  RgbaTupleF16.encodedSize = codec.kStructHeaderSize + 8;

  RgbaTupleF16.decode = function(decoder) {
    var packed;
    var val = new RgbaTupleF16();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.red =
        decoder.decodeStruct(codec.Uint16);
    val.green =
        decoder.decodeStruct(codec.Uint16);
    val.blue =
        decoder.decodeStruct(codec.Uint16);
    val.alpha =
        decoder.decodeStruct(codec.Uint16);
    return val;
  };

  RgbaTupleF16.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(RgbaTupleF16.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint16, val.red);
    encoder.encodeStruct(codec.Uint16, val.green);
    encoder.encodeStruct(codec.Uint16, val.blue);
    encoder.encodeStruct(codec.Uint16, val.alpha);
  };
  function XRCubeMap(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRCubeMap.NUM_COMPONENTS_PER_PIXEL = 4;
  XRCubeMap.prototype.initDefaults_ = function() {
    this.widthAndHeight = 0;
    this.positiveX = null;
    this.negativeX = null;
    this.positiveY = null;
    this.negativeY = null;
    this.positiveZ = null;
    this.negativeZ = null;
  };
  XRCubeMap.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRCubeMap.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 64}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    // validate XRCubeMap.positiveX
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 8, 8, new codec.PointerTo(RgbaTupleF16), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRCubeMap.negativeX
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 16, 8, new codec.PointerTo(RgbaTupleF16), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRCubeMap.positiveY
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 24, 8, new codec.PointerTo(RgbaTupleF16), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRCubeMap.negativeY
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 32, 8, new codec.PointerTo(RgbaTupleF16), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRCubeMap.positiveZ
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 40, 8, new codec.PointerTo(RgbaTupleF16), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRCubeMap.negativeZ
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 48, 8, new codec.PointerTo(RgbaTupleF16), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRCubeMap.encodedSize = codec.kStructHeaderSize + 56;

  XRCubeMap.decode = function(decoder) {
    var packed;
    var val = new XRCubeMap();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.widthAndHeight =
        decoder.decodeStruct(codec.Uint32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.positiveX =
        decoder.decodeArrayPointer(new codec.PointerTo(RgbaTupleF16));
    val.negativeX =
        decoder.decodeArrayPointer(new codec.PointerTo(RgbaTupleF16));
    val.positiveY =
        decoder.decodeArrayPointer(new codec.PointerTo(RgbaTupleF16));
    val.negativeY =
        decoder.decodeArrayPointer(new codec.PointerTo(RgbaTupleF16));
    val.positiveZ =
        decoder.decodeArrayPointer(new codec.PointerTo(RgbaTupleF16));
    val.negativeZ =
        decoder.decodeArrayPointer(new codec.PointerTo(RgbaTupleF16));
    return val;
  };

  XRCubeMap.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRCubeMap.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint32, val.widthAndHeight);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeArrayPointer(new codec.PointerTo(RgbaTupleF16), val.positiveX);
    encoder.encodeArrayPointer(new codec.PointerTo(RgbaTupleF16), val.negativeX);
    encoder.encodeArrayPointer(new codec.PointerTo(RgbaTupleF16), val.positiveY);
    encoder.encodeArrayPointer(new codec.PointerTo(RgbaTupleF16), val.negativeY);
    encoder.encodeArrayPointer(new codec.PointerTo(RgbaTupleF16), val.positiveZ);
    encoder.encodeArrayPointer(new codec.PointerTo(RgbaTupleF16), val.negativeZ);
  };
  function XRLightProbe(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRLightProbe.prototype.initDefaults_ = function() {
    this.sphericalHarmonics = null;
    this.mainLightDirection = null;
    this.mainLightIntensity = null;
  };
  XRLightProbe.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRLightProbe.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 32}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRLightProbe.sphericalHarmonics
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, XRSphericalHarmonics, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRLightProbe.mainLightDirection
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, geometry$.Vector3dF, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRLightProbe.mainLightIntensity
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, RgbTupleF32, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRLightProbe.encodedSize = codec.kStructHeaderSize + 24;

  XRLightProbe.decode = function(decoder) {
    var packed;
    var val = new XRLightProbe();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.sphericalHarmonics =
        decoder.decodeStructPointer(XRSphericalHarmonics);
    val.mainLightDirection =
        decoder.decodeStructPointer(geometry$.Vector3dF);
    val.mainLightIntensity =
        decoder.decodeStructPointer(RgbTupleF32);
    return val;
  };

  XRLightProbe.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRLightProbe.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(XRSphericalHarmonics, val.sphericalHarmonics);
    encoder.encodeStructPointer(geometry$.Vector3dF, val.mainLightDirection);
    encoder.encodeStructPointer(RgbTupleF32, val.mainLightIntensity);
  };
  function XRReflectionProbe(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRReflectionProbe.prototype.initDefaults_ = function() {
    this.cubeMap = null;
  };
  XRReflectionProbe.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRReflectionProbe.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRReflectionProbe.cubeMap
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, XRCubeMap, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRReflectionProbe.encodedSize = codec.kStructHeaderSize + 8;

  XRReflectionProbe.decode = function(decoder) {
    var packed;
    var val = new XRReflectionProbe();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.cubeMap =
        decoder.decodeStructPointer(XRCubeMap);
    return val;
  };

  XRReflectionProbe.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRReflectionProbe.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(XRCubeMap, val.cubeMap);
  };
  function XRLightEstimationData(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRLightEstimationData.prototype.initDefaults_ = function() {
    this.lightProbe = null;
    this.reflectionProbe = null;
  };
  XRLightEstimationData.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRLightEstimationData.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRLightEstimationData.lightProbe
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, XRLightProbe, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRLightEstimationData.reflectionProbe
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, XRReflectionProbe, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRLightEstimationData.encodedSize = codec.kStructHeaderSize + 16;

  XRLightEstimationData.decode = function(decoder) {
    var packed;
    var val = new XRLightEstimationData();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.lightProbe =
        decoder.decodeStructPointer(XRLightProbe);
    val.reflectionProbe =
        decoder.decodeStructPointer(XRReflectionProbe);
    return val;
  };

  XRLightEstimationData.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRLightEstimationData.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(XRLightProbe, val.lightProbe);
    encoder.encodeStructPointer(XRReflectionProbe, val.reflectionProbe);
  };
  function XRDepthDataStillValid(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRDepthDataStillValid.prototype.initDefaults_ = function() {
  };
  XRDepthDataStillValid.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRDepthDataStillValid.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRDepthDataStillValid.encodedSize = codec.kStructHeaderSize + 0;

  XRDepthDataStillValid.decode = function(decoder) {
    var packed;
    var val = new XRDepthDataStillValid();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  XRDepthDataStillValid.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRDepthDataStillValid.encodedSize);
    encoder.writeUint32(0);
  };
  function XRDepthDataUpdated(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRDepthDataUpdated.prototype.initDefaults_ = function() {
    this.timeDelta = null;
    this.pixelData = null;
    this.normTextureFromNormView = null;
    this.size = null;
    this.rawValueToMeters = 0;
  };
  XRDepthDataUpdated.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRDepthDataUpdated.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 56}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRDepthDataUpdated.timeDelta
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, time$.TimeDelta, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRDepthDataUpdated.pixelData
    err = messageValidator.validateUnion(offset + codec.kStructHeaderSize + 8, big_buffer$.BigBuffer, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRDepthDataUpdated.normTextureFromNormView
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 24, transform$.Transform, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRDepthDataUpdated.size
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 32, geometry$.Size, false);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  XRDepthDataUpdated.encodedSize = codec.kStructHeaderSize + 48;

  XRDepthDataUpdated.decode = function(decoder) {
    var packed;
    var val = new XRDepthDataUpdated();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.timeDelta =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.pixelData =
        decoder.decodeStruct(big_buffer$.BigBuffer);
    val.normTextureFromNormView =
        decoder.decodeStructPointer(transform$.Transform);
    val.size =
        decoder.decodeStructPointer(geometry$.Size);
    val.rawValueToMeters =
        decoder.decodeStruct(codec.Float);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  XRDepthDataUpdated.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRDepthDataUpdated.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(time$.TimeDelta, val.timeDelta);
    encoder.encodeStruct(big_buffer$.BigBuffer, val.pixelData);
    encoder.encodeStructPointer(transform$.Transform, val.normTextureFromNormView);
    encoder.encodeStructPointer(geometry$.Size, val.size);
    encoder.encodeStruct(codec.Float, val.rawValueToMeters);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function XRTrackedImageData(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRTrackedImageData.prototype.initDefaults_ = function() {
    this.index = 0;
    this.activelyTracked = false;
    this.mojoFromImage = null;
    this.widthInMeters = 0;
  };
  XRTrackedImageData.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRTrackedImageData.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 32}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    // validate XRTrackedImageData.mojoFromImage
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, Pose, false);
    if (err !== validator.validationError.NONE)
        return err;



    return validator.validationError.NONE;
  };

  XRTrackedImageData.encodedSize = codec.kStructHeaderSize + 24;

  XRTrackedImageData.decode = function(decoder) {
    var packed;
    var val = new XRTrackedImageData();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.index =
        decoder.decodeStruct(codec.Uint32);
    packed = decoder.readUint8();
    val.activelyTracked = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.mojoFromImage =
        decoder.decodeStructPointer(Pose);
    val.widthInMeters =
        decoder.decodeStruct(codec.Float);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  XRTrackedImageData.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRTrackedImageData.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint32, val.index);
    packed = 0;
    packed |= (val.activelyTracked & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStructPointer(Pose, val.mojoFromImage);
    encoder.encodeStruct(codec.Float, val.widthInMeters);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function XRTrackedImagesData(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRTrackedImagesData.prototype.initDefaults_ = function() {
    this.imagesData = null;
    this.imageTrackableScores = null;
  };
  XRTrackedImagesData.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRTrackedImagesData.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRTrackedImagesData.imagesData
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 0, 8, new codec.PointerTo(XRTrackedImageData), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRTrackedImagesData.imageTrackableScores
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 8, 1, codec.PackedBool, true, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRTrackedImagesData.encodedSize = codec.kStructHeaderSize + 16;

  XRTrackedImagesData.decode = function(decoder) {
    var packed;
    var val = new XRTrackedImagesData();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.imagesData =
        decoder.decodeArrayPointer(new codec.PointerTo(XRTrackedImageData));
    val.imageTrackableScores =
        decoder.decodeArrayPointer(codec.PackedBool);
    return val;
  };

  XRTrackedImagesData.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRTrackedImagesData.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeArrayPointer(new codec.PointerTo(XRTrackedImageData), val.imagesData);
    encoder.encodeArrayPointer(codec.PackedBool, val.imageTrackableScores);
  };
  function XRFrameData(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRFrameData.prototype.initDefaults_ = function() {
    this.mojoFromViewer = null;
    this.timeDelta = null;
    this.bufferHolder = null;
    this.cameraImageBufferHolder = null;
    this.cameraImageSize = null;
    this.depthData = null;
    this.mojoSpaceReset = false;
    this.frameId = 0;
    this.stageParametersId = 0;
    this.views = null;
    this.inputState = null;
    this.stageParameters = null;
    this.detectedPlanesData = null;
    this.anchorsData = null;
    this.lightEstimationData = null;
    this.hitTestSubscriptionResults = null;
    this.renderingTimeRatio = 0;
    this.trackedImages = null;
  };
  XRFrameData.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRFrameData.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 144}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRFrameData.mojoFromViewer
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, VRPose, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRFrameData.timeDelta
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, time$.TimeDelta, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRFrameData.bufferHolder
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, mailbox_holder$.MailboxHolder, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRFrameData.cameraImageBufferHolder
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 24, mailbox_holder$.MailboxHolder, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRFrameData.cameraImageSize
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 32, geometry$.Size, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRFrameData.depthData
    err = messageValidator.validateUnion(offset + codec.kStructHeaderSize + 40, XRDepthData, true);
    if (err !== validator.validationError.NONE)
        return err;




    // validate XRFrameData.views
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 64, 8, new codec.PointerTo(XRView), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRFrameData.inputState
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 72, 8, new codec.PointerTo(XRInputSourceState), true, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;



    // validate XRFrameData.stageParameters
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 80, VRStageParameters, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRFrameData.detectedPlanesData
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 88, XRPlaneDetectionData, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRFrameData.anchorsData
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 96, XRAnchorsData, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRFrameData.lightEstimationData
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 104, XRLightEstimationData, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRFrameData.hitTestSubscriptionResults
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 112, XRHitTestSubscriptionResultsData, true);
    if (err !== validator.validationError.NONE)
        return err;



    // validate XRFrameData.trackedImages
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 128, XRTrackedImagesData, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRFrameData.encodedSize = codec.kStructHeaderSize + 136;

  XRFrameData.decode = function(decoder) {
    var packed;
    var val = new XRFrameData();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.mojoFromViewer =
        decoder.decodeStructPointer(VRPose);
    val.timeDelta =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.bufferHolder =
        decoder.decodeStructPointer(mailbox_holder$.MailboxHolder);
    val.cameraImageBufferHolder =
        decoder.decodeStructPointer(mailbox_holder$.MailboxHolder);
    val.cameraImageSize =
        decoder.decodeStructPointer(geometry$.Size);
    val.depthData =
        decoder.decodeStruct(XRDepthData);
    packed = decoder.readUint8();
    val.mojoSpaceReset = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    val.frameId =
        decoder.decodeStruct(codec.Int16);
    val.stageParametersId =
        decoder.decodeStruct(codec.Uint32);
    val.views =
        decoder.decodeArrayPointer(new codec.PointerTo(XRView));
    val.inputState =
        decoder.decodeArrayPointer(new codec.PointerTo(XRInputSourceState));
    val.stageParameters =
        decoder.decodeStructPointer(VRStageParameters);
    val.detectedPlanesData =
        decoder.decodeStructPointer(XRPlaneDetectionData);
    val.anchorsData =
        decoder.decodeStructPointer(XRAnchorsData);
    val.lightEstimationData =
        decoder.decodeStructPointer(XRLightEstimationData);
    val.hitTestSubscriptionResults =
        decoder.decodeStructPointer(XRHitTestSubscriptionResultsData);
    val.renderingTimeRatio =
        decoder.decodeStruct(codec.Float);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.trackedImages =
        decoder.decodeStructPointer(XRTrackedImagesData);
    return val;
  };

  XRFrameData.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRFrameData.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(VRPose, val.mojoFromViewer);
    encoder.encodeStructPointer(time$.TimeDelta, val.timeDelta);
    encoder.encodeStructPointer(mailbox_holder$.MailboxHolder, val.bufferHolder);
    encoder.encodeStructPointer(mailbox_holder$.MailboxHolder, val.cameraImageBufferHolder);
    encoder.encodeStructPointer(geometry$.Size, val.cameraImageSize);
    encoder.encodeStruct(XRDepthData, val.depthData);
    packed = 0;
    packed |= (val.mojoSpaceReset & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.encodeStruct(codec.Int16, val.frameId);
    encoder.encodeStruct(codec.Uint32, val.stageParametersId);
    encoder.encodeArrayPointer(new codec.PointerTo(XRView), val.views);
    encoder.encodeArrayPointer(new codec.PointerTo(XRInputSourceState), val.inputState);
    encoder.encodeStructPointer(VRStageParameters, val.stageParameters);
    encoder.encodeStructPointer(XRPlaneDetectionData, val.detectedPlanesData);
    encoder.encodeStructPointer(XRAnchorsData, val.anchorsData);
    encoder.encodeStructPointer(XRLightEstimationData, val.lightEstimationData);
    encoder.encodeStructPointer(XRHitTestSubscriptionResultsData, val.hitTestSubscriptionResults);
    encoder.encodeStruct(codec.Float, val.renderingTimeRatio);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStructPointer(XRTrackedImagesData, val.trackedImages);
  };
  function RequestSessionSuccess(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  RequestSessionSuccess.prototype.initDefaults_ = function() {
    this.session = null;
    this.metricsRecorder = new XRSessionMetricsRecorderPtr();
  };
  RequestSessionSuccess.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  RequestSessionSuccess.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate RequestSessionSuccess.session
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, XRSession, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate RequestSessionSuccess.metricsRecorder
    err = messageValidator.validateInterface(offset + codec.kStructHeaderSize + 8, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  RequestSessionSuccess.encodedSize = codec.kStructHeaderSize + 16;

  RequestSessionSuccess.decode = function(decoder) {
    var packed;
    var val = new RequestSessionSuccess();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.session =
        decoder.decodeStructPointer(XRSession);
    val.metricsRecorder =
        decoder.decodeStruct(new codec.Interface(XRSessionMetricsRecorderPtr));
    return val;
  };

  RequestSessionSuccess.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(RequestSessionSuccess.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(XRSession, val.session);
    encoder.encodeStruct(new codec.Interface(XRSessionMetricsRecorderPtr), val.metricsRecorder);
  };
  function XRFrameDataRequestOptions(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRFrameDataRequestOptions.prototype.initDefaults_ = function() {
    this.includeLightingEstimationData = false;
    this.stageParametersId = 0;
  };
  XRFrameDataRequestOptions.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRFrameDataRequestOptions.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    return validator.validationError.NONE;
  };

  XRFrameDataRequestOptions.encodedSize = codec.kStructHeaderSize + 8;

  XRFrameDataRequestOptions.decode = function(decoder) {
    var packed;
    var val = new XRFrameDataRequestOptions();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    packed = decoder.readUint8();
    val.includeLightingEstimationData = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.stageParametersId =
        decoder.decodeStruct(codec.Uint32);
    return val;
  };

  XRFrameDataRequestOptions.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRFrameDataRequestOptions.encodedSize);
    encoder.writeUint32(0);
    packed = 0;
    packed |= (val.includeLightingEstimationData & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.Uint32, val.stageParametersId);
  };
  function VRService_SetClient_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  VRService_SetClient_Params.prototype.initDefaults_ = function() {
    this.client = new VRServiceClientPtr();
  };
  VRService_SetClient_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  VRService_SetClient_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VRService_SetClient_Params.client
    err = messageValidator.validateInterface(offset + codec.kStructHeaderSize + 0, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  VRService_SetClient_Params.encodedSize = codec.kStructHeaderSize + 8;

  VRService_SetClient_Params.decode = function(decoder) {
    var packed;
    var val = new VRService_SetClient_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.client =
        decoder.decodeStruct(new codec.Interface(VRServiceClientPtr));
    return val;
  };

  VRService_SetClient_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(VRService_SetClient_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(new codec.Interface(VRServiceClientPtr), val.client);
  };
  function VRService_RequestSession_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  VRService_RequestSession_Params.prototype.initDefaults_ = function() {
    this.options = null;
  };
  VRService_RequestSession_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  VRService_RequestSession_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VRService_RequestSession_Params.options
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, xr_session$.XRSessionOptions, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  VRService_RequestSession_Params.encodedSize = codec.kStructHeaderSize + 8;

  VRService_RequestSession_Params.decode = function(decoder) {
    var packed;
    var val = new VRService_RequestSession_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.options =
        decoder.decodeStructPointer(xr_session$.XRSessionOptions);
    return val;
  };

  VRService_RequestSession_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(VRService_RequestSession_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(xr_session$.XRSessionOptions, val.options);
  };
  function VRService_RequestSession_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  VRService_RequestSession_ResponseParams.prototype.initDefaults_ = function() {
    this.result = null;
  };
  VRService_RequestSession_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  VRService_RequestSession_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VRService_RequestSession_ResponseParams.result
    err = messageValidator.validateUnion(offset + codec.kStructHeaderSize + 0, RequestSessionResult, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  VRService_RequestSession_ResponseParams.encodedSize = codec.kStructHeaderSize + 16;

  VRService_RequestSession_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new VRService_RequestSession_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.result =
        decoder.decodeStruct(RequestSessionResult);
    return val;
  };

  VRService_RequestSession_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(VRService_RequestSession_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(RequestSessionResult, val.result);
  };
  function VRService_SupportsSession_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  VRService_SupportsSession_Params.prototype.initDefaults_ = function() {
    this.options = null;
  };
  VRService_SupportsSession_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  VRService_SupportsSession_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VRService_SupportsSession_Params.options
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, xr_session$.XRSessionOptions, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  VRService_SupportsSession_Params.encodedSize = codec.kStructHeaderSize + 8;

  VRService_SupportsSession_Params.decode = function(decoder) {
    var packed;
    var val = new VRService_SupportsSession_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.options =
        decoder.decodeStructPointer(xr_session$.XRSessionOptions);
    return val;
  };

  VRService_SupportsSession_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(VRService_SupportsSession_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(xr_session$.XRSessionOptions, val.options);
  };
  function VRService_SupportsSession_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  VRService_SupportsSession_ResponseParams.prototype.initDefaults_ = function() {
    this.supportsSession = false;
  };
  VRService_SupportsSession_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  VRService_SupportsSession_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  VRService_SupportsSession_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  VRService_SupportsSession_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new VRService_SupportsSession_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    packed = decoder.readUint8();
    val.supportsSession = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  VRService_SupportsSession_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(VRService_SupportsSession_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    packed = 0;
    packed |= (val.supportsSession & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function VRService_ExitPresent_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  VRService_ExitPresent_Params.prototype.initDefaults_ = function() {
  };
  VRService_ExitPresent_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  VRService_ExitPresent_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  VRService_ExitPresent_Params.encodedSize = codec.kStructHeaderSize + 0;

  VRService_ExitPresent_Params.decode = function(decoder) {
    var packed;
    var val = new VRService_ExitPresent_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  VRService_ExitPresent_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(VRService_ExitPresent_Params.encodedSize);
    encoder.writeUint32(0);
  };
  function VRService_ExitPresent_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  VRService_ExitPresent_ResponseParams.prototype.initDefaults_ = function() {
  };
  VRService_ExitPresent_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  VRService_ExitPresent_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  VRService_ExitPresent_ResponseParams.encodedSize = codec.kStructHeaderSize + 0;

  VRService_ExitPresent_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new VRService_ExitPresent_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  VRService_ExitPresent_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(VRService_ExitPresent_ResponseParams.encodedSize);
    encoder.writeUint32(0);
  };
  function VRService_SetFramesThrottled_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  VRService_SetFramesThrottled_Params.prototype.initDefaults_ = function() {
    this.throttled = false;
  };
  VRService_SetFramesThrottled_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  VRService_SetFramesThrottled_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  VRService_SetFramesThrottled_Params.encodedSize = codec.kStructHeaderSize + 8;

  VRService_SetFramesThrottled_Params.decode = function(decoder) {
    var packed;
    var val = new VRService_SetFramesThrottled_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    packed = decoder.readUint8();
    val.throttled = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  VRService_SetFramesThrottled_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(VRService_SetFramesThrottled_Params.encodedSize);
    encoder.writeUint32(0);
    packed = 0;
    packed |= (val.throttled & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function VRService_MakeXrCompatible_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  VRService_MakeXrCompatible_Params.prototype.initDefaults_ = function() {
  };
  VRService_MakeXrCompatible_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  VRService_MakeXrCompatible_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  VRService_MakeXrCompatible_Params.encodedSize = codec.kStructHeaderSize + 0;

  VRService_MakeXrCompatible_Params.decode = function(decoder) {
    var packed;
    var val = new VRService_MakeXrCompatible_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  VRService_MakeXrCompatible_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(VRService_MakeXrCompatible_Params.encodedSize);
    encoder.writeUint32(0);
  };
  function VRService_MakeXrCompatible_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  VRService_MakeXrCompatible_ResponseParams.prototype.initDefaults_ = function() {
    this.xrCompatibleResult = 0;
  };
  VRService_MakeXrCompatible_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  VRService_MakeXrCompatible_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate VRService_MakeXrCompatible_ResponseParams.xrCompatibleResult
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, XrCompatibleResult);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  VRService_MakeXrCompatible_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  VRService_MakeXrCompatible_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new VRService_MakeXrCompatible_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.xrCompatibleResult =
        decoder.decodeStruct(new codec.Enum(XrCompatibleResult));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  VRService_MakeXrCompatible_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(VRService_MakeXrCompatible_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.xrCompatibleResult);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function XRSessionMetricsRecorder_ReportFeatureUsed_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRSessionMetricsRecorder_ReportFeatureUsed_Params.prototype.initDefaults_ = function() {
    this.feature = 0;
  };
  XRSessionMetricsRecorder_ReportFeatureUsed_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRSessionMetricsRecorder_ReportFeatureUsed_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRSessionMetricsRecorder_ReportFeatureUsed_Params.feature
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, xr_session$.XRSessionFeature);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRSessionMetricsRecorder_ReportFeatureUsed_Params.encodedSize = codec.kStructHeaderSize + 8;

  XRSessionMetricsRecorder_ReportFeatureUsed_Params.decode = function(decoder) {
    var packed;
    var val = new XRSessionMetricsRecorder_ReportFeatureUsed_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.feature =
        decoder.decodeStruct(new codec.Enum(xr_session$.XRSessionFeature));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  XRSessionMetricsRecorder_ReportFeatureUsed_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRSessionMetricsRecorder_ReportFeatureUsed_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.feature);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function VRServiceClient_OnDeviceChanged_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  VRServiceClient_OnDeviceChanged_Params.prototype.initDefaults_ = function() {
  };
  VRServiceClient_OnDeviceChanged_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  VRServiceClient_OnDeviceChanged_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  VRServiceClient_OnDeviceChanged_Params.encodedSize = codec.kStructHeaderSize + 0;

  VRServiceClient_OnDeviceChanged_Params.decode = function(decoder) {
    var packed;
    var val = new VRServiceClient_OnDeviceChanged_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  VRServiceClient_OnDeviceChanged_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(VRServiceClient_OnDeviceChanged_Params.encodedSize);
    encoder.writeUint32(0);
  };
  function XREnvironmentIntegrationProvider_SubscribeToHitTest_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XREnvironmentIntegrationProvider_SubscribeToHitTest_Params.prototype.initDefaults_ = function() {
    this.nativeOriginInformation = null;
    this.entityTypes = null;
    this.ray = null;
  };
  XREnvironmentIntegrationProvider_SubscribeToHitTest_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XREnvironmentIntegrationProvider_SubscribeToHitTest_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 40}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XREnvironmentIntegrationProvider_SubscribeToHitTest_Params.nativeOriginInformation
    err = messageValidator.validateUnion(offset + codec.kStructHeaderSize + 0, XRNativeOriginInformation, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XREnvironmentIntegrationProvider_SubscribeToHitTest_Params.entityTypes
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 16, 4, new codec.Enum(EntityTypeForHitTest), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XREnvironmentIntegrationProvider_SubscribeToHitTest_Params.ray
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 24, XRRay, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XREnvironmentIntegrationProvider_SubscribeToHitTest_Params.encodedSize = codec.kStructHeaderSize + 32;

  XREnvironmentIntegrationProvider_SubscribeToHitTest_Params.decode = function(decoder) {
    var packed;
    var val = new XREnvironmentIntegrationProvider_SubscribeToHitTest_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.nativeOriginInformation =
        decoder.decodeStruct(XRNativeOriginInformation);
    val.entityTypes =
        decoder.decodeArrayPointer(new codec.Enum(EntityTypeForHitTest));
    val.ray =
        decoder.decodeStructPointer(XRRay);
    return val;
  };

  XREnvironmentIntegrationProvider_SubscribeToHitTest_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XREnvironmentIntegrationProvider_SubscribeToHitTest_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(XRNativeOriginInformation, val.nativeOriginInformation);
    encoder.encodeArrayPointer(new codec.Enum(EntityTypeForHitTest), val.entityTypes);
    encoder.encodeStructPointer(XRRay, val.ray);
  };
  function XREnvironmentIntegrationProvider_SubscribeToHitTest_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XREnvironmentIntegrationProvider_SubscribeToHitTest_ResponseParams.prototype.initDefaults_ = function() {
    this.result = 0;
    this.subscriptionId = 0;
  };
  XREnvironmentIntegrationProvider_SubscribeToHitTest_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XREnvironmentIntegrationProvider_SubscribeToHitTest_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XREnvironmentIntegrationProvider_SubscribeToHitTest_ResponseParams.result
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, SubscribeToHitTestResult);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  XREnvironmentIntegrationProvider_SubscribeToHitTest_ResponseParams.encodedSize = codec.kStructHeaderSize + 16;

  XREnvironmentIntegrationProvider_SubscribeToHitTest_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new XREnvironmentIntegrationProvider_SubscribeToHitTest_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.result =
        decoder.decodeStruct(new codec.Enum(SubscribeToHitTestResult));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.subscriptionId =
        decoder.decodeStruct(codec.Uint64);
    return val;
  };

  XREnvironmentIntegrationProvider_SubscribeToHitTest_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XREnvironmentIntegrationProvider_SubscribeToHitTest_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.result);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.Uint64, val.subscriptionId);
  };
  function XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_Params.prototype.initDefaults_ = function() {
    this.profileName = null;
    this.entityTypes = null;
    this.ray = null;
  };
  XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 32}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_Params.profileName
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 0, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_Params.entityTypes
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 8, 4, new codec.Enum(EntityTypeForHitTest), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_Params.ray
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, XRRay, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_Params.encodedSize = codec.kStructHeaderSize + 24;

  XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_Params.decode = function(decoder) {
    var packed;
    var val = new XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.profileName =
        decoder.decodeStruct(codec.String);
    val.entityTypes =
        decoder.decodeArrayPointer(new codec.Enum(EntityTypeForHitTest));
    val.ray =
        decoder.decodeStructPointer(XRRay);
    return val;
  };

  XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.String, val.profileName);
    encoder.encodeArrayPointer(new codec.Enum(EntityTypeForHitTest), val.entityTypes);
    encoder.encodeStructPointer(XRRay, val.ray);
  };
  function XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_ResponseParams.prototype.initDefaults_ = function() {
    this.result = 0;
    this.subscriptionId = 0;
  };
  XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_ResponseParams.result
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, SubscribeToHitTestResult);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_ResponseParams.encodedSize = codec.kStructHeaderSize + 16;

  XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.result =
        decoder.decodeStruct(new codec.Enum(SubscribeToHitTestResult));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.subscriptionId =
        decoder.decodeStruct(codec.Uint64);
    return val;
  };

  XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.result);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.Uint64, val.subscriptionId);
  };
  function XREnvironmentIntegrationProvider_UnsubscribeFromHitTest_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XREnvironmentIntegrationProvider_UnsubscribeFromHitTest_Params.prototype.initDefaults_ = function() {
    this.subscriptionId = 0;
  };
  XREnvironmentIntegrationProvider_UnsubscribeFromHitTest_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XREnvironmentIntegrationProvider_UnsubscribeFromHitTest_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  XREnvironmentIntegrationProvider_UnsubscribeFromHitTest_Params.encodedSize = codec.kStructHeaderSize + 8;

  XREnvironmentIntegrationProvider_UnsubscribeFromHitTest_Params.decode = function(decoder) {
    var packed;
    var val = new XREnvironmentIntegrationProvider_UnsubscribeFromHitTest_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.subscriptionId =
        decoder.decodeStruct(codec.Uint64);
    return val;
  };

  XREnvironmentIntegrationProvider_UnsubscribeFromHitTest_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XREnvironmentIntegrationProvider_UnsubscribeFromHitTest_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint64, val.subscriptionId);
  };
  function XREnvironmentIntegrationProvider_CreateAnchor_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XREnvironmentIntegrationProvider_CreateAnchor_Params.prototype.initDefaults_ = function() {
    this.nativeOriginInformation = null;
    this.nativeOriginFromAnchor = null;
  };
  XREnvironmentIntegrationProvider_CreateAnchor_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XREnvironmentIntegrationProvider_CreateAnchor_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 32}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XREnvironmentIntegrationProvider_CreateAnchor_Params.nativeOriginInformation
    err = messageValidator.validateUnion(offset + codec.kStructHeaderSize + 0, XRNativeOriginInformation, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XREnvironmentIntegrationProvider_CreateAnchor_Params.nativeOriginFromAnchor
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, Pose, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XREnvironmentIntegrationProvider_CreateAnchor_Params.encodedSize = codec.kStructHeaderSize + 24;

  XREnvironmentIntegrationProvider_CreateAnchor_Params.decode = function(decoder) {
    var packed;
    var val = new XREnvironmentIntegrationProvider_CreateAnchor_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.nativeOriginInformation =
        decoder.decodeStruct(XRNativeOriginInformation);
    val.nativeOriginFromAnchor =
        decoder.decodeStructPointer(Pose);
    return val;
  };

  XREnvironmentIntegrationProvider_CreateAnchor_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XREnvironmentIntegrationProvider_CreateAnchor_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(XRNativeOriginInformation, val.nativeOriginInformation);
    encoder.encodeStructPointer(Pose, val.nativeOriginFromAnchor);
  };
  function XREnvironmentIntegrationProvider_CreateAnchor_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XREnvironmentIntegrationProvider_CreateAnchor_ResponseParams.prototype.initDefaults_ = function() {
    this.result = 0;
    this.anchorId = 0;
  };
  XREnvironmentIntegrationProvider_CreateAnchor_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XREnvironmentIntegrationProvider_CreateAnchor_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XREnvironmentIntegrationProvider_CreateAnchor_ResponseParams.result
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, CreateAnchorResult);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  XREnvironmentIntegrationProvider_CreateAnchor_ResponseParams.encodedSize = codec.kStructHeaderSize + 16;

  XREnvironmentIntegrationProvider_CreateAnchor_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new XREnvironmentIntegrationProvider_CreateAnchor_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.result =
        decoder.decodeStruct(new codec.Enum(CreateAnchorResult));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.anchorId =
        decoder.decodeStruct(codec.Uint64);
    return val;
  };

  XREnvironmentIntegrationProvider_CreateAnchor_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XREnvironmentIntegrationProvider_CreateAnchor_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.result);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.Uint64, val.anchorId);
  };
  function XREnvironmentIntegrationProvider_CreatePlaneAnchor_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XREnvironmentIntegrationProvider_CreatePlaneAnchor_Params.prototype.initDefaults_ = function() {
    this.nativeOriginInformation = null;
    this.nativeOriginFromAnchor = null;
    this.planeId = 0;
  };
  XREnvironmentIntegrationProvider_CreatePlaneAnchor_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XREnvironmentIntegrationProvider_CreatePlaneAnchor_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 40}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XREnvironmentIntegrationProvider_CreatePlaneAnchor_Params.nativeOriginInformation
    err = messageValidator.validateUnion(offset + codec.kStructHeaderSize + 0, XRNativeOriginInformation, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XREnvironmentIntegrationProvider_CreatePlaneAnchor_Params.nativeOriginFromAnchor
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, Pose, false);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  XREnvironmentIntegrationProvider_CreatePlaneAnchor_Params.encodedSize = codec.kStructHeaderSize + 32;

  XREnvironmentIntegrationProvider_CreatePlaneAnchor_Params.decode = function(decoder) {
    var packed;
    var val = new XREnvironmentIntegrationProvider_CreatePlaneAnchor_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.nativeOriginInformation =
        decoder.decodeStruct(XRNativeOriginInformation);
    val.nativeOriginFromAnchor =
        decoder.decodeStructPointer(Pose);
    val.planeId =
        decoder.decodeStruct(codec.Uint64);
    return val;
  };

  XREnvironmentIntegrationProvider_CreatePlaneAnchor_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XREnvironmentIntegrationProvider_CreatePlaneAnchor_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(XRNativeOriginInformation, val.nativeOriginInformation);
    encoder.encodeStructPointer(Pose, val.nativeOriginFromAnchor);
    encoder.encodeStruct(codec.Uint64, val.planeId);
  };
  function XREnvironmentIntegrationProvider_CreatePlaneAnchor_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XREnvironmentIntegrationProvider_CreatePlaneAnchor_ResponseParams.prototype.initDefaults_ = function() {
    this.result = 0;
    this.anchorId = 0;
  };
  XREnvironmentIntegrationProvider_CreatePlaneAnchor_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XREnvironmentIntegrationProvider_CreatePlaneAnchor_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XREnvironmentIntegrationProvider_CreatePlaneAnchor_ResponseParams.result
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, CreateAnchorResult);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  XREnvironmentIntegrationProvider_CreatePlaneAnchor_ResponseParams.encodedSize = codec.kStructHeaderSize + 16;

  XREnvironmentIntegrationProvider_CreatePlaneAnchor_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new XREnvironmentIntegrationProvider_CreatePlaneAnchor_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.result =
        decoder.decodeStruct(new codec.Enum(CreateAnchorResult));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.anchorId =
        decoder.decodeStruct(codec.Uint64);
    return val;
  };

  XREnvironmentIntegrationProvider_CreatePlaneAnchor_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XREnvironmentIntegrationProvider_CreatePlaneAnchor_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.result);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.Uint64, val.anchorId);
  };
  function XREnvironmentIntegrationProvider_DetachAnchor_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XREnvironmentIntegrationProvider_DetachAnchor_Params.prototype.initDefaults_ = function() {
    this.anchorId = 0;
  };
  XREnvironmentIntegrationProvider_DetachAnchor_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XREnvironmentIntegrationProvider_DetachAnchor_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  XREnvironmentIntegrationProvider_DetachAnchor_Params.encodedSize = codec.kStructHeaderSize + 8;

  XREnvironmentIntegrationProvider_DetachAnchor_Params.decode = function(decoder) {
    var packed;
    var val = new XREnvironmentIntegrationProvider_DetachAnchor_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.anchorId =
        decoder.decodeStruct(codec.Uint64);
    return val;
  };

  XREnvironmentIntegrationProvider_DetachAnchor_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XREnvironmentIntegrationProvider_DetachAnchor_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint64, val.anchorId);
  };
  function XRFrameDataProvider_GetFrameData_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRFrameDataProvider_GetFrameData_Params.prototype.initDefaults_ = function() {
    this.options = null;
  };
  XRFrameDataProvider_GetFrameData_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRFrameDataProvider_GetFrameData_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRFrameDataProvider_GetFrameData_Params.options
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, XRFrameDataRequestOptions, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRFrameDataProvider_GetFrameData_Params.encodedSize = codec.kStructHeaderSize + 8;

  XRFrameDataProvider_GetFrameData_Params.decode = function(decoder) {
    var packed;
    var val = new XRFrameDataProvider_GetFrameData_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.options =
        decoder.decodeStructPointer(XRFrameDataRequestOptions);
    return val;
  };

  XRFrameDataProvider_GetFrameData_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRFrameDataProvider_GetFrameData_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(XRFrameDataRequestOptions, val.options);
  };
  function XRFrameDataProvider_GetFrameData_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRFrameDataProvider_GetFrameData_ResponseParams.prototype.initDefaults_ = function() {
    this.frameData = null;
  };
  XRFrameDataProvider_GetFrameData_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRFrameDataProvider_GetFrameData_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRFrameDataProvider_GetFrameData_ResponseParams.frameData
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, XRFrameData, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRFrameDataProvider_GetFrameData_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  XRFrameDataProvider_GetFrameData_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new XRFrameDataProvider_GetFrameData_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.frameData =
        decoder.decodeStructPointer(XRFrameData);
    return val;
  };

  XRFrameDataProvider_GetFrameData_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRFrameDataProvider_GetFrameData_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(XRFrameData, val.frameData);
  };
  function XRFrameDataProvider_GetEnvironmentIntegrationProvider_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRFrameDataProvider_GetEnvironmentIntegrationProvider_Params.prototype.initDefaults_ = function() {
    this.environmentProvider = new associatedBindings.AssociatedInterfaceRequest();
  };
  XRFrameDataProvider_GetEnvironmentIntegrationProvider_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRFrameDataProvider_GetEnvironmentIntegrationProvider_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRFrameDataProvider_GetEnvironmentIntegrationProvider_Params.environmentProvider
    err = messageValidator.validateAssociatedInterfaceRequest(offset + codec.kStructHeaderSize + 0, false)
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRFrameDataProvider_GetEnvironmentIntegrationProvider_Params.encodedSize = codec.kStructHeaderSize + 8;

  XRFrameDataProvider_GetEnvironmentIntegrationProvider_Params.decode = function(decoder) {
    var packed;
    var val = new XRFrameDataProvider_GetEnvironmentIntegrationProvider_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.environmentProvider =
        decoder.decodeStruct(codec.AssociatedInterfaceRequest);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  XRFrameDataProvider_GetEnvironmentIntegrationProvider_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRFrameDataProvider_GetEnvironmentIntegrationProvider_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.AssociatedInterfaceRequest, val.environmentProvider);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function XRPresentationProvider_UpdateLayerBounds_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRPresentationProvider_UpdateLayerBounds_Params.prototype.initDefaults_ = function() {
    this.frameId = 0;
    this.leftBounds = null;
    this.rightBounds = null;
    this.sourceSize = null;
  };
  XRPresentationProvider_UpdateLayerBounds_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRPresentationProvider_UpdateLayerBounds_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 40}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    // validate XRPresentationProvider_UpdateLayerBounds_Params.leftBounds
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, geometry$.RectF, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRPresentationProvider_UpdateLayerBounds_Params.rightBounds
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, geometry$.RectF, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRPresentationProvider_UpdateLayerBounds_Params.sourceSize
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 24, geometry$.Size, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRPresentationProvider_UpdateLayerBounds_Params.encodedSize = codec.kStructHeaderSize + 32;

  XRPresentationProvider_UpdateLayerBounds_Params.decode = function(decoder) {
    var packed;
    var val = new XRPresentationProvider_UpdateLayerBounds_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.frameId =
        decoder.decodeStruct(codec.Int16);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.leftBounds =
        decoder.decodeStructPointer(geometry$.RectF);
    val.rightBounds =
        decoder.decodeStructPointer(geometry$.RectF);
    val.sourceSize =
        decoder.decodeStructPointer(geometry$.Size);
    return val;
  };

  XRPresentationProvider_UpdateLayerBounds_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRPresentationProvider_UpdateLayerBounds_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int16, val.frameId);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStructPointer(geometry$.RectF, val.leftBounds);
    encoder.encodeStructPointer(geometry$.RectF, val.rightBounds);
    encoder.encodeStructPointer(geometry$.Size, val.sourceSize);
  };
  function XRPresentationProvider_SubmitFrameMissing_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRPresentationProvider_SubmitFrameMissing_Params.prototype.initDefaults_ = function() {
    this.frameId = 0;
    this.syncToken = null;
  };
  XRPresentationProvider_SubmitFrameMissing_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRPresentationProvider_SubmitFrameMissing_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    // validate XRPresentationProvider_SubmitFrameMissing_Params.syncToken
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, sync_token$.SyncToken, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRPresentationProvider_SubmitFrameMissing_Params.encodedSize = codec.kStructHeaderSize + 16;

  XRPresentationProvider_SubmitFrameMissing_Params.decode = function(decoder) {
    var packed;
    var val = new XRPresentationProvider_SubmitFrameMissing_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.frameId =
        decoder.decodeStruct(codec.Int16);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.syncToken =
        decoder.decodeStructPointer(sync_token$.SyncToken);
    return val;
  };

  XRPresentationProvider_SubmitFrameMissing_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRPresentationProvider_SubmitFrameMissing_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int16, val.frameId);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStructPointer(sync_token$.SyncToken, val.syncToken);
  };
  function XRPresentationProvider_SubmitFrame_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRPresentationProvider_SubmitFrame_Params.prototype.initDefaults_ = function() {
    this.frameId = 0;
    this.mailboxHolder = null;
    this.timeWaited = null;
  };
  XRPresentationProvider_SubmitFrame_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRPresentationProvider_SubmitFrame_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 32}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    // validate XRPresentationProvider_SubmitFrame_Params.mailboxHolder
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, mailbox_holder$.MailboxHolder, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRPresentationProvider_SubmitFrame_Params.timeWaited
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, time$.TimeDelta, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRPresentationProvider_SubmitFrame_Params.encodedSize = codec.kStructHeaderSize + 24;

  XRPresentationProvider_SubmitFrame_Params.decode = function(decoder) {
    var packed;
    var val = new XRPresentationProvider_SubmitFrame_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.frameId =
        decoder.decodeStruct(codec.Int16);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.mailboxHolder =
        decoder.decodeStructPointer(mailbox_holder$.MailboxHolder);
    val.timeWaited =
        decoder.decodeStructPointer(time$.TimeDelta);
    return val;
  };

  XRPresentationProvider_SubmitFrame_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRPresentationProvider_SubmitFrame_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int16, val.frameId);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStructPointer(mailbox_holder$.MailboxHolder, val.mailboxHolder);
    encoder.encodeStructPointer(time$.TimeDelta, val.timeWaited);
  };
  function XRPresentationProvider_SubmitFrameDrawnIntoTexture_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRPresentationProvider_SubmitFrameDrawnIntoTexture_Params.prototype.initDefaults_ = function() {
    this.frameId = 0;
    this.syncToken = null;
    this.timeWaited = null;
  };
  XRPresentationProvider_SubmitFrameDrawnIntoTexture_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRPresentationProvider_SubmitFrameDrawnIntoTexture_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 32}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    // validate XRPresentationProvider_SubmitFrameDrawnIntoTexture_Params.syncToken
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, sync_token$.SyncToken, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRPresentationProvider_SubmitFrameDrawnIntoTexture_Params.timeWaited
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, time$.TimeDelta, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRPresentationProvider_SubmitFrameDrawnIntoTexture_Params.encodedSize = codec.kStructHeaderSize + 24;

  XRPresentationProvider_SubmitFrameDrawnIntoTexture_Params.decode = function(decoder) {
    var packed;
    var val = new XRPresentationProvider_SubmitFrameDrawnIntoTexture_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.frameId =
        decoder.decodeStruct(codec.Int16);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.syncToken =
        decoder.decodeStructPointer(sync_token$.SyncToken);
    val.timeWaited =
        decoder.decodeStructPointer(time$.TimeDelta);
    return val;
  };

  XRPresentationProvider_SubmitFrameDrawnIntoTexture_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRPresentationProvider_SubmitFrameDrawnIntoTexture_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int16, val.frameId);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStructPointer(sync_token$.SyncToken, val.syncToken);
    encoder.encodeStructPointer(time$.TimeDelta, val.timeWaited);
  };
  function XRPresentationClient_OnSubmitFrameTransferred_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRPresentationClient_OnSubmitFrameTransferred_Params.prototype.initDefaults_ = function() {
    this.success = false;
  };
  XRPresentationClient_OnSubmitFrameTransferred_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRPresentationClient_OnSubmitFrameTransferred_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  XRPresentationClient_OnSubmitFrameTransferred_Params.encodedSize = codec.kStructHeaderSize + 8;

  XRPresentationClient_OnSubmitFrameTransferred_Params.decode = function(decoder) {
    var packed;
    var val = new XRPresentationClient_OnSubmitFrameTransferred_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    packed = decoder.readUint8();
    val.success = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  XRPresentationClient_OnSubmitFrameTransferred_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRPresentationClient_OnSubmitFrameTransferred_Params.encodedSize);
    encoder.writeUint32(0);
    packed = 0;
    packed |= (val.success & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function XRPresentationClient_OnSubmitFrameRendered_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRPresentationClient_OnSubmitFrameRendered_Params.prototype.initDefaults_ = function() {
  };
  XRPresentationClient_OnSubmitFrameRendered_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRPresentationClient_OnSubmitFrameRendered_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRPresentationClient_OnSubmitFrameRendered_Params.encodedSize = codec.kStructHeaderSize + 0;

  XRPresentationClient_OnSubmitFrameRendered_Params.decode = function(decoder) {
    var packed;
    var val = new XRPresentationClient_OnSubmitFrameRendered_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  XRPresentationClient_OnSubmitFrameRendered_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRPresentationClient_OnSubmitFrameRendered_Params.encodedSize);
    encoder.writeUint32(0);
  };
  function XRPresentationClient_OnSubmitFrameGpuFence_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRPresentationClient_OnSubmitFrameGpuFence_Params.prototype.initDefaults_ = function() {
    this.gpuFenceHandle = null;
  };
  XRPresentationClient_OnSubmitFrameGpuFence_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRPresentationClient_OnSubmitFrameGpuFence_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRPresentationClient_OnSubmitFrameGpuFence_Params.gpuFenceHandle
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, gpu_fence_handle$.GpuFenceHandle, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRPresentationClient_OnSubmitFrameGpuFence_Params.encodedSize = codec.kStructHeaderSize + 8;

  XRPresentationClient_OnSubmitFrameGpuFence_Params.decode = function(decoder) {
    var packed;
    var val = new XRPresentationClient_OnSubmitFrameGpuFence_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.gpuFenceHandle =
        decoder.decodeStructPointer(gpu_fence_handle$.GpuFenceHandle);
    return val;
  };

  XRPresentationClient_OnSubmitFrameGpuFence_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRPresentationClient_OnSubmitFrameGpuFence_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(gpu_fence_handle$.GpuFenceHandle, val.gpuFenceHandle);
  };
  function XRSessionClient_OnExitPresent_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRSessionClient_OnExitPresent_Params.prototype.initDefaults_ = function() {
  };
  XRSessionClient_OnExitPresent_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRSessionClient_OnExitPresent_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRSessionClient_OnExitPresent_Params.encodedSize = codec.kStructHeaderSize + 0;

  XRSessionClient_OnExitPresent_Params.decode = function(decoder) {
    var packed;
    var val = new XRSessionClient_OnExitPresent_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  XRSessionClient_OnExitPresent_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRSessionClient_OnExitPresent_Params.encodedSize);
    encoder.writeUint32(0);
  };
  function XRSessionClient_OnVisibilityStateChanged_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  XRSessionClient_OnVisibilityStateChanged_Params.prototype.initDefaults_ = function() {
    this.visibilityState = 0;
  };
  XRSessionClient_OnVisibilityStateChanged_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  XRSessionClient_OnVisibilityStateChanged_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate XRSessionClient_OnVisibilityStateChanged_Params.visibilityState
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, XRVisibilityState);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  XRSessionClient_OnVisibilityStateChanged_Params.encodedSize = codec.kStructHeaderSize + 8;

  XRSessionClient_OnVisibilityStateChanged_Params.decode = function(decoder) {
    var packed;
    var val = new XRSessionClient_OnVisibilityStateChanged_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.visibilityState =
        decoder.decodeStruct(new codec.Enum(XRVisibilityState));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  XRSessionClient_OnVisibilityStateChanged_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(XRSessionClient_OnVisibilityStateChanged_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.visibilityState);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };

  function XRNativeOriginInformation(value) {
    this.initDefault_();
    this.initValue_(value);
  }


  XRNativeOriginInformation.Tags = {
    inputSourceSpaceInfo: 0,
    planeId: 1,
    anchorId: 2,
    referenceSpaceType: 3,
    handJointSpaceInfo: 4,
    imageIndex: 5,
  };

  XRNativeOriginInformation.prototype.initDefault_ = function() {
    this.$data = null;
    this.$tag = undefined;
  }

  XRNativeOriginInformation.prototype.initValue_ = function(value) {
    if (value == undefined) {
      return;
    }

    var keys = Object.keys(value);
    if (keys.length == 0) {
      return;
    }

    if (keys.length > 1) {
      throw new TypeError("You may set only one member on a union.");
    }

    var fields = [
        "inputSourceSpaceInfo",
        "planeId",
        "anchorId",
        "referenceSpaceType",
        "handJointSpaceInfo",
        "imageIndex",
    ];

    if (fields.indexOf(keys[0]) < 0) {
      throw new ReferenceError(keys[0] + " is not a XRNativeOriginInformation member.");

    }

    this[keys[0]] = value[keys[0]];
  }
  Object.defineProperty(XRNativeOriginInformation.prototype, "inputSourceSpaceInfo", {
    get: function() {
      if (this.$tag != XRNativeOriginInformation.Tags.inputSourceSpaceInfo) {
        throw new ReferenceError(
            "XRNativeOriginInformation.inputSourceSpaceInfo is not currently set.");
      }
      return this.$data;
    },

    set: function(value) {
      this.$tag = XRNativeOriginInformation.Tags.inputSourceSpaceInfo;
      this.$data = value;
    }
  });
  Object.defineProperty(XRNativeOriginInformation.prototype, "planeId", {
    get: function() {
      if (this.$tag != XRNativeOriginInformation.Tags.planeId) {
        throw new ReferenceError(
            "XRNativeOriginInformation.planeId is not currently set.");
      }
      return this.$data;
    },

    set: function(value) {
      this.$tag = XRNativeOriginInformation.Tags.planeId;
      this.$data = value;
    }
  });
  Object.defineProperty(XRNativeOriginInformation.prototype, "anchorId", {
    get: function() {
      if (this.$tag != XRNativeOriginInformation.Tags.anchorId) {
        throw new ReferenceError(
            "XRNativeOriginInformation.anchorId is not currently set.");
      }
      return this.$data;
    },

    set: function(value) {
      this.$tag = XRNativeOriginInformation.Tags.anchorId;
      this.$data = value;
    }
  });
  Object.defineProperty(XRNativeOriginInformation.prototype, "referenceSpaceType", {
    get: function() {
      if (this.$tag != XRNativeOriginInformation.Tags.referenceSpaceType) {
        throw new ReferenceError(
            "XRNativeOriginInformation.referenceSpaceType is not currently set.");
      }
      return this.$data;
    },

    set: function(value) {
      this.$tag = XRNativeOriginInformation.Tags.referenceSpaceType;
      this.$data = value;
    }
  });
  Object.defineProperty(XRNativeOriginInformation.prototype, "handJointSpaceInfo", {
    get: function() {
      if (this.$tag != XRNativeOriginInformation.Tags.handJointSpaceInfo) {
        throw new ReferenceError(
            "XRNativeOriginInformation.handJointSpaceInfo is not currently set.");
      }
      return this.$data;
    },

    set: function(value) {
      this.$tag = XRNativeOriginInformation.Tags.handJointSpaceInfo;
      this.$data = value;
    }
  });
  Object.defineProperty(XRNativeOriginInformation.prototype, "imageIndex", {
    get: function() {
      if (this.$tag != XRNativeOriginInformation.Tags.imageIndex) {
        throw new ReferenceError(
            "XRNativeOriginInformation.imageIndex is not currently set.");
      }
      return this.$data;
    },

    set: function(value) {
      this.$tag = XRNativeOriginInformation.Tags.imageIndex;
      this.$data = value;
    }
  });


    XRNativeOriginInformation.encode = function(encoder, val) {
      if (val == null) {
        encoder.writeUint64(0);
        encoder.writeUint64(0);
        return;
      }
      if (val.$tag == undefined) {
        throw new TypeError("Cannot encode unions with an unknown member set.");
      }

      encoder.writeUint32(16);
      encoder.writeUint32(val.$tag);
      switch (val.$tag) {
        case XRNativeOriginInformation.Tags.inputSourceSpaceInfo:
          encoder.encodeStructPointer(XRInputSourceSpaceInfo, val.inputSourceSpaceInfo);
          break;
        case XRNativeOriginInformation.Tags.planeId:
          encoder.encodeStruct(codec.Uint64, val.planeId);
          break;
        case XRNativeOriginInformation.Tags.anchorId:
          encoder.encodeStruct(codec.Uint64, val.anchorId);
          break;
        case XRNativeOriginInformation.Tags.referenceSpaceType:
          encoder.encodeStruct(codec.Int32, val.referenceSpaceType);
          break;
        case XRNativeOriginInformation.Tags.handJointSpaceInfo:
          encoder.encodeStructPointer(XRHandJointSpaceInfo, val.handJointSpaceInfo);
          break;
        case XRNativeOriginInformation.Tags.imageIndex:
          encoder.encodeStruct(codec.Uint32, val.imageIndex);
          break;
      }
      encoder.align();
    };


    XRNativeOriginInformation.decode = function(decoder) {
      var size = decoder.readUint32();
      if (size == 0) {
        decoder.readUint32();
        decoder.readUint64();
        return null;
      }

      var result = new XRNativeOriginInformation();
      var tag = decoder.readUint32();
      switch (tag) {
        case XRNativeOriginInformation.Tags.inputSourceSpaceInfo:
          result.inputSourceSpaceInfo = decoder.decodeStructPointer(XRInputSourceSpaceInfo);
          break;
        case XRNativeOriginInformation.Tags.planeId:
          result.planeId = decoder.decodeStruct(codec.Uint64);
          break;
        case XRNativeOriginInformation.Tags.anchorId:
          result.anchorId = decoder.decodeStruct(codec.Uint64);
          break;
        case XRNativeOriginInformation.Tags.referenceSpaceType:
          result.referenceSpaceType = decoder.decodeStruct(new codec.Enum(XRReferenceSpaceType));
          break;
        case XRNativeOriginInformation.Tags.handJointSpaceInfo:
          result.handJointSpaceInfo = decoder.decodeStructPointer(XRHandJointSpaceInfo);
          break;
        case XRNativeOriginInformation.Tags.imageIndex:
          result.imageIndex = decoder.decodeStruct(codec.Uint32);
          break;
      }
      decoder.align();

      return result;
    };


    XRNativeOriginInformation.validate = function(messageValidator, offset) {
      var size = messageValidator.decodeUnionSize(offset);
      if (size != 16) {
        return validator.validationError.INVALID_UNION_SIZE;
      }

      var tag = messageValidator.decodeUnionTag(offset);
      var data_offset = offset + 8;
      var err;
      switch (tag) {
        case XRNativeOriginInformation.Tags.inputSourceSpaceInfo:
          

    // validate XRNativeOriginInformation.inputSourceSpaceInfo
    err = messageValidator.validateStructPointer(data_offset, XRInputSourceSpaceInfo, false);
    if (err !== validator.validationError.NONE)
        return err;
          break;
        case XRNativeOriginInformation.Tags.planeId:
          

          break;
        case XRNativeOriginInformation.Tags.anchorId:
          

          break;
        case XRNativeOriginInformation.Tags.referenceSpaceType:
          

    // validate XRNativeOriginInformation.referenceSpaceType
    err = messageValidator.validateEnum(data_offset, XRReferenceSpaceType);
    if (err !== validator.validationError.NONE)
        return err;
          break;
        case XRNativeOriginInformation.Tags.handJointSpaceInfo:
          

    // validate XRNativeOriginInformation.handJointSpaceInfo
    err = messageValidator.validateStructPointer(data_offset, XRHandJointSpaceInfo, false);
    if (err !== validator.validationError.NONE)
        return err;
          break;
        case XRNativeOriginInformation.Tags.imageIndex:
          

          break;
      }

      return validator.validationError.NONE;
    };

  XRNativeOriginInformation.encodedSize = 16;

  function XRDepthData(value) {
    this.initDefault_();
    this.initValue_(value);
  }


  XRDepthData.Tags = {
    dataStillValid: 0,
    updatedDepthData: 1,
  };

  XRDepthData.prototype.initDefault_ = function() {
    this.$data = null;
    this.$tag = undefined;
  }

  XRDepthData.prototype.initValue_ = function(value) {
    if (value == undefined) {
      return;
    }

    var keys = Object.keys(value);
    if (keys.length == 0) {
      return;
    }

    if (keys.length > 1) {
      throw new TypeError("You may set only one member on a union.");
    }

    var fields = [
        "dataStillValid",
        "updatedDepthData",
    ];

    if (fields.indexOf(keys[0]) < 0) {
      throw new ReferenceError(keys[0] + " is not a XRDepthData member.");

    }

    this[keys[0]] = value[keys[0]];
  }
  Object.defineProperty(XRDepthData.prototype, "dataStillValid", {
    get: function() {
      if (this.$tag != XRDepthData.Tags.dataStillValid) {
        throw new ReferenceError(
            "XRDepthData.dataStillValid is not currently set.");
      }
      return this.$data;
    },

    set: function(value) {
      this.$tag = XRDepthData.Tags.dataStillValid;
      this.$data = value;
    }
  });
  Object.defineProperty(XRDepthData.prototype, "updatedDepthData", {
    get: function() {
      if (this.$tag != XRDepthData.Tags.updatedDepthData) {
        throw new ReferenceError(
            "XRDepthData.updatedDepthData is not currently set.");
      }
      return this.$data;
    },

    set: function(value) {
      this.$tag = XRDepthData.Tags.updatedDepthData;
      this.$data = value;
    }
  });


    XRDepthData.encode = function(encoder, val) {
      if (val == null) {
        encoder.writeUint64(0);
        encoder.writeUint64(0);
        return;
      }
      if (val.$tag == undefined) {
        throw new TypeError("Cannot encode unions with an unknown member set.");
      }

      encoder.writeUint32(16);
      encoder.writeUint32(val.$tag);
      switch (val.$tag) {
        case XRDepthData.Tags.dataStillValid:
          encoder.encodeStructPointer(XRDepthDataStillValid, val.dataStillValid);
          break;
        case XRDepthData.Tags.updatedDepthData:
          encoder.encodeStructPointer(XRDepthDataUpdated, val.updatedDepthData);
          break;
      }
      encoder.align();
    };


    XRDepthData.decode = function(decoder) {
      var size = decoder.readUint32();
      if (size == 0) {
        decoder.readUint32();
        decoder.readUint64();
        return null;
      }

      var result = new XRDepthData();
      var tag = decoder.readUint32();
      switch (tag) {
        case XRDepthData.Tags.dataStillValid:
          result.dataStillValid = decoder.decodeStructPointer(XRDepthDataStillValid);
          break;
        case XRDepthData.Tags.updatedDepthData:
          result.updatedDepthData = decoder.decodeStructPointer(XRDepthDataUpdated);
          break;
      }
      decoder.align();

      return result;
    };


    XRDepthData.validate = function(messageValidator, offset) {
      var size = messageValidator.decodeUnionSize(offset);
      if (size != 16) {
        return validator.validationError.INVALID_UNION_SIZE;
      }

      var tag = messageValidator.decodeUnionTag(offset);
      var data_offset = offset + 8;
      var err;
      switch (tag) {
        case XRDepthData.Tags.dataStillValid:
          

    // validate XRDepthData.dataStillValid
    err = messageValidator.validateStructPointer(data_offset, XRDepthDataStillValid, false);
    if (err !== validator.validationError.NONE)
        return err;
          break;
        case XRDepthData.Tags.updatedDepthData:
          

    // validate XRDepthData.updatedDepthData
    err = messageValidator.validateStructPointer(data_offset, XRDepthDataUpdated, false);
    if (err !== validator.validationError.NONE)
        return err;
          break;
      }

      return validator.validationError.NONE;
    };

  XRDepthData.encodedSize = 16;

  function RequestSessionResult(value) {
    this.initDefault_();
    this.initValue_(value);
  }


  RequestSessionResult.Tags = {
    success: 0,
    failureReason: 1,
  };

  RequestSessionResult.prototype.initDefault_ = function() {
    this.$data = null;
    this.$tag = undefined;
  }

  RequestSessionResult.prototype.initValue_ = function(value) {
    if (value == undefined) {
      return;
    }

    var keys = Object.keys(value);
    if (keys.length == 0) {
      return;
    }

    if (keys.length > 1) {
      throw new TypeError("You may set only one member on a union.");
    }

    var fields = [
        "success",
        "failureReason",
    ];

    if (fields.indexOf(keys[0]) < 0) {
      throw new ReferenceError(keys[0] + " is not a RequestSessionResult member.");

    }

    this[keys[0]] = value[keys[0]];
  }
  Object.defineProperty(RequestSessionResult.prototype, "success", {
    get: function() {
      if (this.$tag != RequestSessionResult.Tags.success) {
        throw new ReferenceError(
            "RequestSessionResult.success is not currently set.");
      }
      return this.$data;
    },

    set: function(value) {
      this.$tag = RequestSessionResult.Tags.success;
      this.$data = value;
    }
  });
  Object.defineProperty(RequestSessionResult.prototype, "failureReason", {
    get: function() {
      if (this.$tag != RequestSessionResult.Tags.failureReason) {
        throw new ReferenceError(
            "RequestSessionResult.failureReason is not currently set.");
      }
      return this.$data;
    },

    set: function(value) {
      this.$tag = RequestSessionResult.Tags.failureReason;
      this.$data = value;
    }
  });


    RequestSessionResult.encode = function(encoder, val) {
      if (val == null) {
        encoder.writeUint64(0);
        encoder.writeUint64(0);
        return;
      }
      if (val.$tag == undefined) {
        throw new TypeError("Cannot encode unions with an unknown member set.");
      }

      encoder.writeUint32(16);
      encoder.writeUint32(val.$tag);
      switch (val.$tag) {
        case RequestSessionResult.Tags.success:
          encoder.encodeStructPointer(RequestSessionSuccess, val.success);
          break;
        case RequestSessionResult.Tags.failureReason:
          encoder.encodeStruct(codec.Int32, val.failureReason);
          break;
      }
      encoder.align();
    };


    RequestSessionResult.decode = function(decoder) {
      var size = decoder.readUint32();
      if (size == 0) {
        decoder.readUint32();
        decoder.readUint64();
        return null;
      }

      var result = new RequestSessionResult();
      var tag = decoder.readUint32();
      switch (tag) {
        case RequestSessionResult.Tags.success:
          result.success = decoder.decodeStructPointer(RequestSessionSuccess);
          break;
        case RequestSessionResult.Tags.failureReason:
          result.failureReason = decoder.decodeStruct(new codec.Enum(xr_session$.RequestSessionError));
          break;
      }
      decoder.align();

      return result;
    };


    RequestSessionResult.validate = function(messageValidator, offset) {
      var size = messageValidator.decodeUnionSize(offset);
      if (size != 16) {
        return validator.validationError.INVALID_UNION_SIZE;
      }

      var tag = messageValidator.decodeUnionTag(offset);
      var data_offset = offset + 8;
      var err;
      switch (tag) {
        case RequestSessionResult.Tags.success:
          

    // validate RequestSessionResult.success
    err = messageValidator.validateStructPointer(data_offset, RequestSessionSuccess, false);
    if (err !== validator.validationError.NONE)
        return err;
          break;
        case RequestSessionResult.Tags.failureReason:
          

    // validate RequestSessionResult.failureReason
    err = messageValidator.validateEnum(data_offset, xr_session$.RequestSessionError);
    if (err !== validator.validationError.NONE)
        return err;
          break;
      }

      return validator.validationError.NONE;
    };

  RequestSessionResult.encodedSize = 16;
  var kVRService_SetClient_Name = 1481673402;
  var kVRService_RequestSession_Name = 74895163;
  var kVRService_SupportsSession_Name = 1834955089;
  var kVRService_ExitPresent_Name = 1004406700;
  var kVRService_SetFramesThrottled_Name = 263970893;
  var kVRService_MakeXrCompatible_Name = 1749619786;

  function VRServicePtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(VRService,
                                                   handleOrPtrInfo);
  }

  function VRServiceAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        VRService, associatedInterfacePtrInfo);
  }

  VRServiceAssociatedPtr.prototype =
      Object.create(VRServicePtr.prototype);
  VRServiceAssociatedPtr.prototype.constructor =
      VRServiceAssociatedPtr;

  function VRServiceProxy(receiver) {
    this.receiver_ = receiver;
  }
  VRServicePtr.prototype.setClient = function() {
    return VRServiceProxy.prototype.setClient
        .apply(this.ptr.getProxy(), arguments);
  };

  VRServiceProxy.prototype.setClient = function(client) {
    var params_ = new VRService_SetClient_Params();
    params_.client = client;
    var builder = new codec.MessageV0Builder(
        kVRService_SetClient_Name,
        codec.align(VRService_SetClient_Params.encodedSize));
    builder.encodeStruct(VRService_SetClient_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  VRServicePtr.prototype.requestSession = function() {
    return VRServiceProxy.prototype.requestSession
        .apply(this.ptr.getProxy(), arguments);
  };

  VRServiceProxy.prototype.requestSession = function(options) {
    var params_ = new VRService_RequestSession_Params();
    params_.options = options;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kVRService_RequestSession_Name,
          codec.align(VRService_RequestSession_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(VRService_RequestSession_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(VRService_RequestSession_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  VRServicePtr.prototype.supportsSession = function() {
    return VRServiceProxy.prototype.supportsSession
        .apply(this.ptr.getProxy(), arguments);
  };

  VRServiceProxy.prototype.supportsSession = function(options) {
    var params_ = new VRService_SupportsSession_Params();
    params_.options = options;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kVRService_SupportsSession_Name,
          codec.align(VRService_SupportsSession_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(VRService_SupportsSession_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(VRService_SupportsSession_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  VRServicePtr.prototype.exitPresent = function() {
    return VRServiceProxy.prototype.exitPresent
        .apply(this.ptr.getProxy(), arguments);
  };

  VRServiceProxy.prototype.exitPresent = function() {
    var params_ = new VRService_ExitPresent_Params();
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kVRService_ExitPresent_Name,
          codec.align(VRService_ExitPresent_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(VRService_ExitPresent_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(VRService_ExitPresent_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  VRServicePtr.prototype.setFramesThrottled = function() {
    return VRServiceProxy.prototype.setFramesThrottled
        .apply(this.ptr.getProxy(), arguments);
  };

  VRServiceProxy.prototype.setFramesThrottled = function(throttled) {
    var params_ = new VRService_SetFramesThrottled_Params();
    params_.throttled = throttled;
    var builder = new codec.MessageV0Builder(
        kVRService_SetFramesThrottled_Name,
        codec.align(VRService_SetFramesThrottled_Params.encodedSize));
    builder.encodeStruct(VRService_SetFramesThrottled_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  VRServicePtr.prototype.makeXrCompatible = function() {
    return VRServiceProxy.prototype.makeXrCompatible
        .apply(this.ptr.getProxy(), arguments);
  };

  VRServiceProxy.prototype.makeXrCompatible = function() {
    var params_ = new VRService_MakeXrCompatible_Params();
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kVRService_MakeXrCompatible_Name,
          codec.align(VRService_MakeXrCompatible_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(VRService_MakeXrCompatible_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(VRService_MakeXrCompatible_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };

  function VRServiceStub(delegate) {
    this.delegate_ = delegate;
  }
  VRServiceStub.prototype.setClient = function(client) {
    return this.delegate_ && this.delegate_.setClient && this.delegate_.setClient(client);
  }
  VRServiceStub.prototype.requestSession = function(options) {
    return this.delegate_ && this.delegate_.requestSession && this.delegate_.requestSession(options);
  }
  VRServiceStub.prototype.supportsSession = function(options) {
    return this.delegate_ && this.delegate_.supportsSession && this.delegate_.supportsSession(options);
  }
  VRServiceStub.prototype.exitPresent = function() {
    return this.delegate_ && this.delegate_.exitPresent && this.delegate_.exitPresent();
  }
  VRServiceStub.prototype.setFramesThrottled = function(throttled) {
    return this.delegate_ && this.delegate_.setFramesThrottled && this.delegate_.setFramesThrottled(throttled);
  }
  VRServiceStub.prototype.makeXrCompatible = function() {
    return this.delegate_ && this.delegate_.makeXrCompatible && this.delegate_.makeXrCompatible();
  }

  VRServiceStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kVRService_SetClient_Name:
      var params = reader.decodeStruct(VRService_SetClient_Params);
      this.setClient(params.client);
      return true;
    case kVRService_SetFramesThrottled_Name:
      var params = reader.decodeStruct(VRService_SetFramesThrottled_Params);
      this.setFramesThrottled(params.throttled);
      return true;
    default:
      return false;
    }
  };

  VRServiceStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kVRService_RequestSession_Name:
      var params = reader.decodeStruct(VRService_RequestSession_Params);
      this.requestSession(params.options).then(function(response) {
        var responseParams =
            new VRService_RequestSession_ResponseParams();
        responseParams.result = response.result;
        var builder = new codec.MessageV1Builder(
            kVRService_RequestSession_Name,
            codec.align(VRService_RequestSession_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(VRService_RequestSession_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kVRService_SupportsSession_Name:
      var params = reader.decodeStruct(VRService_SupportsSession_Params);
      this.supportsSession(params.options).then(function(response) {
        var responseParams =
            new VRService_SupportsSession_ResponseParams();
        responseParams.supportsSession = response.supportsSession;
        var builder = new codec.MessageV1Builder(
            kVRService_SupportsSession_Name,
            codec.align(VRService_SupportsSession_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(VRService_SupportsSession_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kVRService_ExitPresent_Name:
      var params = reader.decodeStruct(VRService_ExitPresent_Params);
      this.exitPresent().then(function(response) {
        var responseParams =
            new VRService_ExitPresent_ResponseParams();
        var builder = new codec.MessageV1Builder(
            kVRService_ExitPresent_Name,
            codec.align(VRService_ExitPresent_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(VRService_ExitPresent_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kVRService_MakeXrCompatible_Name:
      var params = reader.decodeStruct(VRService_MakeXrCompatible_Params);
      this.makeXrCompatible().then(function(response) {
        var responseParams =
            new VRService_MakeXrCompatible_ResponseParams();
        responseParams.xrCompatibleResult = response.xrCompatibleResult;
        var builder = new codec.MessageV1Builder(
            kVRService_MakeXrCompatible_Name,
            codec.align(VRService_MakeXrCompatible_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(VRService_MakeXrCompatible_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    default:
      return false;
    }
  };

  function validateVRServiceRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kVRService_SetClient_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = VRService_SetClient_Params;
      break;
      case kVRService_RequestSession_Name:
        if (message.expectsResponse())
          paramsClass = VRService_RequestSession_Params;
      break;
      case kVRService_SupportsSession_Name:
        if (message.expectsResponse())
          paramsClass = VRService_SupportsSession_Params;
      break;
      case kVRService_ExitPresent_Name:
        if (message.expectsResponse())
          paramsClass = VRService_ExitPresent_Params;
      break;
      case kVRService_SetFramesThrottled_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = VRService_SetFramesThrottled_Params;
      break;
      case kVRService_MakeXrCompatible_Name:
        if (message.expectsResponse())
          paramsClass = VRService_MakeXrCompatible_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateVRServiceResponse(messageValidator) {
   var message = messageValidator.message;
   var paramsClass = null;
   switch (message.getName()) {
      case kVRService_RequestSession_Name:
        if (message.isResponse())
          paramsClass = VRService_RequestSession_ResponseParams;
        break;
      case kVRService_SupportsSession_Name:
        if (message.isResponse())
          paramsClass = VRService_SupportsSession_ResponseParams;
        break;
      case kVRService_ExitPresent_Name:
        if (message.isResponse())
          paramsClass = VRService_ExitPresent_ResponseParams;
        break;
      case kVRService_MakeXrCompatible_Name:
        if (message.isResponse())
          paramsClass = VRService_MakeXrCompatible_ResponseParams;
        break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  var VRService = {
    name: 'device.mojom.VRService',
    kVersion: 0,
    ptrClass: VRServicePtr,
    proxyClass: VRServiceProxy,
    stubClass: VRServiceStub,
    validateRequest: validateVRServiceRequest,
    validateResponse: validateVRServiceResponse,
  };
  VRServiceStub.prototype.validator = validateVRServiceRequest;
  VRServiceProxy.prototype.validator = validateVRServiceResponse;
  var kXRSessionMetricsRecorder_ReportFeatureUsed_Name = 56489913;

  function XRSessionMetricsRecorderPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(XRSessionMetricsRecorder,
                                                   handleOrPtrInfo);
  }

  function XRSessionMetricsRecorderAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        XRSessionMetricsRecorder, associatedInterfacePtrInfo);
  }

  XRSessionMetricsRecorderAssociatedPtr.prototype =
      Object.create(XRSessionMetricsRecorderPtr.prototype);
  XRSessionMetricsRecorderAssociatedPtr.prototype.constructor =
      XRSessionMetricsRecorderAssociatedPtr;

  function XRSessionMetricsRecorderProxy(receiver) {
    this.receiver_ = receiver;
  }
  XRSessionMetricsRecorderPtr.prototype.reportFeatureUsed = function() {
    return XRSessionMetricsRecorderProxy.prototype.reportFeatureUsed
        .apply(this.ptr.getProxy(), arguments);
  };

  XRSessionMetricsRecorderProxy.prototype.reportFeatureUsed = function(feature) {
    var params_ = new XRSessionMetricsRecorder_ReportFeatureUsed_Params();
    params_.feature = feature;
    var builder = new codec.MessageV0Builder(
        kXRSessionMetricsRecorder_ReportFeatureUsed_Name,
        codec.align(XRSessionMetricsRecorder_ReportFeatureUsed_Params.encodedSize));
    builder.encodeStruct(XRSessionMetricsRecorder_ReportFeatureUsed_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };

  function XRSessionMetricsRecorderStub(delegate) {
    this.delegate_ = delegate;
  }
  XRSessionMetricsRecorderStub.prototype.reportFeatureUsed = function(feature) {
    return this.delegate_ && this.delegate_.reportFeatureUsed && this.delegate_.reportFeatureUsed(feature);
  }

  XRSessionMetricsRecorderStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kXRSessionMetricsRecorder_ReportFeatureUsed_Name:
      var params = reader.decodeStruct(XRSessionMetricsRecorder_ReportFeatureUsed_Params);
      this.reportFeatureUsed(params.feature);
      return true;
    default:
      return false;
    }
  };

  XRSessionMetricsRecorderStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  function validateXRSessionMetricsRecorderRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kXRSessionMetricsRecorder_ReportFeatureUsed_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = XRSessionMetricsRecorder_ReportFeatureUsed_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateXRSessionMetricsRecorderResponse(messageValidator) {
    return validator.validationError.NONE;
  }

  var XRSessionMetricsRecorder = {
    name: 'device.mojom.XRSessionMetricsRecorder',
    kVersion: 0,
    ptrClass: XRSessionMetricsRecorderPtr,
    proxyClass: XRSessionMetricsRecorderProxy,
    stubClass: XRSessionMetricsRecorderStub,
    validateRequest: validateXRSessionMetricsRecorderRequest,
    validateResponse: null,
  };
  XRSessionMetricsRecorderStub.prototype.validator = validateXRSessionMetricsRecorderRequest;
  XRSessionMetricsRecorderProxy.prototype.validator = null;
  var kVRServiceClient_OnDeviceChanged_Name = 1451488046;

  function VRServiceClientPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(VRServiceClient,
                                                   handleOrPtrInfo);
  }

  function VRServiceClientAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        VRServiceClient, associatedInterfacePtrInfo);
  }

  VRServiceClientAssociatedPtr.prototype =
      Object.create(VRServiceClientPtr.prototype);
  VRServiceClientAssociatedPtr.prototype.constructor =
      VRServiceClientAssociatedPtr;

  function VRServiceClientProxy(receiver) {
    this.receiver_ = receiver;
  }
  VRServiceClientPtr.prototype.onDeviceChanged = function() {
    return VRServiceClientProxy.prototype.onDeviceChanged
        .apply(this.ptr.getProxy(), arguments);
  };

  VRServiceClientProxy.prototype.onDeviceChanged = function() {
    var params_ = new VRServiceClient_OnDeviceChanged_Params();
    var builder = new codec.MessageV0Builder(
        kVRServiceClient_OnDeviceChanged_Name,
        codec.align(VRServiceClient_OnDeviceChanged_Params.encodedSize));
    builder.encodeStruct(VRServiceClient_OnDeviceChanged_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };

  function VRServiceClientStub(delegate) {
    this.delegate_ = delegate;
  }
  VRServiceClientStub.prototype.onDeviceChanged = function() {
    return this.delegate_ && this.delegate_.onDeviceChanged && this.delegate_.onDeviceChanged();
  }

  VRServiceClientStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kVRServiceClient_OnDeviceChanged_Name:
      var params = reader.decodeStruct(VRServiceClient_OnDeviceChanged_Params);
      this.onDeviceChanged();
      return true;
    default:
      return false;
    }
  };

  VRServiceClientStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  function validateVRServiceClientRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kVRServiceClient_OnDeviceChanged_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = VRServiceClient_OnDeviceChanged_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateVRServiceClientResponse(messageValidator) {
    return validator.validationError.NONE;
  }

  var VRServiceClient = {
    name: 'device.mojom.VRServiceClient',
    kVersion: 0,
    ptrClass: VRServiceClientPtr,
    proxyClass: VRServiceClientProxy,
    stubClass: VRServiceClientStub,
    validateRequest: validateVRServiceClientRequest,
    validateResponse: null,
  };
  VRServiceClientStub.prototype.validator = validateVRServiceClientRequest;
  VRServiceClientProxy.prototype.validator = null;
  var kXREnvironmentIntegrationProvider_SubscribeToHitTest_Name = 912492324;
  var kXREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_Name = 888743605;
  var kXREnvironmentIntegrationProvider_UnsubscribeFromHitTest_Name = 1545576151;
  var kXREnvironmentIntegrationProvider_CreateAnchor_Name = 1255988942;
  var kXREnvironmentIntegrationProvider_CreatePlaneAnchor_Name = 320341154;
  var kXREnvironmentIntegrationProvider_DetachAnchor_Name = 1716176298;

  function XREnvironmentIntegrationProviderPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(XREnvironmentIntegrationProvider,
                                                   handleOrPtrInfo);
  }

  function XREnvironmentIntegrationProviderAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        XREnvironmentIntegrationProvider, associatedInterfacePtrInfo);
  }

  XREnvironmentIntegrationProviderAssociatedPtr.prototype =
      Object.create(XREnvironmentIntegrationProviderPtr.prototype);
  XREnvironmentIntegrationProviderAssociatedPtr.prototype.constructor =
      XREnvironmentIntegrationProviderAssociatedPtr;

  function XREnvironmentIntegrationProviderProxy(receiver) {
    this.receiver_ = receiver;
  }
  XREnvironmentIntegrationProviderPtr.prototype.subscribeToHitTest = function() {
    return XREnvironmentIntegrationProviderProxy.prototype.subscribeToHitTest
        .apply(this.ptr.getProxy(), arguments);
  };

  XREnvironmentIntegrationProviderProxy.prototype.subscribeToHitTest = function(nativeOriginInformation, entityTypes, ray) {
    var params_ = new XREnvironmentIntegrationProvider_SubscribeToHitTest_Params();
    params_.nativeOriginInformation = nativeOriginInformation;
    params_.entityTypes = entityTypes;
    params_.ray = ray;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kXREnvironmentIntegrationProvider_SubscribeToHitTest_Name,
          codec.align(XREnvironmentIntegrationProvider_SubscribeToHitTest_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(XREnvironmentIntegrationProvider_SubscribeToHitTest_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(XREnvironmentIntegrationProvider_SubscribeToHitTest_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  XREnvironmentIntegrationProviderPtr.prototype.subscribeToHitTestForTransientInput = function() {
    return XREnvironmentIntegrationProviderProxy.prototype.subscribeToHitTestForTransientInput
        .apply(this.ptr.getProxy(), arguments);
  };

  XREnvironmentIntegrationProviderProxy.prototype.subscribeToHitTestForTransientInput = function(profileName, entityTypes, ray) {
    var params_ = new XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_Params();
    params_.profileName = profileName;
    params_.entityTypes = entityTypes;
    params_.ray = ray;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kXREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_Name,
          codec.align(XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  XREnvironmentIntegrationProviderPtr.prototype.unsubscribeFromHitTest = function() {
    return XREnvironmentIntegrationProviderProxy.prototype.unsubscribeFromHitTest
        .apply(this.ptr.getProxy(), arguments);
  };

  XREnvironmentIntegrationProviderProxy.prototype.unsubscribeFromHitTest = function(subscriptionId) {
    var params_ = new XREnvironmentIntegrationProvider_UnsubscribeFromHitTest_Params();
    params_.subscriptionId = subscriptionId;
    var builder = new codec.MessageV0Builder(
        kXREnvironmentIntegrationProvider_UnsubscribeFromHitTest_Name,
        codec.align(XREnvironmentIntegrationProvider_UnsubscribeFromHitTest_Params.encodedSize));
    builder.encodeStruct(XREnvironmentIntegrationProvider_UnsubscribeFromHitTest_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  XREnvironmentIntegrationProviderPtr.prototype.createAnchor = function() {
    return XREnvironmentIntegrationProviderProxy.prototype.createAnchor
        .apply(this.ptr.getProxy(), arguments);
  };

  XREnvironmentIntegrationProviderProxy.prototype.createAnchor = function(nativeOriginInformation, nativeOriginFromAnchor) {
    var params_ = new XREnvironmentIntegrationProvider_CreateAnchor_Params();
    params_.nativeOriginInformation = nativeOriginInformation;
    params_.nativeOriginFromAnchor = nativeOriginFromAnchor;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kXREnvironmentIntegrationProvider_CreateAnchor_Name,
          codec.align(XREnvironmentIntegrationProvider_CreateAnchor_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(XREnvironmentIntegrationProvider_CreateAnchor_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(XREnvironmentIntegrationProvider_CreateAnchor_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  XREnvironmentIntegrationProviderPtr.prototype.createPlaneAnchor = function() {
    return XREnvironmentIntegrationProviderProxy.prototype.createPlaneAnchor
        .apply(this.ptr.getProxy(), arguments);
  };

  XREnvironmentIntegrationProviderProxy.prototype.createPlaneAnchor = function(nativeOriginInformation, nativeOriginFromAnchor, planeId) {
    var params_ = new XREnvironmentIntegrationProvider_CreatePlaneAnchor_Params();
    params_.nativeOriginInformation = nativeOriginInformation;
    params_.nativeOriginFromAnchor = nativeOriginFromAnchor;
    params_.planeId = planeId;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kXREnvironmentIntegrationProvider_CreatePlaneAnchor_Name,
          codec.align(XREnvironmentIntegrationProvider_CreatePlaneAnchor_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(XREnvironmentIntegrationProvider_CreatePlaneAnchor_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(XREnvironmentIntegrationProvider_CreatePlaneAnchor_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  XREnvironmentIntegrationProviderPtr.prototype.detachAnchor = function() {
    return XREnvironmentIntegrationProviderProxy.prototype.detachAnchor
        .apply(this.ptr.getProxy(), arguments);
  };

  XREnvironmentIntegrationProviderProxy.prototype.detachAnchor = function(anchorId) {
    var params_ = new XREnvironmentIntegrationProvider_DetachAnchor_Params();
    params_.anchorId = anchorId;
    var builder = new codec.MessageV0Builder(
        kXREnvironmentIntegrationProvider_DetachAnchor_Name,
        codec.align(XREnvironmentIntegrationProvider_DetachAnchor_Params.encodedSize));
    builder.encodeStruct(XREnvironmentIntegrationProvider_DetachAnchor_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };

  function XREnvironmentIntegrationProviderStub(delegate) {
    this.delegate_ = delegate;
  }
  XREnvironmentIntegrationProviderStub.prototype.subscribeToHitTest = function(nativeOriginInformation, entityTypes, ray) {
    return this.delegate_ && this.delegate_.subscribeToHitTest && this.delegate_.subscribeToHitTest(nativeOriginInformation, entityTypes, ray);
  }
  XREnvironmentIntegrationProviderStub.prototype.subscribeToHitTestForTransientInput = function(profileName, entityTypes, ray) {
    return this.delegate_ && this.delegate_.subscribeToHitTestForTransientInput && this.delegate_.subscribeToHitTestForTransientInput(profileName, entityTypes, ray);
  }
  XREnvironmentIntegrationProviderStub.prototype.unsubscribeFromHitTest = function(subscriptionId) {
    return this.delegate_ && this.delegate_.unsubscribeFromHitTest && this.delegate_.unsubscribeFromHitTest(subscriptionId);
  }
  XREnvironmentIntegrationProviderStub.prototype.createAnchor = function(nativeOriginInformation, nativeOriginFromAnchor) {
    return this.delegate_ && this.delegate_.createAnchor && this.delegate_.createAnchor(nativeOriginInformation, nativeOriginFromAnchor);
  }
  XREnvironmentIntegrationProviderStub.prototype.createPlaneAnchor = function(nativeOriginInformation, nativeOriginFromAnchor, planeId) {
    return this.delegate_ && this.delegate_.createPlaneAnchor && this.delegate_.createPlaneAnchor(nativeOriginInformation, nativeOriginFromAnchor, planeId);
  }
  XREnvironmentIntegrationProviderStub.prototype.detachAnchor = function(anchorId) {
    return this.delegate_ && this.delegate_.detachAnchor && this.delegate_.detachAnchor(anchorId);
  }

  XREnvironmentIntegrationProviderStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kXREnvironmentIntegrationProvider_UnsubscribeFromHitTest_Name:
      var params = reader.decodeStruct(XREnvironmentIntegrationProvider_UnsubscribeFromHitTest_Params);
      this.unsubscribeFromHitTest(params.subscriptionId);
      return true;
    case kXREnvironmentIntegrationProvider_DetachAnchor_Name:
      var params = reader.decodeStruct(XREnvironmentIntegrationProvider_DetachAnchor_Params);
      this.detachAnchor(params.anchorId);
      return true;
    default:
      return false;
    }
  };

  XREnvironmentIntegrationProviderStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kXREnvironmentIntegrationProvider_SubscribeToHitTest_Name:
      var params = reader.decodeStruct(XREnvironmentIntegrationProvider_SubscribeToHitTest_Params);
      this.subscribeToHitTest(params.nativeOriginInformation, params.entityTypes, params.ray).then(function(response) {
        var responseParams =
            new XREnvironmentIntegrationProvider_SubscribeToHitTest_ResponseParams();
        responseParams.result = response.result;
        responseParams.subscriptionId = response.subscriptionId;
        var builder = new codec.MessageV1Builder(
            kXREnvironmentIntegrationProvider_SubscribeToHitTest_Name,
            codec.align(XREnvironmentIntegrationProvider_SubscribeToHitTest_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(XREnvironmentIntegrationProvider_SubscribeToHitTest_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kXREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_Name:
      var params = reader.decodeStruct(XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_Params);
      this.subscribeToHitTestForTransientInput(params.profileName, params.entityTypes, params.ray).then(function(response) {
        var responseParams =
            new XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_ResponseParams();
        responseParams.result = response.result;
        responseParams.subscriptionId = response.subscriptionId;
        var builder = new codec.MessageV1Builder(
            kXREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_Name,
            codec.align(XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kXREnvironmentIntegrationProvider_CreateAnchor_Name:
      var params = reader.decodeStruct(XREnvironmentIntegrationProvider_CreateAnchor_Params);
      this.createAnchor(params.nativeOriginInformation, params.nativeOriginFromAnchor).then(function(response) {
        var responseParams =
            new XREnvironmentIntegrationProvider_CreateAnchor_ResponseParams();
        responseParams.result = response.result;
        responseParams.anchorId = response.anchorId;
        var builder = new codec.MessageV1Builder(
            kXREnvironmentIntegrationProvider_CreateAnchor_Name,
            codec.align(XREnvironmentIntegrationProvider_CreateAnchor_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(XREnvironmentIntegrationProvider_CreateAnchor_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kXREnvironmentIntegrationProvider_CreatePlaneAnchor_Name:
      var params = reader.decodeStruct(XREnvironmentIntegrationProvider_CreatePlaneAnchor_Params);
      this.createPlaneAnchor(params.nativeOriginInformation, params.nativeOriginFromAnchor, params.planeId).then(function(response) {
        var responseParams =
            new XREnvironmentIntegrationProvider_CreatePlaneAnchor_ResponseParams();
        responseParams.result = response.result;
        responseParams.anchorId = response.anchorId;
        var builder = new codec.MessageV1Builder(
            kXREnvironmentIntegrationProvider_CreatePlaneAnchor_Name,
            codec.align(XREnvironmentIntegrationProvider_CreatePlaneAnchor_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(XREnvironmentIntegrationProvider_CreatePlaneAnchor_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    default:
      return false;
    }
  };

  function validateXREnvironmentIntegrationProviderRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kXREnvironmentIntegrationProvider_SubscribeToHitTest_Name:
        if (message.expectsResponse())
          paramsClass = XREnvironmentIntegrationProvider_SubscribeToHitTest_Params;
      break;
      case kXREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_Name:
        if (message.expectsResponse())
          paramsClass = XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_Params;
      break;
      case kXREnvironmentIntegrationProvider_UnsubscribeFromHitTest_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = XREnvironmentIntegrationProvider_UnsubscribeFromHitTest_Params;
      break;
      case kXREnvironmentIntegrationProvider_CreateAnchor_Name:
        if (message.expectsResponse())
          paramsClass = XREnvironmentIntegrationProvider_CreateAnchor_Params;
      break;
      case kXREnvironmentIntegrationProvider_CreatePlaneAnchor_Name:
        if (message.expectsResponse())
          paramsClass = XREnvironmentIntegrationProvider_CreatePlaneAnchor_Params;
      break;
      case kXREnvironmentIntegrationProvider_DetachAnchor_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = XREnvironmentIntegrationProvider_DetachAnchor_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateXREnvironmentIntegrationProviderResponse(messageValidator) {
   var message = messageValidator.message;
   var paramsClass = null;
   switch (message.getName()) {
      case kXREnvironmentIntegrationProvider_SubscribeToHitTest_Name:
        if (message.isResponse())
          paramsClass = XREnvironmentIntegrationProvider_SubscribeToHitTest_ResponseParams;
        break;
      case kXREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_Name:
        if (message.isResponse())
          paramsClass = XREnvironmentIntegrationProvider_SubscribeToHitTestForTransientInput_ResponseParams;
        break;
      case kXREnvironmentIntegrationProvider_CreateAnchor_Name:
        if (message.isResponse())
          paramsClass = XREnvironmentIntegrationProvider_CreateAnchor_ResponseParams;
        break;
      case kXREnvironmentIntegrationProvider_CreatePlaneAnchor_Name:
        if (message.isResponse())
          paramsClass = XREnvironmentIntegrationProvider_CreatePlaneAnchor_ResponseParams;
        break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  var XREnvironmentIntegrationProvider = {
    name: 'device.mojom.XREnvironmentIntegrationProvider',
    kVersion: 0,
    ptrClass: XREnvironmentIntegrationProviderPtr,
    proxyClass: XREnvironmentIntegrationProviderProxy,
    stubClass: XREnvironmentIntegrationProviderStub,
    validateRequest: validateXREnvironmentIntegrationProviderRequest,
    validateResponse: validateXREnvironmentIntegrationProviderResponse,
  };
  XREnvironmentIntegrationProviderStub.prototype.validator = validateXREnvironmentIntegrationProviderRequest;
  XREnvironmentIntegrationProviderProxy.prototype.validator = validateXREnvironmentIntegrationProviderResponse;
  var kXRFrameDataProvider_GetFrameData_Name = 854430811;
  var kXRFrameDataProvider_GetEnvironmentIntegrationProvider_Name = 1178968080;

  function XRFrameDataProviderPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(XRFrameDataProvider,
                                                   handleOrPtrInfo);
  }

  function XRFrameDataProviderAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        XRFrameDataProvider, associatedInterfacePtrInfo);
  }

  XRFrameDataProviderAssociatedPtr.prototype =
      Object.create(XRFrameDataProviderPtr.prototype);
  XRFrameDataProviderAssociatedPtr.prototype.constructor =
      XRFrameDataProviderAssociatedPtr;

  function XRFrameDataProviderProxy(receiver) {
    this.receiver_ = receiver;
  }
  XRFrameDataProviderPtr.prototype.getFrameData = function() {
    return XRFrameDataProviderProxy.prototype.getFrameData
        .apply(this.ptr.getProxy(), arguments);
  };

  XRFrameDataProviderProxy.prototype.getFrameData = function(options) {
    var params_ = new XRFrameDataProvider_GetFrameData_Params();
    params_.options = options;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kXRFrameDataProvider_GetFrameData_Name,
          codec.align(XRFrameDataProvider_GetFrameData_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(XRFrameDataProvider_GetFrameData_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(XRFrameDataProvider_GetFrameData_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  XRFrameDataProviderPtr.prototype.getEnvironmentIntegrationProvider = function() {
    return XRFrameDataProviderProxy.prototype.getEnvironmentIntegrationProvider
        .apply(this.ptr.getProxy(), arguments);
  };

  XRFrameDataProviderProxy.prototype.getEnvironmentIntegrationProvider = function(environmentProvider) {
    var params_ = new XRFrameDataProvider_GetEnvironmentIntegrationProvider_Params();
    params_.environmentProvider = environmentProvider;
    var builder = new codec.MessageV2Builder(
        kXRFrameDataProvider_GetEnvironmentIntegrationProvider_Name,
        codec.align(XRFrameDataProvider_GetEnvironmentIntegrationProvider_Params.encodedSize));
    builder.setPayload(XRFrameDataProvider_GetEnvironmentIntegrationProvider_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };

  function XRFrameDataProviderStub(delegate) {
    this.delegate_ = delegate;
  }
  XRFrameDataProviderStub.prototype.getFrameData = function(options) {
    return this.delegate_ && this.delegate_.getFrameData && this.delegate_.getFrameData(options);
  }
  XRFrameDataProviderStub.prototype.getEnvironmentIntegrationProvider = function(environmentProvider) {
    return this.delegate_ && this.delegate_.getEnvironmentIntegrationProvider && this.delegate_.getEnvironmentIntegrationProvider(environmentProvider);
  }

  XRFrameDataProviderStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kXRFrameDataProvider_GetEnvironmentIntegrationProvider_Name:
      var params = reader.decodeStruct(XRFrameDataProvider_GetEnvironmentIntegrationProvider_Params);
      this.getEnvironmentIntegrationProvider(params.environmentProvider);
      return true;
    default:
      return false;
    }
  };

  XRFrameDataProviderStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kXRFrameDataProvider_GetFrameData_Name:
      var params = reader.decodeStruct(XRFrameDataProvider_GetFrameData_Params);
      this.getFrameData(params.options).then(function(response) {
        var responseParams =
            new XRFrameDataProvider_GetFrameData_ResponseParams();
        responseParams.frameData = response.frameData;
        var builder = new codec.MessageV1Builder(
            kXRFrameDataProvider_GetFrameData_Name,
            codec.align(XRFrameDataProvider_GetFrameData_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(XRFrameDataProvider_GetFrameData_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    default:
      return false;
    }
  };

  function validateXRFrameDataProviderRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kXRFrameDataProvider_GetFrameData_Name:
        if (message.expectsResponse())
          paramsClass = XRFrameDataProvider_GetFrameData_Params;
      break;
      case kXRFrameDataProvider_GetEnvironmentIntegrationProvider_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = XRFrameDataProvider_GetEnvironmentIntegrationProvider_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateXRFrameDataProviderResponse(messageValidator) {
   var message = messageValidator.message;
   var paramsClass = null;
   switch (message.getName()) {
      case kXRFrameDataProvider_GetFrameData_Name:
        if (message.isResponse())
          paramsClass = XRFrameDataProvider_GetFrameData_ResponseParams;
        break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  var XRFrameDataProvider = {
    name: 'device.mojom.XRFrameDataProvider',
    kVersion: 0,
    ptrClass: XRFrameDataProviderPtr,
    proxyClass: XRFrameDataProviderProxy,
    stubClass: XRFrameDataProviderStub,
    validateRequest: validateXRFrameDataProviderRequest,
    validateResponse: validateXRFrameDataProviderResponse,
  };
  XRFrameDataProviderStub.prototype.validator = validateXRFrameDataProviderRequest;
  XRFrameDataProviderProxy.prototype.validator = validateXRFrameDataProviderResponse;
  var kXRPresentationProvider_UpdateLayerBounds_Name = 1160838587;
  var kXRPresentationProvider_SubmitFrameMissing_Name = 716907393;
  var kXRPresentationProvider_SubmitFrame_Name = 916688949;
  var kXRPresentationProvider_SubmitFrameDrawnIntoTexture_Name = 1093425494;

  function XRPresentationProviderPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(XRPresentationProvider,
                                                   handleOrPtrInfo);
  }

  function XRPresentationProviderAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        XRPresentationProvider, associatedInterfacePtrInfo);
  }

  XRPresentationProviderAssociatedPtr.prototype =
      Object.create(XRPresentationProviderPtr.prototype);
  XRPresentationProviderAssociatedPtr.prototype.constructor =
      XRPresentationProviderAssociatedPtr;

  function XRPresentationProviderProxy(receiver) {
    this.receiver_ = receiver;
  }
  XRPresentationProviderPtr.prototype.updateLayerBounds = function() {
    return XRPresentationProviderProxy.prototype.updateLayerBounds
        .apply(this.ptr.getProxy(), arguments);
  };

  XRPresentationProviderProxy.prototype.updateLayerBounds = function(frameId, leftBounds, rightBounds, sourceSize) {
    var params_ = new XRPresentationProvider_UpdateLayerBounds_Params();
    params_.frameId = frameId;
    params_.leftBounds = leftBounds;
    params_.rightBounds = rightBounds;
    params_.sourceSize = sourceSize;
    var builder = new codec.MessageV0Builder(
        kXRPresentationProvider_UpdateLayerBounds_Name,
        codec.align(XRPresentationProvider_UpdateLayerBounds_Params.encodedSize));
    builder.encodeStruct(XRPresentationProvider_UpdateLayerBounds_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  XRPresentationProviderPtr.prototype.submitFrameMissing = function() {
    return XRPresentationProviderProxy.prototype.submitFrameMissing
        .apply(this.ptr.getProxy(), arguments);
  };

  XRPresentationProviderProxy.prototype.submitFrameMissing = function(frameId, syncToken) {
    var params_ = new XRPresentationProvider_SubmitFrameMissing_Params();
    params_.frameId = frameId;
    params_.syncToken = syncToken;
    var builder = new codec.MessageV0Builder(
        kXRPresentationProvider_SubmitFrameMissing_Name,
        codec.align(XRPresentationProvider_SubmitFrameMissing_Params.encodedSize));
    builder.encodeStruct(XRPresentationProvider_SubmitFrameMissing_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  XRPresentationProviderPtr.prototype.submitFrame = function() {
    return XRPresentationProviderProxy.prototype.submitFrame
        .apply(this.ptr.getProxy(), arguments);
  };

  XRPresentationProviderProxy.prototype.submitFrame = function(frameId, mailboxHolder, timeWaited) {
    var params_ = new XRPresentationProvider_SubmitFrame_Params();
    params_.frameId = frameId;
    params_.mailboxHolder = mailboxHolder;
    params_.timeWaited = timeWaited;
    var builder = new codec.MessageV0Builder(
        kXRPresentationProvider_SubmitFrame_Name,
        codec.align(XRPresentationProvider_SubmitFrame_Params.encodedSize));
    builder.encodeStruct(XRPresentationProvider_SubmitFrame_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  XRPresentationProviderPtr.prototype.submitFrameDrawnIntoTexture = function() {
    return XRPresentationProviderProxy.prototype.submitFrameDrawnIntoTexture
        .apply(this.ptr.getProxy(), arguments);
  };

  XRPresentationProviderProxy.prototype.submitFrameDrawnIntoTexture = function(frameId, syncToken, timeWaited) {
    var params_ = new XRPresentationProvider_SubmitFrameDrawnIntoTexture_Params();
    params_.frameId = frameId;
    params_.syncToken = syncToken;
    params_.timeWaited = timeWaited;
    var builder = new codec.MessageV0Builder(
        kXRPresentationProvider_SubmitFrameDrawnIntoTexture_Name,
        codec.align(XRPresentationProvider_SubmitFrameDrawnIntoTexture_Params.encodedSize));
    builder.encodeStruct(XRPresentationProvider_SubmitFrameDrawnIntoTexture_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };

  function XRPresentationProviderStub(delegate) {
    this.delegate_ = delegate;
  }
  XRPresentationProviderStub.prototype.updateLayerBounds = function(frameId, leftBounds, rightBounds, sourceSize) {
    return this.delegate_ && this.delegate_.updateLayerBounds && this.delegate_.updateLayerBounds(frameId, leftBounds, rightBounds, sourceSize);
  }
  XRPresentationProviderStub.prototype.submitFrameMissing = function(frameId, syncToken) {
    return this.delegate_ && this.delegate_.submitFrameMissing && this.delegate_.submitFrameMissing(frameId, syncToken);
  }
  XRPresentationProviderStub.prototype.submitFrame = function(frameId, mailboxHolder, timeWaited) {
    return this.delegate_ && this.delegate_.submitFrame && this.delegate_.submitFrame(frameId, mailboxHolder, timeWaited);
  }
  XRPresentationProviderStub.prototype.submitFrameDrawnIntoTexture = function(frameId, syncToken, timeWaited) {
    return this.delegate_ && this.delegate_.submitFrameDrawnIntoTexture && this.delegate_.submitFrameDrawnIntoTexture(frameId, syncToken, timeWaited);
  }

  XRPresentationProviderStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kXRPresentationProvider_UpdateLayerBounds_Name:
      var params = reader.decodeStruct(XRPresentationProvider_UpdateLayerBounds_Params);
      this.updateLayerBounds(params.frameId, params.leftBounds, params.rightBounds, params.sourceSize);
      return true;
    case kXRPresentationProvider_SubmitFrameMissing_Name:
      var params = reader.decodeStruct(XRPresentationProvider_SubmitFrameMissing_Params);
      this.submitFrameMissing(params.frameId, params.syncToken);
      return true;
    case kXRPresentationProvider_SubmitFrame_Name:
      var params = reader.decodeStruct(XRPresentationProvider_SubmitFrame_Params);
      this.submitFrame(params.frameId, params.mailboxHolder, params.timeWaited);
      return true;
    case kXRPresentationProvider_SubmitFrameDrawnIntoTexture_Name:
      var params = reader.decodeStruct(XRPresentationProvider_SubmitFrameDrawnIntoTexture_Params);
      this.submitFrameDrawnIntoTexture(params.frameId, params.syncToken, params.timeWaited);
      return true;
    default:
      return false;
    }
  };

  XRPresentationProviderStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  function validateXRPresentationProviderRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kXRPresentationProvider_UpdateLayerBounds_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = XRPresentationProvider_UpdateLayerBounds_Params;
      break;
      case kXRPresentationProvider_SubmitFrameMissing_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = XRPresentationProvider_SubmitFrameMissing_Params;
      break;
      case kXRPresentationProvider_SubmitFrame_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = XRPresentationProvider_SubmitFrame_Params;
      break;
      case kXRPresentationProvider_SubmitFrameDrawnIntoTexture_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = XRPresentationProvider_SubmitFrameDrawnIntoTexture_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateXRPresentationProviderResponse(messageValidator) {
    return validator.validationError.NONE;
  }

  var XRPresentationProvider = {
    name: 'device.mojom.XRPresentationProvider',
    kVersion: 0,
    ptrClass: XRPresentationProviderPtr,
    proxyClass: XRPresentationProviderProxy,
    stubClass: XRPresentationProviderStub,
    validateRequest: validateXRPresentationProviderRequest,
    validateResponse: null,
  };
  XRPresentationProviderStub.prototype.validator = validateXRPresentationProviderRequest;
  XRPresentationProviderProxy.prototype.validator = null;
  var kXRPresentationClient_OnSubmitFrameTransferred_Name = 1595631423;
  var kXRPresentationClient_OnSubmitFrameRendered_Name = 1774623586;
  var kXRPresentationClient_OnSubmitFrameGpuFence_Name = 1288003793;

  function XRPresentationClientPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(XRPresentationClient,
                                                   handleOrPtrInfo);
  }

  function XRPresentationClientAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        XRPresentationClient, associatedInterfacePtrInfo);
  }

  XRPresentationClientAssociatedPtr.prototype =
      Object.create(XRPresentationClientPtr.prototype);
  XRPresentationClientAssociatedPtr.prototype.constructor =
      XRPresentationClientAssociatedPtr;

  function XRPresentationClientProxy(receiver) {
    this.receiver_ = receiver;
  }
  XRPresentationClientPtr.prototype.onSubmitFrameTransferred = function() {
    return XRPresentationClientProxy.prototype.onSubmitFrameTransferred
        .apply(this.ptr.getProxy(), arguments);
  };

  XRPresentationClientProxy.prototype.onSubmitFrameTransferred = function(success) {
    var params_ = new XRPresentationClient_OnSubmitFrameTransferred_Params();
    params_.success = success;
    var builder = new codec.MessageV0Builder(
        kXRPresentationClient_OnSubmitFrameTransferred_Name,
        codec.align(XRPresentationClient_OnSubmitFrameTransferred_Params.encodedSize));
    builder.encodeStruct(XRPresentationClient_OnSubmitFrameTransferred_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  XRPresentationClientPtr.prototype.onSubmitFrameRendered = function() {
    return XRPresentationClientProxy.prototype.onSubmitFrameRendered
        .apply(this.ptr.getProxy(), arguments);
  };

  XRPresentationClientProxy.prototype.onSubmitFrameRendered = function() {
    var params_ = new XRPresentationClient_OnSubmitFrameRendered_Params();
    var builder = new codec.MessageV0Builder(
        kXRPresentationClient_OnSubmitFrameRendered_Name,
        codec.align(XRPresentationClient_OnSubmitFrameRendered_Params.encodedSize));
    builder.encodeStruct(XRPresentationClient_OnSubmitFrameRendered_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  XRPresentationClientPtr.prototype.onSubmitFrameGpuFence = function() {
    return XRPresentationClientProxy.prototype.onSubmitFrameGpuFence
        .apply(this.ptr.getProxy(), arguments);
  };

  XRPresentationClientProxy.prototype.onSubmitFrameGpuFence = function(gpuFenceHandle) {
    var params_ = new XRPresentationClient_OnSubmitFrameGpuFence_Params();
    params_.gpuFenceHandle = gpuFenceHandle;
    var builder = new codec.MessageV0Builder(
        kXRPresentationClient_OnSubmitFrameGpuFence_Name,
        codec.align(XRPresentationClient_OnSubmitFrameGpuFence_Params.encodedSize));
    builder.encodeStruct(XRPresentationClient_OnSubmitFrameGpuFence_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };

  function XRPresentationClientStub(delegate) {
    this.delegate_ = delegate;
  }
  XRPresentationClientStub.prototype.onSubmitFrameTransferred = function(success) {
    return this.delegate_ && this.delegate_.onSubmitFrameTransferred && this.delegate_.onSubmitFrameTransferred(success);
  }
  XRPresentationClientStub.prototype.onSubmitFrameRendered = function() {
    return this.delegate_ && this.delegate_.onSubmitFrameRendered && this.delegate_.onSubmitFrameRendered();
  }
  XRPresentationClientStub.prototype.onSubmitFrameGpuFence = function(gpuFenceHandle) {
    return this.delegate_ && this.delegate_.onSubmitFrameGpuFence && this.delegate_.onSubmitFrameGpuFence(gpuFenceHandle);
  }

  XRPresentationClientStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kXRPresentationClient_OnSubmitFrameTransferred_Name:
      var params = reader.decodeStruct(XRPresentationClient_OnSubmitFrameTransferred_Params);
      this.onSubmitFrameTransferred(params.success);
      return true;
    case kXRPresentationClient_OnSubmitFrameRendered_Name:
      var params = reader.decodeStruct(XRPresentationClient_OnSubmitFrameRendered_Params);
      this.onSubmitFrameRendered();
      return true;
    case kXRPresentationClient_OnSubmitFrameGpuFence_Name:
      var params = reader.decodeStruct(XRPresentationClient_OnSubmitFrameGpuFence_Params);
      this.onSubmitFrameGpuFence(params.gpuFenceHandle);
      return true;
    default:
      return false;
    }
  };

  XRPresentationClientStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  function validateXRPresentationClientRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kXRPresentationClient_OnSubmitFrameTransferred_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = XRPresentationClient_OnSubmitFrameTransferred_Params;
      break;
      case kXRPresentationClient_OnSubmitFrameRendered_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = XRPresentationClient_OnSubmitFrameRendered_Params;
      break;
      case kXRPresentationClient_OnSubmitFrameGpuFence_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = XRPresentationClient_OnSubmitFrameGpuFence_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateXRPresentationClientResponse(messageValidator) {
    return validator.validationError.NONE;
  }

  var XRPresentationClient = {
    name: 'device.mojom.XRPresentationClient',
    kVersion: 0,
    ptrClass: XRPresentationClientPtr,
    proxyClass: XRPresentationClientProxy,
    stubClass: XRPresentationClientStub,
    validateRequest: validateXRPresentationClientRequest,
    validateResponse: null,
  };
  XRPresentationClientStub.prototype.validator = validateXRPresentationClientRequest;
  XRPresentationClientProxy.prototype.validator = null;
  var kXRSessionClient_OnExitPresent_Name = 1087568828;
  var kXRSessionClient_OnVisibilityStateChanged_Name = 306203277;

  function XRSessionClientPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(XRSessionClient,
                                                   handleOrPtrInfo);
  }

  function XRSessionClientAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        XRSessionClient, associatedInterfacePtrInfo);
  }

  XRSessionClientAssociatedPtr.prototype =
      Object.create(XRSessionClientPtr.prototype);
  XRSessionClientAssociatedPtr.prototype.constructor =
      XRSessionClientAssociatedPtr;

  function XRSessionClientProxy(receiver) {
    this.receiver_ = receiver;
  }
  XRSessionClientPtr.prototype.onExitPresent = function() {
    return XRSessionClientProxy.prototype.onExitPresent
        .apply(this.ptr.getProxy(), arguments);
  };

  XRSessionClientProxy.prototype.onExitPresent = function() {
    var params_ = new XRSessionClient_OnExitPresent_Params();
    var builder = new codec.MessageV0Builder(
        kXRSessionClient_OnExitPresent_Name,
        codec.align(XRSessionClient_OnExitPresent_Params.encodedSize));
    builder.encodeStruct(XRSessionClient_OnExitPresent_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  XRSessionClientPtr.prototype.onVisibilityStateChanged = function() {
    return XRSessionClientProxy.prototype.onVisibilityStateChanged
        .apply(this.ptr.getProxy(), arguments);
  };

  XRSessionClientProxy.prototype.onVisibilityStateChanged = function(visibilityState) {
    var params_ = new XRSessionClient_OnVisibilityStateChanged_Params();
    params_.visibilityState = visibilityState;
    var builder = new codec.MessageV0Builder(
        kXRSessionClient_OnVisibilityStateChanged_Name,
        codec.align(XRSessionClient_OnVisibilityStateChanged_Params.encodedSize));
    builder.encodeStruct(XRSessionClient_OnVisibilityStateChanged_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };

  function XRSessionClientStub(delegate) {
    this.delegate_ = delegate;
  }
  XRSessionClientStub.prototype.onExitPresent = function() {
    return this.delegate_ && this.delegate_.onExitPresent && this.delegate_.onExitPresent();
  }
  XRSessionClientStub.prototype.onVisibilityStateChanged = function(visibilityState) {
    return this.delegate_ && this.delegate_.onVisibilityStateChanged && this.delegate_.onVisibilityStateChanged(visibilityState);
  }

  XRSessionClientStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kXRSessionClient_OnExitPresent_Name:
      var params = reader.decodeStruct(XRSessionClient_OnExitPresent_Params);
      this.onExitPresent();
      return true;
    case kXRSessionClient_OnVisibilityStateChanged_Name:
      var params = reader.decodeStruct(XRSessionClient_OnVisibilityStateChanged_Params);
      this.onVisibilityStateChanged(params.visibilityState);
      return true;
    default:
      return false;
    }
  };

  XRSessionClientStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  function validateXRSessionClientRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kXRSessionClient_OnExitPresent_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = XRSessionClient_OnExitPresent_Params;
      break;
      case kXRSessionClient_OnVisibilityStateChanged_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = XRSessionClient_OnVisibilityStateChanged_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateXRSessionClientResponse(messageValidator) {
    return validator.validationError.NONE;
  }

  var XRSessionClient = {
    name: 'device.mojom.XRSessionClient',
    kVersion: 0,
    ptrClass: XRSessionClientPtr,
    proxyClass: XRSessionClientProxy,
    stubClass: XRSessionClientStub,
    validateRequest: validateXRSessionClientRequest,
    validateResponse: null,
  };
  XRSessionClientStub.prototype.validator = validateXRSessionClientRequest;
  XRSessionClientProxy.prototype.validator = null;
  exports.XRHandedness = XRHandedness;
  exports.XRTargetRayMode = XRTargetRayMode;
  exports.XRSessionFeatureRequestStatus = XRSessionFeatureRequestStatus;
  exports.XREnvironmentBlendMode = XREnvironmentBlendMode;
  exports.XRInteractionMode = XRInteractionMode;
  exports.XRHandJoint = XRHandJoint;
  exports.XREye = XREye;
  exports.XRPresentationTransportMethod = XRPresentationTransportMethod;
  exports.XRReferenceSpaceType = XRReferenceSpaceType;
  exports.XRInputSourceSpaceType = XRInputSourceSpaceType;
  exports.XRPlaneOrientation = XRPlaneOrientation;
  exports.XrCompatibleResult = XrCompatibleResult;
  exports.CreateAnchorResult = CreateAnchorResult;
  exports.SubscribeToHitTestResult = SubscribeToHitTestResult;
  exports.EntityTypeForHitTest = EntityTypeForHitTest;
  exports.XRVisibilityState = XRVisibilityState;
  exports.XRDepthConfig = XRDepthConfig;
  exports.XRSessionDeviceConfig = XRSessionDeviceConfig;
  exports.XRSession = XRSession;
  exports.XRPresentationConnection = XRPresentationConnection;
  exports.XRInputSourceDescription = XRInputSourceDescription;
  exports.XRHandJointData = XRHandJointData;
  exports.XRHandTrackingData = XRHandTrackingData;
  exports.XRInputSourceState = XRInputSourceState;
  exports.VRFieldOfView = VRFieldOfView;
  exports.VRPose = VRPose;
  exports.Pose = Pose;
  exports.XRRay = XRRay;
  exports.XRHitResult = XRHitResult;
  exports.XRView = XRView;
  exports.VRStageParameters = VRStageParameters;
  exports.XRPresentationTransportOptions = XRPresentationTransportOptions;
  exports.XRInputSourceSpaceInfo = XRInputSourceSpaceInfo;
  exports.XRHandJointSpaceInfo = XRHandJointSpaceInfo;
  exports.XRPlanePointData = XRPlanePointData;
  exports.XRPlaneData = XRPlaneData;
  exports.XRPlaneDetectionData = XRPlaneDetectionData;
  exports.XRAnchorData = XRAnchorData;
  exports.XRAnchorsData = XRAnchorsData;
  exports.XRHitTestSubscriptionResultData = XRHitTestSubscriptionResultData;
  exports.XRHitTestTransientInputSubscriptionResultData = XRHitTestTransientInputSubscriptionResultData;
  exports.XRHitTestSubscriptionResultsData = XRHitTestSubscriptionResultsData;
  exports.RgbTupleF32 = RgbTupleF32;
  exports.XRSphericalHarmonics = XRSphericalHarmonics;
  exports.RgbaTupleF16 = RgbaTupleF16;
  exports.XRCubeMap = XRCubeMap;
  exports.XRLightProbe = XRLightProbe;
  exports.XRReflectionProbe = XRReflectionProbe;
  exports.XRLightEstimationData = XRLightEstimationData;
  exports.XRDepthDataStillValid = XRDepthDataStillValid;
  exports.XRDepthDataUpdated = XRDepthDataUpdated;
  exports.XRTrackedImageData = XRTrackedImageData;
  exports.XRTrackedImagesData = XRTrackedImagesData;
  exports.XRFrameData = XRFrameData;
  exports.RequestSessionSuccess = RequestSessionSuccess;
  exports.XRFrameDataRequestOptions = XRFrameDataRequestOptions;
  exports.XRNativeOriginInformation = XRNativeOriginInformation;
  exports.XRDepthData = XRDepthData;
  exports.RequestSessionResult = RequestSessionResult;
  exports.VRService = VRService;
  exports.VRServicePtr = VRServicePtr;
  exports.VRServiceAssociatedPtr = VRServiceAssociatedPtr;
  exports.XRSessionMetricsRecorder = XRSessionMetricsRecorder;
  exports.XRSessionMetricsRecorderPtr = XRSessionMetricsRecorderPtr;
  exports.XRSessionMetricsRecorderAssociatedPtr = XRSessionMetricsRecorderAssociatedPtr;
  exports.VRServiceClient = VRServiceClient;
  exports.VRServiceClientPtr = VRServiceClientPtr;
  exports.VRServiceClientAssociatedPtr = VRServiceClientAssociatedPtr;
  exports.XREnvironmentIntegrationProvider = XREnvironmentIntegrationProvider;
  exports.XREnvironmentIntegrationProviderPtr = XREnvironmentIntegrationProviderPtr;
  exports.XREnvironmentIntegrationProviderAssociatedPtr = XREnvironmentIntegrationProviderAssociatedPtr;
  exports.XRFrameDataProvider = XRFrameDataProvider;
  exports.XRFrameDataProviderPtr = XRFrameDataProviderPtr;
  exports.XRFrameDataProviderAssociatedPtr = XRFrameDataProviderAssociatedPtr;
  exports.XRPresentationProvider = XRPresentationProvider;
  exports.XRPresentationProviderPtr = XRPresentationProviderPtr;
  exports.XRPresentationProviderAssociatedPtr = XRPresentationProviderAssociatedPtr;
  exports.XRPresentationClient = XRPresentationClient;
  exports.XRPresentationClientPtr = XRPresentationClientPtr;
  exports.XRPresentationClientAssociatedPtr = XRPresentationClientAssociatedPtr;
  exports.XRSessionClient = XRSessionClient;
  exports.XRSessionClientPtr = XRSessionClientPtr;
  exports.XRSessionClientAssociatedPtr = XRSessionClientAssociatedPtr;
})();