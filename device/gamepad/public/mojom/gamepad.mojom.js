// device/gamepad/public/mojom/gamepad.mojom.js is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2014 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

(function() {
  var mojomId = 'device/gamepad/public/mojom/gamepad.mojom';
  if (mojo.internal.isMojomLoaded(mojomId)) {
    console.warn('The following mojom is loaded multiple times: ' + mojomId);
    return;
  }
  mojo.internal.markMojomLoaded(mojomId);
  var bindings = mojo;
  var associatedBindings = mojo;
  var codec = mojo.internal;
  var validator = mojo.internal;

  var exports = mojo.internal.exposeNamespace('device.mojom');
  var shared_memory$ =
      mojo.internal.exposeNamespace('mojoBase.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'mojo/public/mojom/base/shared_memory.mojom', '../../../../mojo/public/mojom/base/shared_memory.mojom.js');
  }


  var GamepadMapping = {};
  GamepadMapping.GamepadMappingNone = 0;
  GamepadMapping.GamepadMappingStandard = 1;
  GamepadMapping.GamepadMappingXRStandard = 2;
  GamepadMapping.MIN_VALUE = 0;
  GamepadMapping.MAX_VALUE = 2;

  GamepadMapping.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    }
    return false;
  };

  GamepadMapping.toKnownEnumValue = function(value) {
    return value;
  };

  GamepadMapping.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var GamepadHand = {};
  GamepadHand.GamepadHandNone = 0;
  GamepadHand.GamepadHandLeft = 1;
  GamepadHand.GamepadHandRight = 2;
  GamepadHand.MIN_VALUE = 0;
  GamepadHand.MAX_VALUE = 2;

  GamepadHand.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    }
    return false;
  };

  GamepadHand.toKnownEnumValue = function(value) {
    return value;
  };

  GamepadHand.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var GamepadHapticActuatorType = {};
  GamepadHapticActuatorType.GamepadHapticActuatorTypeVibration = 0;
  GamepadHapticActuatorType.GamepadHapticActuatorTypeDualRumble = 1;
  GamepadHapticActuatorType.GamepadHapticActuatorTypeTriggerRumble = 2;
  GamepadHapticActuatorType.MIN_VALUE = 0;
  GamepadHapticActuatorType.MAX_VALUE = 2;

  GamepadHapticActuatorType.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    }
    return false;
  };

  GamepadHapticActuatorType.toKnownEnumValue = function(value) {
    return value;
  };

  GamepadHapticActuatorType.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var GamepadHapticEffectType = {};
  GamepadHapticEffectType.GamepadHapticEffectTypeDualRumble = 0;
  GamepadHapticEffectType.GamepadHapticEffectTypeTriggerRumble = 1;
  GamepadHapticEffectType.MIN_VALUE = 0;
  GamepadHapticEffectType.MAX_VALUE = 1;

  GamepadHapticEffectType.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
      return true;
    }
    return false;
  };

  GamepadHapticEffectType.toKnownEnumValue = function(value) {
    return value;
  };

  GamepadHapticEffectType.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var GamepadHapticsResult = {};
  GamepadHapticsResult.GamepadHapticsResultError = 0;
  GamepadHapticsResult.GamepadHapticsResultComplete = 1;
  GamepadHapticsResult.GamepadHapticsResultPreempted = 2;
  GamepadHapticsResult.GamepadHapticsResultInvalidParameter = 3;
  GamepadHapticsResult.GamepadHapticsResultNotSupported = 4;
  GamepadHapticsResult.MIN_VALUE = 0;
  GamepadHapticsResult.MAX_VALUE = 4;

  GamepadHapticsResult.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    }
    return false;
  };

  GamepadHapticsResult.toKnownEnumValue = function(value) {
    return value;
  };

  GamepadHapticsResult.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };

  function GamepadQuaternion(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GamepadQuaternion.prototype.initDefaults_ = function() {
    this.x = 0;
    this.y = 0;
    this.z = 0;
    this.w = 0;
  };
  GamepadQuaternion.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GamepadQuaternion.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;





    return validator.validationError.NONE;
  };

  GamepadQuaternion.encodedSize = codec.kStructHeaderSize + 16;

  GamepadQuaternion.decode = function(decoder) {
    var packed;
    var val = new GamepadQuaternion();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.x =
        decoder.decodeStruct(codec.Float);
    val.y =
        decoder.decodeStruct(codec.Float);
    val.z =
        decoder.decodeStruct(codec.Float);
    val.w =
        decoder.decodeStruct(codec.Float);
    return val;
  };

  GamepadQuaternion.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GamepadQuaternion.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Float, val.x);
    encoder.encodeStruct(codec.Float, val.y);
    encoder.encodeStruct(codec.Float, val.z);
    encoder.encodeStruct(codec.Float, val.w);
  };
  function GamepadVector(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GamepadVector.prototype.initDefaults_ = function() {
    this.x = 0;
    this.y = 0;
    this.z = 0;
  };
  GamepadVector.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GamepadVector.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;




    return validator.validationError.NONE;
  };

  GamepadVector.encodedSize = codec.kStructHeaderSize + 16;

  GamepadVector.decode = function(decoder) {
    var packed;
    var val = new GamepadVector();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.x =
        decoder.decodeStruct(codec.Float);
    val.y =
        decoder.decodeStruct(codec.Float);
    val.z =
        decoder.decodeStruct(codec.Float);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  GamepadVector.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GamepadVector.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Float, val.x);
    encoder.encodeStruct(codec.Float, val.y);
    encoder.encodeStruct(codec.Float, val.z);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function GamepadButton(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GamepadButton.prototype.initDefaults_ = function() {
    this.pressed = false;
    this.touched = false;
    this.value = 0;
  };
  GamepadButton.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GamepadButton.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;




    return validator.validationError.NONE;
  };

  GamepadButton.encodedSize = codec.kStructHeaderSize + 16;

  GamepadButton.decode = function(decoder) {
    var packed;
    var val = new GamepadButton();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    packed = decoder.readUint8();
    val.pressed = (packed >> 0) & 1 ? true : false;
    val.touched = (packed >> 1) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.value =
        decoder.decodeStruct(codec.Double);
    return val;
  };

  GamepadButton.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GamepadButton.encodedSize);
    encoder.writeUint32(0);
    packed = 0;
    packed |= (val.pressed & 1) << 0
    packed |= (val.touched & 1) << 1
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.Double, val.value);
  };
  function ButtonChange(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ButtonChange.prototype.initDefaults_ = function() {
    this.buttonIndex = 0;
    this.buttonDown = false;
    this.buttonUp = false;
    this.valueChanged = false;
    this.buttonSnapshot = null;
  };
  ButtonChange.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ButtonChange.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;






    // validate ButtonChange.buttonSnapshot
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, GamepadButton, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ButtonChange.encodedSize = codec.kStructHeaderSize + 16;

  ButtonChange.decode = function(decoder) {
    var packed;
    var val = new ButtonChange();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.buttonIndex =
        decoder.decodeStruct(codec.Uint32);
    packed = decoder.readUint8();
    val.buttonDown = (packed >> 0) & 1 ? true : false;
    val.buttonUp = (packed >> 1) & 1 ? true : false;
    val.valueChanged = (packed >> 2) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.buttonSnapshot =
        decoder.decodeStructPointer(GamepadButton);
    return val;
  };

  ButtonChange.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ButtonChange.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint32, val.buttonIndex);
    packed = 0;
    packed |= (val.buttonDown & 1) << 0
    packed |= (val.buttonUp & 1) << 1
    packed |= (val.valueChanged & 1) << 2
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStructPointer(GamepadButton, val.buttonSnapshot);
  };
  function AxisChange(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  AxisChange.prototype.initDefaults_ = function() {
    this.axisIndex = 0;
    this.axisSnapshot = 0;
  };
  AxisChange.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  AxisChange.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    return validator.validationError.NONE;
  };

  AxisChange.encodedSize = codec.kStructHeaderSize + 16;

  AxisChange.decode = function(decoder) {
    var packed;
    var val = new AxisChange();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.axisIndex =
        decoder.decodeStruct(codec.Uint32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.axisSnapshot =
        decoder.decodeStruct(codec.Double);
    return val;
  };

  AxisChange.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(AxisChange.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint32, val.axisIndex);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.Double, val.axisSnapshot);
  };
  function GamepadChanges(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GamepadChanges.prototype.initDefaults_ = function() {
    this.gamepadIndex = 0;
    this.buttonChanges = null;
    this.axisChanges = null;
    this.timestamp = 0;
  };
  GamepadChanges.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GamepadChanges.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 40}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    // validate GamepadChanges.buttonChanges
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 8, 8, new codec.PointerTo(ButtonChange), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GamepadChanges.axisChanges
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 16, 8, new codec.PointerTo(AxisChange), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  GamepadChanges.encodedSize = codec.kStructHeaderSize + 32;

  GamepadChanges.decode = function(decoder) {
    var packed;
    var val = new GamepadChanges();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.gamepadIndex =
        decoder.decodeStruct(codec.Uint32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.buttonChanges =
        decoder.decodeArrayPointer(new codec.PointerTo(ButtonChange));
    val.axisChanges =
        decoder.decodeArrayPointer(new codec.PointerTo(AxisChange));
    val.timestamp =
        decoder.decodeStruct(codec.Int64);
    return val;
  };

  GamepadChanges.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GamepadChanges.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint32, val.gamepadIndex);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeArrayPointer(new codec.PointerTo(ButtonChange), val.buttonChanges);
    encoder.encodeArrayPointer(new codec.PointerTo(AxisChange), val.axisChanges);
    encoder.encodeStruct(codec.Int64, val.timestamp);
  };
  function GamepadTouch(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GamepadTouch.prototype.initDefaults_ = function() {
    this.touchId = 0;
    this.surfaceId = 0;
    this.hasSurfaceDimensions = false;
    this.x = 0;
    this.y = 0;
    this.surfaceHeight = 0;
    this.surfaceWidth = 0;
  };
  GamepadTouch.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GamepadTouch.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 40}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;








    return validator.validationError.NONE;
  };

  GamepadTouch.encodedSize = codec.kStructHeaderSize + 32;

  GamepadTouch.decode = function(decoder) {
    var packed;
    var val = new GamepadTouch();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.touchId =
        decoder.decodeStruct(codec.Uint32);
    val.surfaceId =
        decoder.decodeStruct(codec.Uint8);
    packed = decoder.readUint8();
    val.hasSurfaceDimensions = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    val.x =
        decoder.decodeStruct(codec.Double);
    val.y =
        decoder.decodeStruct(codec.Double);
    val.surfaceHeight =
        decoder.decodeStruct(codec.Uint32);
    val.surfaceWidth =
        decoder.decodeStruct(codec.Uint32);
    return val;
  };

  GamepadTouch.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GamepadTouch.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint32, val.touchId);
    encoder.encodeStruct(codec.Uint8, val.surfaceId);
    packed = 0;
    packed |= (val.hasSurfaceDimensions & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.Double, val.x);
    encoder.encodeStruct(codec.Double, val.y);
    encoder.encodeStruct(codec.Uint32, val.surfaceHeight);
    encoder.encodeStruct(codec.Uint32, val.surfaceWidth);
  };
  function GamepadPose(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GamepadPose.prototype.initDefaults_ = function() {
    this.orientation = null;
    this.position = null;
    this.angularVelocity = null;
    this.linearVelocity = null;
    this.angularAcceleration = null;
    this.linearAcceleration = null;
  };
  GamepadPose.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GamepadPose.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 56}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GamepadPose.orientation
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, GamepadQuaternion, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GamepadPose.position
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, GamepadVector, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GamepadPose.angularVelocity
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, GamepadVector, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GamepadPose.linearVelocity
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 24, GamepadVector, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GamepadPose.angularAcceleration
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 32, GamepadVector, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GamepadPose.linearAcceleration
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 40, GamepadVector, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GamepadPose.encodedSize = codec.kStructHeaderSize + 48;

  GamepadPose.decode = function(decoder) {
    var packed;
    var val = new GamepadPose();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.orientation =
        decoder.decodeStructPointer(GamepadQuaternion);
    val.position =
        decoder.decodeStructPointer(GamepadVector);
    val.angularVelocity =
        decoder.decodeStructPointer(GamepadVector);
    val.linearVelocity =
        decoder.decodeStructPointer(GamepadVector);
    val.angularAcceleration =
        decoder.decodeStructPointer(GamepadVector);
    val.linearAcceleration =
        decoder.decodeStructPointer(GamepadVector);
    return val;
  };

  GamepadPose.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GamepadPose.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(GamepadQuaternion, val.orientation);
    encoder.encodeStructPointer(GamepadVector, val.position);
    encoder.encodeStructPointer(GamepadVector, val.angularVelocity);
    encoder.encodeStructPointer(GamepadVector, val.linearVelocity);
    encoder.encodeStructPointer(GamepadVector, val.angularAcceleration);
    encoder.encodeStructPointer(GamepadVector, val.linearAcceleration);
  };
  function GamepadHapticActuator(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GamepadHapticActuator.prototype.initDefaults_ = function() {
    this.type = 0;
  };
  GamepadHapticActuator.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GamepadHapticActuator.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GamepadHapticActuator.type
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, GamepadHapticActuatorType);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GamepadHapticActuator.encodedSize = codec.kStructHeaderSize + 8;

  GamepadHapticActuator.decode = function(decoder) {
    var packed;
    var val = new GamepadHapticActuator();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.type =
        decoder.decodeStruct(new codec.Enum(GamepadHapticActuatorType));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  GamepadHapticActuator.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GamepadHapticActuator.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.type);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function Gamepad(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  Gamepad.prototype.initDefaults_ = function() {
    this.connected = false;
    this.mapping = 0;
    this.id = null;
    this.timestamp = 0;
    this.axes = null;
    this.buttons = null;
    this.vibrationActuator = null;
    this.pose = null;
    this.hand = 0;
    this.displayId = 0;
    this.touchEvents = null;
  };
  Gamepad.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  Gamepad.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 80}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    // validate Gamepad.id
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 8, 2, codec.Uint16, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;



    // validate Gamepad.axes
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 24, 8, codec.Double, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Gamepad.buttons
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 32, 8, new codec.PointerTo(GamepadButton), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Gamepad.vibrationActuator
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 40, GamepadHapticActuator, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Gamepad.mapping
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 4, GamepadMapping);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Gamepad.pose
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 48, GamepadPose, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Gamepad.hand
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 56, GamepadHand);
    if (err !== validator.validationError.NONE)
        return err;


    // validate Gamepad.touchEvents
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 64, 8, new codec.PointerTo(GamepadTouch), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  Gamepad.encodedSize = codec.kStructHeaderSize + 72;

  Gamepad.decode = function(decoder) {
    var packed;
    var val = new Gamepad();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    packed = decoder.readUint8();
    val.connected = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.mapping =
        decoder.decodeStruct(new codec.Enum(GamepadMapping));
    val.id =
        decoder.decodeArrayPointer(codec.Uint16);
    val.timestamp =
        decoder.decodeStruct(codec.Int64);
    val.axes =
        decoder.decodeArrayPointer(codec.Double);
    val.buttons =
        decoder.decodeArrayPointer(new codec.PointerTo(GamepadButton));
    val.vibrationActuator =
        decoder.decodeStructPointer(GamepadHapticActuator);
    val.pose =
        decoder.decodeStructPointer(GamepadPose);
    val.hand =
        decoder.decodeStruct(new codec.Enum(GamepadHand));
    val.displayId =
        decoder.decodeStruct(codec.Uint32);
    val.touchEvents =
        decoder.decodeArrayPointer(new codec.PointerTo(GamepadTouch));
    return val;
  };

  Gamepad.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(Gamepad.encodedSize);
    encoder.writeUint32(0);
    packed = 0;
    packed |= (val.connected & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.Int32, val.mapping);
    encoder.encodeArrayPointer(codec.Uint16, val.id);
    encoder.encodeStruct(codec.Int64, val.timestamp);
    encoder.encodeArrayPointer(codec.Double, val.axes);
    encoder.encodeArrayPointer(new codec.PointerTo(GamepadButton), val.buttons);
    encoder.encodeStructPointer(GamepadHapticActuator, val.vibrationActuator);
    encoder.encodeStructPointer(GamepadPose, val.pose);
    encoder.encodeStruct(codec.Int32, val.hand);
    encoder.encodeStruct(codec.Uint32, val.displayId);
    encoder.encodeArrayPointer(new codec.PointerTo(GamepadTouch), val.touchEvents);
  };
  function GamepadEffectParameters(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GamepadEffectParameters.prototype.initDefaults_ = function() {
    this.duration = 0;
    this.startDelay = 0;
    this.strongMagnitude = 0;
    this.weakMagnitude = 0;
    this.leftTrigger = 0;
    this.rightTrigger = 0;
  };
  GamepadEffectParameters.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GamepadEffectParameters.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 56}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;







    return validator.validationError.NONE;
  };

  GamepadEffectParameters.encodedSize = codec.kStructHeaderSize + 48;

  GamepadEffectParameters.decode = function(decoder) {
    var packed;
    var val = new GamepadEffectParameters();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.duration =
        decoder.decodeStruct(codec.Double);
    val.startDelay =
        decoder.decodeStruct(codec.Double);
    val.strongMagnitude =
        decoder.decodeStruct(codec.Double);
    val.weakMagnitude =
        decoder.decodeStruct(codec.Double);
    val.leftTrigger =
        decoder.decodeStruct(codec.Double);
    val.rightTrigger =
        decoder.decodeStruct(codec.Double);
    return val;
  };

  GamepadEffectParameters.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GamepadEffectParameters.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Double, val.duration);
    encoder.encodeStruct(codec.Double, val.startDelay);
    encoder.encodeStruct(codec.Double, val.strongMagnitude);
    encoder.encodeStruct(codec.Double, val.weakMagnitude);
    encoder.encodeStruct(codec.Double, val.leftTrigger);
    encoder.encodeStruct(codec.Double, val.rightTrigger);
  };
  function GamepadObserver_GamepadConnected_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GamepadObserver_GamepadConnected_Params.prototype.initDefaults_ = function() {
    this.index = 0;
    this.gamepad = null;
  };
  GamepadObserver_GamepadConnected_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GamepadObserver_GamepadConnected_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    // validate GamepadObserver_GamepadConnected_Params.gamepad
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, Gamepad, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GamepadObserver_GamepadConnected_Params.encodedSize = codec.kStructHeaderSize + 16;

  GamepadObserver_GamepadConnected_Params.decode = function(decoder) {
    var packed;
    var val = new GamepadObserver_GamepadConnected_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.index =
        decoder.decodeStruct(codec.Uint32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.gamepad =
        decoder.decodeStructPointer(Gamepad);
    return val;
  };

  GamepadObserver_GamepadConnected_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GamepadObserver_GamepadConnected_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint32, val.index);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStructPointer(Gamepad, val.gamepad);
  };
  function GamepadObserver_GamepadDisconnected_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GamepadObserver_GamepadDisconnected_Params.prototype.initDefaults_ = function() {
    this.index = 0;
    this.gamepad = null;
  };
  GamepadObserver_GamepadDisconnected_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GamepadObserver_GamepadDisconnected_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    // validate GamepadObserver_GamepadDisconnected_Params.gamepad
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, Gamepad, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GamepadObserver_GamepadDisconnected_Params.encodedSize = codec.kStructHeaderSize + 16;

  GamepadObserver_GamepadDisconnected_Params.decode = function(decoder) {
    var packed;
    var val = new GamepadObserver_GamepadDisconnected_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.index =
        decoder.decodeStruct(codec.Uint32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.gamepad =
        decoder.decodeStructPointer(Gamepad);
    return val;
  };

  GamepadObserver_GamepadDisconnected_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GamepadObserver_GamepadDisconnected_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint32, val.index);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStructPointer(Gamepad, val.gamepad);
  };
  function GamepadObserver_GamepadChanged_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GamepadObserver_GamepadChanged_Params.prototype.initDefaults_ = function() {
    this.changes = null;
  };
  GamepadObserver_GamepadChanged_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GamepadObserver_GamepadChanged_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GamepadObserver_GamepadChanged_Params.changes
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, GamepadChanges, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GamepadObserver_GamepadChanged_Params.encodedSize = codec.kStructHeaderSize + 8;

  GamepadObserver_GamepadChanged_Params.decode = function(decoder) {
    var packed;
    var val = new GamepadObserver_GamepadChanged_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.changes =
        decoder.decodeStructPointer(GamepadChanges);
    return val;
  };

  GamepadObserver_GamepadChanged_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GamepadObserver_GamepadChanged_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(GamepadChanges, val.changes);
  };
  function GamepadMonitor_GamepadStartPolling_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GamepadMonitor_GamepadStartPolling_Params.prototype.initDefaults_ = function() {
  };
  GamepadMonitor_GamepadStartPolling_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GamepadMonitor_GamepadStartPolling_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GamepadMonitor_GamepadStartPolling_Params.encodedSize = codec.kStructHeaderSize + 0;

  GamepadMonitor_GamepadStartPolling_Params.decode = function(decoder) {
    var packed;
    var val = new GamepadMonitor_GamepadStartPolling_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  GamepadMonitor_GamepadStartPolling_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GamepadMonitor_GamepadStartPolling_Params.encodedSize);
    encoder.writeUint32(0);
  };
  function GamepadMonitor_GamepadStartPolling_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GamepadMonitor_GamepadStartPolling_ResponseParams.prototype.initDefaults_ = function() {
    this.memoryRegion = null;
  };
  GamepadMonitor_GamepadStartPolling_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GamepadMonitor_GamepadStartPolling_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GamepadMonitor_GamepadStartPolling_ResponseParams.memoryRegion
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, shared_memory$.ReadOnlySharedMemoryRegion, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GamepadMonitor_GamepadStartPolling_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  GamepadMonitor_GamepadStartPolling_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new GamepadMonitor_GamepadStartPolling_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.memoryRegion =
        decoder.decodeStructPointer(shared_memory$.ReadOnlySharedMemoryRegion);
    return val;
  };

  GamepadMonitor_GamepadStartPolling_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GamepadMonitor_GamepadStartPolling_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(shared_memory$.ReadOnlySharedMemoryRegion, val.memoryRegion);
  };
  function GamepadMonitor_GamepadStopPolling_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GamepadMonitor_GamepadStopPolling_Params.prototype.initDefaults_ = function() {
  };
  GamepadMonitor_GamepadStopPolling_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GamepadMonitor_GamepadStopPolling_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GamepadMonitor_GamepadStopPolling_Params.encodedSize = codec.kStructHeaderSize + 0;

  GamepadMonitor_GamepadStopPolling_Params.decode = function(decoder) {
    var packed;
    var val = new GamepadMonitor_GamepadStopPolling_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  GamepadMonitor_GamepadStopPolling_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GamepadMonitor_GamepadStopPolling_Params.encodedSize);
    encoder.writeUint32(0);
  };
  function GamepadMonitor_GamepadStopPolling_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GamepadMonitor_GamepadStopPolling_ResponseParams.prototype.initDefaults_ = function() {
  };
  GamepadMonitor_GamepadStopPolling_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GamepadMonitor_GamepadStopPolling_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GamepadMonitor_GamepadStopPolling_ResponseParams.encodedSize = codec.kStructHeaderSize + 0;

  GamepadMonitor_GamepadStopPolling_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new GamepadMonitor_GamepadStopPolling_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  GamepadMonitor_GamepadStopPolling_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GamepadMonitor_GamepadStopPolling_ResponseParams.encodedSize);
    encoder.writeUint32(0);
  };
  function GamepadMonitor_SetObserver_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GamepadMonitor_SetObserver_Params.prototype.initDefaults_ = function() {
    this.gamepadObserver = new GamepadObserverPtr();
  };
  GamepadMonitor_SetObserver_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GamepadMonitor_SetObserver_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GamepadMonitor_SetObserver_Params.gamepadObserver
    err = messageValidator.validateInterface(offset + codec.kStructHeaderSize + 0, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GamepadMonitor_SetObserver_Params.encodedSize = codec.kStructHeaderSize + 8;

  GamepadMonitor_SetObserver_Params.decode = function(decoder) {
    var packed;
    var val = new GamepadMonitor_SetObserver_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.gamepadObserver =
        decoder.decodeStruct(new codec.Interface(GamepadObserverPtr));
    return val;
  };

  GamepadMonitor_SetObserver_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GamepadMonitor_SetObserver_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(new codec.Interface(GamepadObserverPtr), val.gamepadObserver);
  };
  function GamepadHapticsManager_PlayVibrationEffectOnce_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GamepadHapticsManager_PlayVibrationEffectOnce_Params.prototype.initDefaults_ = function() {
    this.padIndex = 0;
    this.type = 0;
    this.params = null;
  };
  GamepadHapticsManager_PlayVibrationEffectOnce_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GamepadHapticsManager_PlayVibrationEffectOnce_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    // validate GamepadHapticsManager_PlayVibrationEffectOnce_Params.type
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 4, GamepadHapticEffectType);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GamepadHapticsManager_PlayVibrationEffectOnce_Params.params
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, GamepadEffectParameters, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GamepadHapticsManager_PlayVibrationEffectOnce_Params.encodedSize = codec.kStructHeaderSize + 16;

  GamepadHapticsManager_PlayVibrationEffectOnce_Params.decode = function(decoder) {
    var packed;
    var val = new GamepadHapticsManager_PlayVibrationEffectOnce_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.padIndex =
        decoder.decodeStruct(codec.Uint32);
    val.type =
        decoder.decodeStruct(new codec.Enum(GamepadHapticEffectType));
    val.params =
        decoder.decodeStructPointer(GamepadEffectParameters);
    return val;
  };

  GamepadHapticsManager_PlayVibrationEffectOnce_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GamepadHapticsManager_PlayVibrationEffectOnce_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint32, val.padIndex);
    encoder.encodeStruct(codec.Int32, val.type);
    encoder.encodeStructPointer(GamepadEffectParameters, val.params);
  };
  function GamepadHapticsManager_PlayVibrationEffectOnce_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GamepadHapticsManager_PlayVibrationEffectOnce_ResponseParams.prototype.initDefaults_ = function() {
    this.result = 0;
  };
  GamepadHapticsManager_PlayVibrationEffectOnce_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GamepadHapticsManager_PlayVibrationEffectOnce_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GamepadHapticsManager_PlayVibrationEffectOnce_ResponseParams.result
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, GamepadHapticsResult);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GamepadHapticsManager_PlayVibrationEffectOnce_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  GamepadHapticsManager_PlayVibrationEffectOnce_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new GamepadHapticsManager_PlayVibrationEffectOnce_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.result =
        decoder.decodeStruct(new codec.Enum(GamepadHapticsResult));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  GamepadHapticsManager_PlayVibrationEffectOnce_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GamepadHapticsManager_PlayVibrationEffectOnce_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.result);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function GamepadHapticsManager_ResetVibrationActuator_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GamepadHapticsManager_ResetVibrationActuator_Params.prototype.initDefaults_ = function() {
    this.padIndex = 0;
  };
  GamepadHapticsManager_ResetVibrationActuator_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GamepadHapticsManager_ResetVibrationActuator_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  GamepadHapticsManager_ResetVibrationActuator_Params.encodedSize = codec.kStructHeaderSize + 8;

  GamepadHapticsManager_ResetVibrationActuator_Params.decode = function(decoder) {
    var packed;
    var val = new GamepadHapticsManager_ResetVibrationActuator_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.padIndex =
        decoder.decodeStruct(codec.Uint32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  GamepadHapticsManager_ResetVibrationActuator_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GamepadHapticsManager_ResetVibrationActuator_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint32, val.padIndex);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function GamepadHapticsManager_ResetVibrationActuator_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  GamepadHapticsManager_ResetVibrationActuator_ResponseParams.prototype.initDefaults_ = function() {
    this.result = 0;
  };
  GamepadHapticsManager_ResetVibrationActuator_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  GamepadHapticsManager_ResetVibrationActuator_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate GamepadHapticsManager_ResetVibrationActuator_ResponseParams.result
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, GamepadHapticsResult);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  GamepadHapticsManager_ResetVibrationActuator_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  GamepadHapticsManager_ResetVibrationActuator_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new GamepadHapticsManager_ResetVibrationActuator_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.result =
        decoder.decodeStruct(new codec.Enum(GamepadHapticsResult));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  GamepadHapticsManager_ResetVibrationActuator_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(GamepadHapticsManager_ResetVibrationActuator_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.result);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  var kGamepadObserver_GamepadConnected_Name = 2015100179;
  var kGamepadObserver_GamepadDisconnected_Name = 479895874;
  var kGamepadObserver_GamepadChanged_Name = 971612620;

  function GamepadObserverPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(GamepadObserver,
                                                   handleOrPtrInfo);
  }

  function GamepadObserverAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        GamepadObserver, associatedInterfacePtrInfo);
  }

  GamepadObserverAssociatedPtr.prototype =
      Object.create(GamepadObserverPtr.prototype);
  GamepadObserverAssociatedPtr.prototype.constructor =
      GamepadObserverAssociatedPtr;

  function GamepadObserverProxy(receiver) {
    this.receiver_ = receiver;
  }
  GamepadObserverPtr.prototype.gamepadConnected = function() {
    return GamepadObserverProxy.prototype.gamepadConnected
        .apply(this.ptr.getProxy(), arguments);
  };

  GamepadObserverProxy.prototype.gamepadConnected = function(index, gamepad) {
    var params_ = new GamepadObserver_GamepadConnected_Params();
    params_.index = index;
    params_.gamepad = gamepad;
    var builder = new codec.MessageV0Builder(
        kGamepadObserver_GamepadConnected_Name,
        codec.align(GamepadObserver_GamepadConnected_Params.encodedSize));
    builder.encodeStruct(GamepadObserver_GamepadConnected_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  GamepadObserverPtr.prototype.gamepadDisconnected = function() {
    return GamepadObserverProxy.prototype.gamepadDisconnected
        .apply(this.ptr.getProxy(), arguments);
  };

  GamepadObserverProxy.prototype.gamepadDisconnected = function(index, gamepad) {
    var params_ = new GamepadObserver_GamepadDisconnected_Params();
    params_.index = index;
    params_.gamepad = gamepad;
    var builder = new codec.MessageV0Builder(
        kGamepadObserver_GamepadDisconnected_Name,
        codec.align(GamepadObserver_GamepadDisconnected_Params.encodedSize));
    builder.encodeStruct(GamepadObserver_GamepadDisconnected_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  GamepadObserverPtr.prototype.gamepadChanged = function() {
    return GamepadObserverProxy.prototype.gamepadChanged
        .apply(this.ptr.getProxy(), arguments);
  };

  GamepadObserverProxy.prototype.gamepadChanged = function(changes) {
    var params_ = new GamepadObserver_GamepadChanged_Params();
    params_.changes = changes;
    var builder = new codec.MessageV0Builder(
        kGamepadObserver_GamepadChanged_Name,
        codec.align(GamepadObserver_GamepadChanged_Params.encodedSize));
    builder.encodeStruct(GamepadObserver_GamepadChanged_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };

  function GamepadObserverStub(delegate) {
    this.delegate_ = delegate;
  }
  GamepadObserverStub.prototype.gamepadConnected = function(index, gamepad) {
    return this.delegate_ && this.delegate_.gamepadConnected && this.delegate_.gamepadConnected(index, gamepad);
  }
  GamepadObserverStub.prototype.gamepadDisconnected = function(index, gamepad) {
    return this.delegate_ && this.delegate_.gamepadDisconnected && this.delegate_.gamepadDisconnected(index, gamepad);
  }
  GamepadObserverStub.prototype.gamepadChanged = function(changes) {
    return this.delegate_ && this.delegate_.gamepadChanged && this.delegate_.gamepadChanged(changes);
  }

  GamepadObserverStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kGamepadObserver_GamepadConnected_Name:
      var params = reader.decodeStruct(GamepadObserver_GamepadConnected_Params);
      this.gamepadConnected(params.index, params.gamepad);
      return true;
    case kGamepadObserver_GamepadDisconnected_Name:
      var params = reader.decodeStruct(GamepadObserver_GamepadDisconnected_Params);
      this.gamepadDisconnected(params.index, params.gamepad);
      return true;
    case kGamepadObserver_GamepadChanged_Name:
      var params = reader.decodeStruct(GamepadObserver_GamepadChanged_Params);
      this.gamepadChanged(params.changes);
      return true;
    default:
      return false;
    }
  };

  GamepadObserverStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  function validateGamepadObserverRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kGamepadObserver_GamepadConnected_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = GamepadObserver_GamepadConnected_Params;
      break;
      case kGamepadObserver_GamepadDisconnected_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = GamepadObserver_GamepadDisconnected_Params;
      break;
      case kGamepadObserver_GamepadChanged_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = GamepadObserver_GamepadChanged_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateGamepadObserverResponse(messageValidator) {
    return validator.validationError.NONE;
  }

  var GamepadObserver = {
    name: 'device.mojom.GamepadObserver',
    kVersion: 0,
    ptrClass: GamepadObserverPtr,
    proxyClass: GamepadObserverProxy,
    stubClass: GamepadObserverStub,
    validateRequest: validateGamepadObserverRequest,
    validateResponse: null,
  };
  GamepadObserverStub.prototype.validator = validateGamepadObserverRequest;
  GamepadObserverProxy.prototype.validator = null;
  var kGamepadMonitor_GamepadStartPolling_Name = 1691348369;
  var kGamepadMonitor_GamepadStopPolling_Name = 312793518;
  var kGamepadMonitor_SetObserver_Name = 1593676721;

  function GamepadMonitorPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(GamepadMonitor,
                                                   handleOrPtrInfo);
  }

  function GamepadMonitorAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        GamepadMonitor, associatedInterfacePtrInfo);
  }

  GamepadMonitorAssociatedPtr.prototype =
      Object.create(GamepadMonitorPtr.prototype);
  GamepadMonitorAssociatedPtr.prototype.constructor =
      GamepadMonitorAssociatedPtr;

  function GamepadMonitorProxy(receiver) {
    this.receiver_ = receiver;
  }
  GamepadMonitorPtr.prototype.gamepadStartPolling = function() {
    return GamepadMonitorProxy.prototype.gamepadStartPolling
        .apply(this.ptr.getProxy(), arguments);
  };

  GamepadMonitorProxy.prototype.gamepadStartPolling = function() {
    var params_ = new GamepadMonitor_GamepadStartPolling_Params();
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kGamepadMonitor_GamepadStartPolling_Name,
          codec.align(GamepadMonitor_GamepadStartPolling_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(GamepadMonitor_GamepadStartPolling_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(GamepadMonitor_GamepadStartPolling_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  GamepadMonitorPtr.prototype.gamepadStopPolling = function() {
    return GamepadMonitorProxy.prototype.gamepadStopPolling
        .apply(this.ptr.getProxy(), arguments);
  };

  GamepadMonitorProxy.prototype.gamepadStopPolling = function() {
    var params_ = new GamepadMonitor_GamepadStopPolling_Params();
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kGamepadMonitor_GamepadStopPolling_Name,
          codec.align(GamepadMonitor_GamepadStopPolling_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(GamepadMonitor_GamepadStopPolling_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(GamepadMonitor_GamepadStopPolling_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  GamepadMonitorPtr.prototype.setObserver = function() {
    return GamepadMonitorProxy.prototype.setObserver
        .apply(this.ptr.getProxy(), arguments);
  };

  GamepadMonitorProxy.prototype.setObserver = function(gamepadObserver) {
    var params_ = new GamepadMonitor_SetObserver_Params();
    params_.gamepadObserver = gamepadObserver;
    var builder = new codec.MessageV0Builder(
        kGamepadMonitor_SetObserver_Name,
        codec.align(GamepadMonitor_SetObserver_Params.encodedSize));
    builder.encodeStruct(GamepadMonitor_SetObserver_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };

  function GamepadMonitorStub(delegate) {
    this.delegate_ = delegate;
  }
  GamepadMonitorStub.prototype.gamepadStartPolling = function() {
    return this.delegate_ && this.delegate_.gamepadStartPolling && this.delegate_.gamepadStartPolling();
  }
  GamepadMonitorStub.prototype.gamepadStopPolling = function() {
    return this.delegate_ && this.delegate_.gamepadStopPolling && this.delegate_.gamepadStopPolling();
  }
  GamepadMonitorStub.prototype.setObserver = function(gamepadObserver) {
    return this.delegate_ && this.delegate_.setObserver && this.delegate_.setObserver(gamepadObserver);
  }

  GamepadMonitorStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kGamepadMonitor_SetObserver_Name:
      var params = reader.decodeStruct(GamepadMonitor_SetObserver_Params);
      this.setObserver(params.gamepadObserver);
      return true;
    default:
      return false;
    }
  };

  GamepadMonitorStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kGamepadMonitor_GamepadStartPolling_Name:
      var params = reader.decodeStruct(GamepadMonitor_GamepadStartPolling_Params);
      this.gamepadStartPolling().then(function(response) {
        var responseParams =
            new GamepadMonitor_GamepadStartPolling_ResponseParams();
        responseParams.memoryRegion = response.memoryRegion;
        var builder = new codec.MessageV1Builder(
            kGamepadMonitor_GamepadStartPolling_Name,
            codec.align(GamepadMonitor_GamepadStartPolling_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(GamepadMonitor_GamepadStartPolling_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kGamepadMonitor_GamepadStopPolling_Name:
      var params = reader.decodeStruct(GamepadMonitor_GamepadStopPolling_Params);
      this.gamepadStopPolling().then(function(response) {
        var responseParams =
            new GamepadMonitor_GamepadStopPolling_ResponseParams();
        var builder = new codec.MessageV1Builder(
            kGamepadMonitor_GamepadStopPolling_Name,
            codec.align(GamepadMonitor_GamepadStopPolling_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(GamepadMonitor_GamepadStopPolling_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    default:
      return false;
    }
  };

  function validateGamepadMonitorRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kGamepadMonitor_GamepadStartPolling_Name:
        if (message.expectsResponse())
          paramsClass = GamepadMonitor_GamepadStartPolling_Params;
      break;
      case kGamepadMonitor_GamepadStopPolling_Name:
        if (message.expectsResponse())
          paramsClass = GamepadMonitor_GamepadStopPolling_Params;
      break;
      case kGamepadMonitor_SetObserver_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = GamepadMonitor_SetObserver_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateGamepadMonitorResponse(messageValidator) {
   var message = messageValidator.message;
   var paramsClass = null;
   switch (message.getName()) {
      case kGamepadMonitor_GamepadStartPolling_Name:
        if (message.isResponse())
          paramsClass = GamepadMonitor_GamepadStartPolling_ResponseParams;
        break;
      case kGamepadMonitor_GamepadStopPolling_Name:
        if (message.isResponse())
          paramsClass = GamepadMonitor_GamepadStopPolling_ResponseParams;
        break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  var GamepadMonitor = {
    name: 'device.mojom.GamepadMonitor',
    kVersion: 0,
    ptrClass: GamepadMonitorPtr,
    proxyClass: GamepadMonitorProxy,
    stubClass: GamepadMonitorStub,
    validateRequest: validateGamepadMonitorRequest,
    validateResponse: validateGamepadMonitorResponse,
  };
  GamepadMonitorStub.prototype.validator = validateGamepadMonitorRequest;
  GamepadMonitorProxy.prototype.validator = validateGamepadMonitorResponse;
  var kGamepadHapticsManager_PlayVibrationEffectOnce_Name = 1492762121;
  var kGamepadHapticsManager_ResetVibrationActuator_Name = 539368469;

  function GamepadHapticsManagerPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(GamepadHapticsManager,
                                                   handleOrPtrInfo);
  }

  function GamepadHapticsManagerAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        GamepadHapticsManager, associatedInterfacePtrInfo);
  }

  GamepadHapticsManagerAssociatedPtr.prototype =
      Object.create(GamepadHapticsManagerPtr.prototype);
  GamepadHapticsManagerAssociatedPtr.prototype.constructor =
      GamepadHapticsManagerAssociatedPtr;

  function GamepadHapticsManagerProxy(receiver) {
    this.receiver_ = receiver;
  }
  GamepadHapticsManagerPtr.prototype.playVibrationEffectOnce = function() {
    return GamepadHapticsManagerProxy.prototype.playVibrationEffectOnce
        .apply(this.ptr.getProxy(), arguments);
  };

  GamepadHapticsManagerProxy.prototype.playVibrationEffectOnce = function(padIndex, type, params) {
    var params_ = new GamepadHapticsManager_PlayVibrationEffectOnce_Params();
    params_.padIndex = padIndex;
    params_.type = type;
    params_.params = params;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kGamepadHapticsManager_PlayVibrationEffectOnce_Name,
          codec.align(GamepadHapticsManager_PlayVibrationEffectOnce_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(GamepadHapticsManager_PlayVibrationEffectOnce_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(GamepadHapticsManager_PlayVibrationEffectOnce_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  GamepadHapticsManagerPtr.prototype.resetVibrationActuator = function() {
    return GamepadHapticsManagerProxy.prototype.resetVibrationActuator
        .apply(this.ptr.getProxy(), arguments);
  };

  GamepadHapticsManagerProxy.prototype.resetVibrationActuator = function(padIndex) {
    var params_ = new GamepadHapticsManager_ResetVibrationActuator_Params();
    params_.padIndex = padIndex;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kGamepadHapticsManager_ResetVibrationActuator_Name,
          codec.align(GamepadHapticsManager_ResetVibrationActuator_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(GamepadHapticsManager_ResetVibrationActuator_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(GamepadHapticsManager_ResetVibrationActuator_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };

  function GamepadHapticsManagerStub(delegate) {
    this.delegate_ = delegate;
  }
  GamepadHapticsManagerStub.prototype.playVibrationEffectOnce = function(padIndex, type, params) {
    return this.delegate_ && this.delegate_.playVibrationEffectOnce && this.delegate_.playVibrationEffectOnce(padIndex, type, params);
  }
  GamepadHapticsManagerStub.prototype.resetVibrationActuator = function(padIndex) {
    return this.delegate_ && this.delegate_.resetVibrationActuator && this.delegate_.resetVibrationActuator(padIndex);
  }

  GamepadHapticsManagerStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  GamepadHapticsManagerStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kGamepadHapticsManager_PlayVibrationEffectOnce_Name:
      var params = reader.decodeStruct(GamepadHapticsManager_PlayVibrationEffectOnce_Params);
      this.playVibrationEffectOnce(params.padIndex, params.type, params.params).then(function(response) {
        var responseParams =
            new GamepadHapticsManager_PlayVibrationEffectOnce_ResponseParams();
        responseParams.result = response.result;
        var builder = new codec.MessageV1Builder(
            kGamepadHapticsManager_PlayVibrationEffectOnce_Name,
            codec.align(GamepadHapticsManager_PlayVibrationEffectOnce_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(GamepadHapticsManager_PlayVibrationEffectOnce_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kGamepadHapticsManager_ResetVibrationActuator_Name:
      var params = reader.decodeStruct(GamepadHapticsManager_ResetVibrationActuator_Params);
      this.resetVibrationActuator(params.padIndex).then(function(response) {
        var responseParams =
            new GamepadHapticsManager_ResetVibrationActuator_ResponseParams();
        responseParams.result = response.result;
        var builder = new codec.MessageV1Builder(
            kGamepadHapticsManager_ResetVibrationActuator_Name,
            codec.align(GamepadHapticsManager_ResetVibrationActuator_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(GamepadHapticsManager_ResetVibrationActuator_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    default:
      return false;
    }
  };

  function validateGamepadHapticsManagerRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kGamepadHapticsManager_PlayVibrationEffectOnce_Name:
        if (message.expectsResponse())
          paramsClass = GamepadHapticsManager_PlayVibrationEffectOnce_Params;
      break;
      case kGamepadHapticsManager_ResetVibrationActuator_Name:
        if (message.expectsResponse())
          paramsClass = GamepadHapticsManager_ResetVibrationActuator_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateGamepadHapticsManagerResponse(messageValidator) {
   var message = messageValidator.message;
   var paramsClass = null;
   switch (message.getName()) {
      case kGamepadHapticsManager_PlayVibrationEffectOnce_Name:
        if (message.isResponse())
          paramsClass = GamepadHapticsManager_PlayVibrationEffectOnce_ResponseParams;
        break;
      case kGamepadHapticsManager_ResetVibrationActuator_Name:
        if (message.isResponse())
          paramsClass = GamepadHapticsManager_ResetVibrationActuator_ResponseParams;
        break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  var GamepadHapticsManager = {
    name: 'device.mojom.GamepadHapticsManager',
    kVersion: 0,
    ptrClass: GamepadHapticsManagerPtr,
    proxyClass: GamepadHapticsManagerProxy,
    stubClass: GamepadHapticsManagerStub,
    validateRequest: validateGamepadHapticsManagerRequest,
    validateResponse: validateGamepadHapticsManagerResponse,
  };
  GamepadHapticsManagerStub.prototype.validator = validateGamepadHapticsManagerRequest;
  GamepadHapticsManagerProxy.prototype.validator = validateGamepadHapticsManagerResponse;
  exports.GamepadMapping = GamepadMapping;
  exports.GamepadHand = GamepadHand;
  exports.GamepadHapticActuatorType = GamepadHapticActuatorType;
  exports.GamepadHapticEffectType = GamepadHapticEffectType;
  exports.GamepadHapticsResult = GamepadHapticsResult;
  exports.GamepadQuaternion = GamepadQuaternion;
  exports.GamepadVector = GamepadVector;
  exports.GamepadButton = GamepadButton;
  exports.ButtonChange = ButtonChange;
  exports.AxisChange = AxisChange;
  exports.GamepadChanges = GamepadChanges;
  exports.GamepadTouch = GamepadTouch;
  exports.GamepadPose = GamepadPose;
  exports.GamepadHapticActuator = GamepadHapticActuator;
  exports.Gamepad = Gamepad;
  exports.GamepadEffectParameters = GamepadEffectParameters;
  exports.GamepadObserver = GamepadObserver;
  exports.GamepadObserverPtr = GamepadObserverPtr;
  exports.GamepadObserverAssociatedPtr = GamepadObserverAssociatedPtr;
  exports.GamepadMonitor = GamepadMonitor;
  exports.GamepadMonitorPtr = GamepadMonitorPtr;
  exports.GamepadMonitorAssociatedPtr = GamepadMonitorAssociatedPtr;
  exports.GamepadHapticsManager = GamepadHapticsManager;
  exports.GamepadHapticsManagerPtr = GamepadHapticsManagerPtr;
  exports.GamepadHapticsManagerAssociatedPtr = GamepadHapticsManagerAssociatedPtr;
})();